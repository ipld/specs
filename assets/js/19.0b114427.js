(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{374:function(e,t,a){"use strict";a.r(t);var r=a(42),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"specification-content-addressable-archives-car-car"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification-content-addressable-archives-car-car"}},[e._v("#")]),e._v(" Specification: Content Addressable aRchives (CAR / .car)")]),e._v(" "),a("p",[a("strong",[e._v("Status: Draft")])]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#summary"}},[e._v("Summary")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#format-description"}},[e._v("Format Description")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#header"}},[e._v("Header")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#constraints"}},[e._v("Constraints")])])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#data"}},[e._v("Data")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#length"}},[e._v("Length")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#cid"}},[e._v("CID")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#data-1"}},[e._v("Data")])])])])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#additional-considerations"}},[e._v("Additional Considerations")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#determinism"}},[e._v("Determinism")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#performance"}},[e._v("Performance")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#security-and-verifiability"}},[e._v("Security and Verifiability")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#indexing-and-seeking-reads"}},[e._v("Indexing and Seeking Reads")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#padding"}},[e._v("Padding")])])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#implementations"}},[e._v("Implementations")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#go"}},[e._v("Go")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#javascript"}},[e._v("JavaScript")])])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#unresolved-items"}},[e._v("Unresolved Items")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#number-of-roots"}},[e._v("Number of roots")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#zero-blocks"}},[e._v("Zero blocks")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#root-cid-block-existence"}},[e._v("Root CID block existence")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#cid-version"}},[e._v("CID version")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#duplicate-blocks"}},[e._v("Duplicate Blocks")])])])])]),e._v(" "),a("h2",{attrs:{id:"summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[e._v("#")]),e._v(" Summary")]),e._v(" "),a("p",[e._v("The CAR format (Content Addressable aRchives) can be used to store content addressable objects in the form of IPLD block data as a sequence of bytes; typically in a file with a "),a("code",[e._v(".car")]),e._v(" filename extension.")]),e._v(" "),a("p",[e._v("The CAR format is intended as a serialized representation of any IPLD DAG (graph) as the concatenation of its blocks, plus a header that describes the graphs in the file (via root CIDs). The requirement for the blocks in a CAR to form coherent DAGs is not strict, so the CAR format may also be used to store arbitrary IPLD blocks.")]),e._v(" "),a("p",[e._v("In addition to the binary block data, storage overhead for the CAR format consists of:")]),e._v(" "),a("ul",[a("li",[e._v("A header block encoded as "),a("RouterLink",{attrs:{to:"/block-layer/codecs/dag-cbor.html"}},[e._v("DAG-CBOR")]),e._v(" containing the format version and an array of root CIDs")],1),e._v(" "),a("li",[e._v("A CID for each block preceding its binary data")]),e._v(" "),a("li",[e._v("A compressed integer prefixing each block (including the header block) indicating the total length of that block, including the length of the encoded CID")])]),e._v(" "),a("p",[e._v("This diagram shows how IPLD blocks, their root CID, and a header combine to form a CAR.")]),e._v(" "),a("p",[a("img",{attrs:{src:"content-addressable-archives.png",alt:"Content Addressable aRchive Diagram"}})]),e._v(" "),a("p",[e._v("The name "),a("em",[e._v("Certified ARchive")]),e._v(" has also "),a("a",{attrs:{href:"https://github.com/ipfs/archive-format",target:"_blank",rel:"noopener noreferrer"}},[e._v("previously been used"),a("OutboundLink")],1),e._v(" to refer to the CAR format.")]),e._v(" "),a("h2",{attrs:{id:"format-description"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#format-description"}},[e._v("#")]),e._v(" Format Description")]),e._v(" "),a("p",[e._v('The CAR format comprises a sequence of length-prefixed IPLD block data, where the first block in the CAR is the Header encoded as CBOR, and the remaining blocks form the Data component of the CAR and are each additionally prefixed with their CIDs. The length prefix of each block in a CAR is encoded as a "varint"—an unsigned '),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/LEB128",target:"_blank",rel:"noopener noreferrer"}},[e._v("LEB128"),a("OutboundLink")],1),e._v(" integer. This integer specifies the number of remaining bytes for that block entry—excluding the bytes used to encode the integer, but including the CID for non-header blocks.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("|--------- Header --------| |---------------------------------- Data -----------------------------------|\n\n[ varint | DAG-CBOR block ] [ varint | CID | block ] [ varint | CID | block ] [ varint | CID | block ] …\n")])])]),a("h3",{attrs:{id:"header"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#header"}},[e._v("#")]),e._v(" Header")]),e._v(" "),a("p",[e._v("The first bytes of the CAR format hold a varint, this unsigned integer specifies the number of bytes beyond the varint itself that contain the "),a("em",[e._v("Header")]),e._v(" block. This Header block is a byte array DAG-CBOR (CBOR with tag 42 for CIDs) encoded object holding the version number and array of roots. As an "),a("RouterLink",{attrs:{to:"/schemas/"}},[e._v("IPLD Schema")]),e._v(":")],1),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("CarHeader")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  version Int\n  roots "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("&")]),e._v("Any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("h4",{attrs:{id:"constraints"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constraints"}},[e._v("#")]),e._v(" Constraints")]),e._v(" "),a("ul",[a("li",[e._v("The "),a("code",[e._v("version")]),e._v(" is always a value of "),a("code",[e._v("1")]),e._v(". Future iterations of this specification may make use of "),a("code",[e._v("version")]),e._v(" to introduce variations of the format.")]),e._v(" "),a("li",[e._v("The "),a("code",[e._v("roots")]),e._v(" array must contain "),a("strong",[e._v("one or more")]),e._v(" CIDs, each of which should be present somewhere in the remainder of the CAR.")])]),e._v(" "),a("p",[a("em",[e._v("(Caveats: see "),a("a",{attrs:{href:"#number-of-roots"}},[e._v("Number of roots")]),e._v(" and "),a("a",{attrs:{href:"#root-cid-block-existence"}},[e._v("Root CID block existence")]),e._v(" under Unresolved Issues.)")])]),e._v(" "),a("h3",{attrs:{id:"data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data"}},[e._v("#")]),e._v(" Data")]),e._v(" "),a("p",[e._v("Immediately following the Header block, "),a("strong",[e._v("one or more")]),e._v(" IPLD blocks are concatenated to form the "),a("em",[e._v("Data")]),e._v(" section of the CAR format. "),a("em",[e._v("(Caveat: see "),a("a",{attrs:{href:"#zero-blocks"}},[e._v("Zero blocks")]),e._v(" under Unresolved Issues.)")]),e._v(" Each block is encoded into a "),a("em",[e._v("Section")]),e._v(" by the concatenation of the following values:")]),e._v(" "),a("ol",[a("li",[e._v("Length in bytes of the combined CID and data in this Section, encoded as a varint")]),e._v(" "),a("li",[e._v("CID of the block in this Section, encoded in the raw byte form of the CID")]),e._v(" "),a("li",[e._v("Binary data of the block")])]),e._v(" "),a("h4",{attrs:{id:"length"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#length"}},[e._v("#")]),e._v(" Length")]),e._v(" "),a("p",[e._v("Each Section begins with a varint representation of an unsigned integer indicating the number of bytes containing the remainder of the section.")]),e._v(" "),a("h4",{attrs:{id:"cid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cid"}},[e._v("#")]),e._v(" CID")]),e._v(" "),a("p",[e._v("Following the Length, the CID of the block is included in raw byte form. A decoder reading a Section must decode the CID according to CID byte encoding rules, which don't provide a stable length. See https://github.com/multiformats/cid for details on the encoding of a CID. CIDv0 and CIDv1 are currently supported. "),a("em",[e._v("(Caveat: see "),a("a",{attrs:{href:"#cid-version"}},[e._v("CID version")]),e._v(" under Unresolved Issues.)")])]),e._v(" "),a("p",[a("strong",[e._v("CID byte decoding summary")])]),e._v(" "),a("p",[a("em",[e._v("See the "),a("a",{attrs:{href:"https://github.com/multiformats/cid",target:"_blank",rel:"noopener noreferrer"}},[e._v("CID specification"),a("OutboundLink")],1),e._v(" for full details.")])]),e._v(" "),a("p",[e._v("A CIDv0 is indicated by a first byte of "),a("code",[e._v("0x12")]),e._v(" followed by "),a("code",[e._v("0x20")]),e._v(" which specifies a 32-byte ("),a("code",[e._v("0x20")]),e._v(") length SHA2-256 ("),a("a",{attrs:{href:"https://github.com/multiformats/multicodec/blob/master/table.csv",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("0x12")]),a("OutboundLink")],1),e._v(") digest.")]),e._v(" "),a("p",[e._v("Failure to find "),a("code",[e._v("0x12, 0x20")]),e._v(" indicates a CIDv1 which is decoded by reading:")]),e._v(" "),a("ol",[a("li",[e._v("Version as an unsigned varint (should be "),a("code",[e._v("1")]),e._v(")")]),e._v(" "),a("li",[e._v("Codec as an unsigned varint (valid according to the "),a("a",{attrs:{href:"https://github.com/multiformats/multicodec/blob/master/table.csv",target:"_blank",rel:"noopener noreferrer"}},[e._v("multicodec table"),a("OutboundLink")],1),e._v(")")]),e._v(" "),a("li",[e._v("The raw bytes of a "),a("a",{attrs:{href:"https://github.com/multiformats/multihash",target:"_blank",rel:"noopener noreferrer"}},[e._v("multihash"),a("OutboundLink")],1)])]),e._v(" "),a("p",[e._v("Reading the multihash requires a partial decode in order to determine the length:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("| hash function code (varint) | digest size (varint) | digest |\n")])])]),a("p",[e._v("The first two bytes of a multihash are varints, where the second varint is an unsigned integer indicating the length of the remaining portion of the multihash. Therefore, a manual decode requires two varint reads and then copying the bytes of those varints in addition to the number of bytes indicated by the second varint into a byte array.")]),e._v(" "),a("h4",{attrs:{id:"data-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-2"}},[e._v("#")]),e._v(" Data")]),e._v(" "),a("p",[e._v("The remainder of a Section, after length-prefix and CID, comprises the raw byte data of the IPLD block. The encoded block may be any IPLD block format as specified by the codec in the CID. Typical codecs will be "),a("RouterLink",{attrs:{to:"/block-layer/codecs/dag-pb.html"}},[e._v("DAG-PB")]),e._v(", "),a("RouterLink",{attrs:{to:"/block-layer/codecs/dag-cbor.html"}},[e._v("DAG-CBOR")]),e._v(" or "),a("a",{attrs:{href:"https://github.com/ipld/specs/issues/223",target:"_blank",rel:"noopener noreferrer"}},[e._v("RAW"),a("OutboundLink")],1),e._v(".")],1),e._v(" "),a("h2",{attrs:{id:"additional-considerations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#additional-considerations"}},[e._v("#")]),e._v(" Additional Considerations")]),e._v(" "),a("h3",{attrs:{id:"determinism"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#determinism"}},[e._v("#")]),e._v(" Determinism")]),e._v(" "),a("p",[e._v("Deterministic CAR creation is not covered by this specification. However, deterministic generation of a CAR from a given graph is possible and is relied upon by certain uses of the format, most notably, "),a("a",{attrs:{href:"https://filecoin-project.github.io/specs",target:"_blank",rel:"noopener noreferrer"}},[e._v("Filecoin"),a("OutboundLink")],1),e._v(". Specifically a "),a("em",[e._v("filecoin-deterministic car-file")]),e._v(" is currently implementation-defined as containing all DAG-forming blocks in first-seen order, as a result of a depth-first DAG traversal starting from a single root.")]),e._v(" "),a("p",[e._v("Additional rules for the generation of the CAR format may be applied in order to ensure that the same CAR is always generated from the same data. The burden of this determinism is primarily placed on "),a("RouterLink",{attrs:{to:"/selectors/selectors.html"}},[e._v("selectors")]),e._v(" whereby a given selector applied to a given graph will always yield blocks in the same order regardless of implementation.")],1),e._v(" "),a("p",[e._v("Care regarding the ordering of the "),a("code",[e._v("roots")]),e._v(" array in the Header, as well as consideration for CID version "),a("em",[e._v("(see "),a("a",{attrs:{href:"#cid-version"}},[e._v("below")]),e._v(")")]),e._v(" and avoidance of duplicate blocks "),a("em",[e._v("(see "),a("a",{attrs:{href:"#duplicate-blocks"}},[e._v("below")]),e._v(")")]),e._v(" may also be required for strict determinism.")]),e._v(" "),a("p",[e._v("All such considerations are deferred to the user of the CAR format and should be documented there as this specification does not inherently support determinism.")]),e._v(" "),a("h3",{attrs:{id:"performance"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#performance"}},[e._v("#")]),e._v(" Performance")]),e._v(" "),a("p",[e._v("Some considerations regarding performance:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Streaming")]),e._v(": the CAR format is ideal for dumping blocks via streaming reads as the Header can be loaded first and minimal state is required for ongoing parsing.")]),e._v(" "),a("li",[a("strong",[e._v("Individual block reads")]),e._v(": as the CAR format contains no index information, reads require either a partial scan to discover the location of a required block or an external index must be maintained and referenced for a seek and partial read of that data. See below regarding indexing.")]),e._v(" "),a("li",[a("strong",[e._v("DAG traversal")]),e._v(': without an external index, traversal of a DAG specified by a "root" CID is not possible without dumping all blocks into a more convenient data store or by partial scans to find each block as required, which will likely be too inefficient to be practical.')]),e._v(" "),a("li",[a("strong",[e._v("Modification")]),e._v(": CARs may be appended after initial write as there is no constraint in the Header regarding total length. Care must be taken in appending if a CAR is intended to contain coherent DAG data.")])]),e._v(" "),a("h3",{attrs:{id:"security-and-verifiability"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#security-and-verifiability"}},[e._v("#")]),e._v(" Security and Verifiability")]),e._v(" "),a("p",[e._v("The roots specified by the Header of a CAR must appear somewhere in its Data section, however there is no requirement that the roots define entire DAGs, nor that all blocks in a CAR must be part of DAGs described by the root CIDs in the Header. Therefore, the roots must not be used alone to determine or differentiate the contents of a CAR.")]),e._v(" "),a("p",[e._v("The CAR format contains no internal means, beyond the IPLD block formats and their CIDs, to verify or differentiate contents. Where such a requirement exists, this must be performed externally, such as creating a digest of the entire CAR.")]),e._v(" "),a("h3",{attrs:{id:"indexing-and-seeking-reads"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#indexing-and-seeking-reads"}},[e._v("#")]),e._v(" Indexing and Seeking Reads")]),e._v(" "),a("p",[e._v("The CAR format contains no internal indexing, any indexing must be stored externally to a CAR. However, such indexing is possible and makes seeking reads practical. An index storing byte offset (of Section start or block data start) and length (of Section or block data), keyed by CID, will enable a single block read by seeking to the offset and reading the block data. The format of any such index is not specified here and is left up to CAR format parsing implementations.")]),e._v(" "),a("h3",{attrs:{id:"padding"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#padding"}},[e._v("#")]),e._v(" Padding")]),e._v(" "),a("p",[e._v("The CAR format contains no specified means of padding to achieve specific total archive sizes or internal byte offset alignment of block data. Because it is not a requirement that each block be part of a coherent DAG under one of the roots of the CAR, dummy block entries may be used to achieve padding. Such padding should also account for the size of the length-prefix varint and the CID for a section. All sections must be valid and dummy entries should still decode to valid IPLD blocks.")]),e._v(" "),a("h2",{attrs:{id:"implementations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementations"}},[e._v("#")]),e._v(" Implementations")]),e._v(" "),a("h3",{attrs:{id:"go"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#go"}},[e._v("#")]),e._v(" Go")]),e._v(" "),a("p",[e._v("https://github.com/ipld/go-car")]),e._v(" "),a("p",[e._v("As used in Filecoin for genesis block sharing. Supports creation via a DAG walk from a datastore:")]),e._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[e._v("WriteCar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("ctx context"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("Context"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" ds format"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("DAGService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" roots "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("cid"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("Cid"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" w io"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("Writer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),a("p",[e._v("And writing to a data store via "),a("code",[e._v("Put(block)")]),e._v(" operations:")]),e._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[e._v("LoadCar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("s Store"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" r io"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("Reader"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v("CarHeader"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),a("h3",{attrs:{id:"javascript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript"}},[e._v("#")]),e._v(" JavaScript")]),e._v(" "),a("p",[e._v("https://github.com/rvagg/js-datastore-car")]),e._v(" "),a("p",[e._v("Wraps in "),a("a",{attrs:{href:"https://github.com/ipfs/interface-datastore",target:"_blank",rel:"noopener noreferrer"}},[e._v("Datastore"),a("OutboundLink")],1),e._v(" interface with various modes for reading and writing to support different use-cases—including streaming reading and writing:")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("async")]),e._v(" CarDatastore"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("readBuffer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("buffer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("async")]),e._v(" CarDatastore"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("readFileComplete")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("file"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("async")]),e._v(" CarDatastore"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("readStreamComplete")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("stream"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("async")]),e._v(" CarDatastore"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("readStreaming")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("stream"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("async")]),e._v(" CarDatastore"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("writeStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("stream"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),a("p",[e._v("Also supports an "),a("code",[e._v("indexer()")]),e._v(" that parses a file or stream and yields block index data including CID, offset and length, in addition to a "),a("code",[e._v("readRaw()")]),e._v(" to read individual blocks according to their index data.")]),e._v(" "),a("h2",{attrs:{id:"unresolved-items"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unresolved-items"}},[e._v("#")]),e._v(" Unresolved Items")]),e._v(" "),a("h3",{attrs:{id:"number-of-roots"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#number-of-roots"}},[e._v("#")]),e._v(" Number of roots")]),e._v(" "),a("p",[e._v("Regarding the "),a("code",[e._v("roots")]),e._v(" property of the Header block:")]),e._v(" "),a("ul",[a("li",[e._v("The current Go implementation assumes at least one CID when creating a CAR")]),e._v(" "),a("li",[e._v("The current Go implementation requires at least one CID when reading a CAR")]),e._v(" "),a("li",[e._v("The current JavaScript implementation allows for zero or more roots")]),e._v(" "),a("li",[e._v("Current usage of the CAR format in Filecoin requires exactly one CID")])]),e._v(" "),a("p",[e._v("It is unresolved how the "),a("code",[e._v("roots")]),e._v(" array should be constrained. "),a("strong",[e._v("It is recommended that only a single root CID be used in this version of the CAR format.")])]),e._v(" "),a("p",[e._v('A work-around for use-cases where the inclusion of a root CID is difficult but needing to be safely within the "at least one" recommendation is to use an empty CID: '),a("code",[e._v("\\x01\\x55\\x00\\x00")]),e._v(' (zero-length "identity" multihash with "raw" codec). Since current implemetations for this version of the CAR specification don\'t check for the existence of root CIDs '),a("em",[e._v("(see "),a("a",{attrs:{href:"#root-cid-block-existence"}},[e._v("Root CID block existence")]),e._v(")")]),e._v(", this will be safe as far as CAR implementations are concerned. However, there is no guarantee that applications that use CAR files will correctly consume (ignore) this empty root CID.")]),e._v(" "),a("h3",{attrs:{id:"zero-blocks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zero-blocks"}},[e._v("#")]),e._v(" Zero blocks")]),e._v(" "),a("p",[e._v("It is unresolved whether a valid CAR must contain "),a("em",[e._v("at least one")]),e._v(" block or whether the empty CAR is a valid format and should be accepted by encoders and decoders.")]),e._v(" "),a("h3",{attrs:{id:"root-cid-block-existence"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#root-cid-block-existence"}},[e._v("#")]),e._v(" Root CID block existence")]),e._v(" "),a("p",[e._v("It is unresolved whether an implementation must verify that a CID present in the roots array of the Header also appears as a block in the archive. While it is expected that this would be the case, it is unresolved whether encoders and decoders must validate the existence of root blocks in the archive.")]),e._v(" "),a("p",[e._v("Current implementations of this version of the CAR specification "),a("em",[e._v("do not")]),e._v(" check for root block existence in the CAR body.")]),e._v(" "),a("h3",{attrs:{id:"cid-version"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cid-version"}},[e._v("#")]),e._v(" CID version")]),e._v(" "),a("p",[e._v("It is unresolved whether both CID versions 0 and 1 format are valid in the roots array and at the start of each block Section. Current implementations do not check CID version in the roots array, and both CID versions are also acceptable in each block Section. Discussions on this specification have suggested limiting CIDs used throughout the format (not within blocks) to CIDv1—requiring conversion if an encoder is provided with a CIDv0 and requiring readers of a CAR to ensure CIDv1 is the only available block key.")]),e._v(" "),a("h3",{attrs:{id:"duplicate-blocks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#duplicate-blocks"}},[e._v("#")]),e._v(" Duplicate Blocks")]),e._v(" "),a("p",[e._v("The possibility of duplicate blocks in a single CAR (such as for padding) is currently not specified.")])])}),[],!1,null,null,null);t.default=s.exports}}]);