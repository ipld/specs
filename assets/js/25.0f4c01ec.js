(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{383:function(e,t,a){"use strict";a.r(t);var n=a(42),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"a-quick-primer-and-glossary-of-type-theory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-quick-primer-and-glossary-of-type-theory"}},[e._v("#")]),e._v(" A quick Primer and Glossary of Type Theory")]),e._v(" "),a("p",[e._v('This document provides a quick overview of "type theory", and specifically,\nhow we use it to reason about data and design in IPLD.')]),e._v(" "),a("p",[e._v('We take "type theory" to mean primarily: a way of reasoning about programs\nand data by counting how many possible states they may have.\nWe call this counting of possible, inhabitable states counting "cardinality".\n(We acknowledge that there\'s much more to "type theory" than this in the\nbroader literature and history of computer science, but since IPLD is\nabout '),a("em",[e._v("data")]),e._v(", focusing on this subset of type theory suits our purposes.)")]),e._v(" "),a("p",[e._v("You'll find this document is linked to by the IPLD specs -- both for describing\nkey theoretical foundations of the Data Model, and also to better describe some\nof the advanced features in the Schema layer (plus the reasons for them) --\n"),a("em",[e._v("and")]),e._v(" you'll also find this document linked to by the\n"),a("a",{attrs:{href:"../design/libraries"}},[e._v("library design notes")]),e._v(", where we use some of this\nterminology to describe features of programming languages without resorting\nto language-specific vocabulary.")]),e._v(" "),a("h2",{attrs:{id:"cardinality"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cardinality"}},[e._v("#")]),e._v(" Cardinality")]),e._v(" "),a("p",[e._v('"Cardinality" means "'),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Cardinality",target:"_blank",rel:"noopener noreferrer"}},[e._v("the number of elements in a set"),a("OutboundLink")],1),e._v('".')]),e._v(" "),a("p",[e._v('In IPLD, we use the phrase "the cardinality of a type" to define how many members a type can have.')]),e._v(" "),a("h3",{attrs:{id:"why-is-cardinality-important"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#why-is-cardinality-important"}},[e._v("#")]),e._v(" Why is Cardinality important?")]),e._v(" "),a("p",[e._v("Cardinality is important to the way we define and think about our Data Model and Schema type systems,\nbecause if the cardinality of two parts of a model aren't the same cardinality,\nthen that means one of them is less expressive.\nIf we intended two systems to be interchangeable, but they have unequal cardinality,\nthen we can quickly and clearly identify that there must be a bug somewhere!")]),e._v(" "),a("p",[e._v("Cardinality concepts are also useful for clear documentation.")]),e._v(" "),a("p",[e._v("Cardinality counting can be used as a design planning exercise:\ncount how many states your types "),a("em",[e._v("can")]),e._v(" have, and then consider how many states\nyour code is designed to handle, and if they're not equal,\nthen it's clear that you have work to do!")]),e._v(" "),a("p",[e._v("In practical application, you can see some examples of cardinality-counting used\nto describe "),a("code",[e._v("nullable")]),e._v(" vs "),a("code",[e._v("optional")]),e._v(" vs "),a("code",[e._v("implicit")]),e._v(" values in the IPLD Schemas documentation:\n"),a("RouterLink",{attrs:{to:"/schemas/schema-kinds.html#cardinality-examples"}},[e._v("Cardinality Examples")]),e._v(".\nThese cardinality countings are both key to the documentation,\nand key to understanding and using those features to build unambiguous APIs.")],1),e._v(" "),a("h3",{attrs:{id:"how-do-we-count-cardinality"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-do-we-count-cardinality"}},[e._v("#")]),e._v(" How do we Count Cardinality?")]),e._v(" "),a("p",[e._v("Counting cardinality is probably best done by example.")]),e._v(" "),a("p",[e._v("Consider a boolean: it can have the value 'true', or it can have the value 'false'.\nWe simply count these states up!  The cardinality of a boolean is "),a("code",[e._v("2")]),e._v("!")]),e._v(" "),a("p",[e._v("Now, consider a pair of boolean values: how many states can it have?\nFour: "),a("code",[e._v("(true, true)")]),e._v(", "),a("code",[e._v("(true, false)")]),e._v(", "),a("code",[e._v("(false, true)")]),e._v(", or "),a("code",[e._v("(false, false)")]),e._v(".\nSo, the cardinality of two booleans is "),a("code",[e._v("4")]),e._v(".")]),e._v(" "),a("p",[e._v("The exercise gets more interesting as we consider larger accumulations of values.\nWe will also find that how the cardinality count accumulates differs based on\nhow the types are composed!")]),e._v(" "),a("p",[e._v("We'll explore more examples of this, and start identifying categories of\nthings where we can do predictable kinds of math with cardinality in\nthe next section: "),a("a",{attrs:{href:"#categories-of-types"}},[e._v("Categories of Types")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"categories-of-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#categories-of-types"}},[e._v("#")]),e._v(" Categories of Types")]),e._v(" "),a("p",[e._v('We can identify a few categories of "types" based on how we evaluate their cardinality.\n(These definitions will use names that are popularized in computer science,\nand so they '),a("em",[e._v("may")]),e._v(" match the name used in your favorite programming language -- but\nwhether or not the same is familiar, the "),a("em",[e._v("concept")]),e._v(" is universal, even across languages!)")]),e._v(" "),a("h3",{attrs:{id:"enumerated-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#enumerated-types"}},[e._v("#")]),e._v(" enumerated types")]),e._v(" "),a("p",[e._v('Enumerated types (usually, "enum" for short) have a cardinality that is some integer.')]),e._v(" "),a("p",[e._v('For example, an enum might have members named "Foo", "Bar", and "Baz";\nand the cardinality of that enum is "|3|".')]),e._v(" "),a("p",[e._v('(The term "enum" might make more sense if you think of it as short for\n'),a("em",[e._v("enumerated")]),e._v(", rather than "),a("em",[e._v("enumerable")]),e._v(" -- something with countable-infinity\nmembers is "),a("strong",[e._v("not")]),e._v(' considered an "enum".\n(We\'d call that an '),a("a",{attrs:{href:"#infinite-scalar"}},[e._v("infinite scalar")]),e._v(" instead.))")]),e._v(" "),a("h3",{attrs:{id:"sum-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sum-types"}},[e._v("#")]),e._v(" sum types")]),e._v(" "),a("p",[e._v("Sum types have a cardinality that is "),a("em",[e._v("the sum of cardinality of their member types")]),e._v(".")]),e._v(" "),a("p",[e._v('Sum types usually show up in prose descriptions of data as the word "or".')]),e._v(" "),a("p",[e._v('For example, say: "I have a boolean '),a("em",[e._v("or")]),e._v(' an integer" --\nthis would be an example of a sum type,\nand its cardinality would be "|inf+2|" --\ncountable infinity for the integer, and plus two for the boolean.')]),e._v(" "),a("p",[e._v('A clearer example might take two enums -- let\'s call them\n"Animals" (it has members "cat", "dog", "rabbit"),\nand "Furniture" (it has members "chair", and "desk") --\nand say "I have an Animal '),a("em",[e._v("or")]),e._v(' a furniture" --\nthen clearly I have one (and only one) of these five things:\nthe cardinality is "|3+2|".')]),e._v(" "),a("p",[e._v('Sum types go by many names in various communities: they\'re also commonly\nknown as "(discriminated) unions", "(tagged) variants", or other terminology.\n(We use the "union" term ourselves, in the lexicon of IPLD Schemas!)')]),e._v(" "),a("p",[e._v("You can also consult the Wikipedia page on\n"),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Sum_types",target:"_blank",rel:"noopener noreferrer"}},[e._v("Sum Types"),a("OutboundLink")],1),e._v("\nfor broader discussion of the topic.\nhttps://chadaustin.me/2015/07/sum-types/ also contains some useful content\nand examples from a variety of languages.")]),e._v(" "),a("h3",{attrs:{id:"product-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#product-types"}},[e._v("#")]),e._v(" product types")]),e._v(" "),a("p",[e._v("Product types have a cardinality that is "),a("em",[e._v("the multiplied cardinality of their member types")]),e._v(".")]),e._v(" "),a("p",[e._v("This may sound outlandish, but you've been using them all your life:\n"),a("em",[e._v('"product types" are commonly known as "structs"')]),e._v('\n(or, "classes", in more aggressively object-oriented languages).')]),e._v(" "),a("p",[e._v('Product types usually show up in prose descriptions of data as the word "and".')]),e._v(" "),a("p",[e._v('For example, say: "I have a boolean and another boolean and another boolean" --\nyou might write code for this as '),a("code",[e._v("struct{ a bool, b bool, c bool }")]),e._v(',\nand its cardinality would be "|2*2*2|" -- "|8|" --\ntwo for each of the booleans, and multiplied because each of them may vary independently,\nand thus each of the booleans adds another "dimension" to the state space described by this combined value.')]),e._v(" "),a("p",[e._v('For another example, using our enums again above --\n"Animals" (it has members "cat", "dog", "rabbit"),\nand "Furniture" (it has members "chair", and "desk") --\nwe could say "I have an Animal, '),a("em",[e._v("and")]),e._v(" it's on top of a Furniture\" --\nand then I could have any one of of "),a("em",[e._v("six")]),e._v(' states\n("cat on a chair", "cat on desk", "dog on a chair", etc):\nthe cardinality is "|3*2|".')]),e._v(" "),a("h3",{attrs:{id:"infinite-recursives"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#infinite-recursives"}},[e._v("#")]),e._v(" infinite recursives")]),e._v(" "),a("p",[e._v("Infinite recursives, as it says in the name, have infinite cardinality.")]),e._v(" "),a("p",[e._v("Maps and lists are recursives because they can contain other values,\nincluding more maps and lists.\nMaps and lists are also infinite (even at a single level, before considering recursion):\nsince we can keep inserting entries into a map, or appending values to a list,\nand still have a map or list respectively, we treat their cardinality as infinite.")]),e._v(" "),a("p",[e._v('Note that it\'s still useful to do math around these, though.\nFor example, if you have "maybe a map" (see the '),a("a",{attrs:{href:"#maybe-types"}},[e._v("maybe types")]),e._v(" section,\ncoming later, in the "),a("a",{attrs:{href:"#types-in-the-wild"}},[e._v("Types in the Wild")]),e._v(' chapter) you may\nfind it useful to declare that the cardinality of your map is "a" (an arbitrary placeholder),\nand then the cardinality of "maybe map" is "|a+1|".')]),e._v(" "),a("h3",{attrs:{id:"infinite-scalars"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#infinite-scalars"}},[e._v("#")]),e._v(" infinite scalars")]),e._v(" "),a("p",[e._v("Infinite scalars is a term to describe things like strings:\nbecause they can be unlimited in length, they have infinite cardinality.\nSince we can take a string, append some more characters,\nand still have string, we can't count its cardinality.")]),e._v(" "),a("p",[e._v('Infinite scalars aren\'t very different from infinite recursives, arguably.\n("A string is just a list of characters" is one such argument.)\nStill, we often regard these things as having separate categories in practice:\nstrings are usually treated as a single token in serializers, despite being "infinite";\nnumbers are infinite (even if there are some practical problems with this:\nsee '),a("a",{attrs:{href:"#what-about-numbers"}},[e._v("what about numbers?")]),e._v(" in the "),a("a",{attrs:{href:"#types-in-the-wild"}},[e._v("Types in the Wild")]),e._v(" chapter),\nbut certainly aren't usually considered to be recursive (though this does sometimes\nsee usage in theory -- see "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Peano_arithmetic",target:"_blank",rel:"noopener noreferrer"}},[e._v("Peano Arithmetic"),a("OutboundLink")],1),e._v("!);\nand so on.")]),e._v(" "),a("p",[e._v('As with infinite recursives, note that it\'s still useful to do math around these.\nFor example, if you have "a string or a null",\nyou have a '),a("a",{attrs:{href:"#sum-types"}},[e._v("sum type")]),e._v(" (more specifically, a "),a("a",{attrs:{href:"#maybe-types"}},[e._v("maybe type")]),e._v('),\nand even if the cardinality of string is "infinite", it\'s still useful to declare\nthe cardinality of your string is "a" (an arbitrary placeholder),\nand then the cardinality of "string or null" is "|a+1|".\n(In practice: how often have you had an API bug burn you on the difference\nbetween null and an empty string, or the difference between null and absent?\nThis is why we keep counting cardinality even after an infinity shows up!)')]),e._v(" "),a("h3",{attrs:{id:"unit-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unit-types"}},[e._v("#")]),e._v(" unit types")]),e._v(" "),a("p",[e._v('Let\'s talk about one last size of cardinality... "unit": unit just means "one".')]),e._v(" "),a("p",[e._v('"Unit" types don\'t come up too often... or at least, they\'re not often named as such.\nJust like "product types" are quite common once you recognize them, though, so is "unit".')]),e._v(" "),a("p",[e._v('"Null" can be thought of as a "unit" type.')]),e._v(" "),a("p",[e._v('"Maybe"/"Optional" types (further discussion later in the '),a("a",{attrs:{href:"#types-in-the-wild"}},[e._v("Types in the Wild")]),e._v(" chapter,\nspecifically the "),a("a",{attrs:{href:"#maybe-types"}},[e._v("maybe types")]),e._v(' section) can be thought of as "unit plus a thing".')]),e._v(" "),a("p",[e._v("Enums can be considered a sum type of where every type is itself a just another named unit type!\n(Whether or not you find this a "),a("em",[e._v("useful")]),e._v(" perspective is up to you.  If it's confusing, forget it.)")]),e._v(" "),a("h2",{attrs:{id:"open-vs-closed-membership"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#open-vs-closed-membership"}},[e._v("#")]),e._v(" Open vs Closed membership")]),e._v(" "),a("p",[e._v("All of the above "),a("a",{attrs:{href:"#categories-of-types"}},[e._v("categories of types")]),e._v(' have one thing in common:\nthey have "closed" membership.  That is, at "compile" (or other static analysis) time,\nwe know what their membership is, and we can completely count their cardinality (infinities notwithstanding).\nOnce the program is compiled(/analyzed), there\'s no way to add new members to any of these types,\nand no reason to consider the idea of updating any of the cardinality accounting.')]),e._v(" "),a("p",[e._v('What if we want "open" membership, where I '),a("em",[e._v("don't")]),e._v(" know all of the possible\ntypes of values that will be part of a type in advance?")]),e._v(" "),a("p",[e._v('This "open membership" is commonly known as '),a("strong",[e._v("interfaces")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"interfaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interfaces"}},[e._v("#")]),e._v(" interfaces")]),e._v(" "),a("p",[e._v('Interfaces have the concept of "open membership", and are also typically\ncombined with some definition of "features", also called as traits or behavior\nin some languages, that are required if something will be considered to\nimplement the interface.')]),e._v(" "),a("p",[e._v("In programming languages, the definition of \"features\" usually is expressed in\nterms of a set of methods.  This makes sense for programming languages,\nbecause if you don't know what methods you can call on a thing,\nyou can't really do much with the thing!")]),e._v(" "),a("p",[e._v('One could also imagine using a different definition of "features" to describe\n"interfaces" that apply purely to data:\nFor example, stating that some map has the features to conform to an interface\nonly if some entries of some known names and value types are present in the map.\n(However, this is not often seen, so this document will continue to frequently\nrefer to "sets of methods" when discussing interfaces.)')]),e._v(" "),a("h3",{attrs:{id:"explicit-versus-structural-interfaces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#explicit-versus-structural-interfaces"}},[e._v("#")]),e._v(" explicit versus structural interfaces")]),e._v(" "),a("p",[e._v("Interfaces as found in programming languages tend to fall into one of two large camps:\n"),a("em",[e._v("explicit")]),e._v(" interfaces, or "),a("em",[e._v("structural")]),e._v(" interfaces.")]),e._v(" "),a("p",[e._v("Explicit interfaces require types implementing them to say so.")]),e._v(" "),a("p",[e._v("Structural interfaces state some set of methods (or more generally, features)\nthat must be present on a type for it to satisfy the interface;\nthen, any type that has those methods implements the interface.")]),e._v(" "),a("p",[e._v('Both explicit and structural styles of interfaces have "open" membership --\nyou can "compile" a program that has interfaces in it,\nthen add more libraries when you "link" the program and execute it,\nand those libraries can add more implementors of the interfaces!')]),e._v(" "),a("p",[e._v("The explicit and structural styles vary in other practical details.\nFor example, explicit interfaces require referencing the interface they implement;\nthis makes them significantly less flexible, and creates many dependency management requirements.\nBy contrast, structural interfaces can knowingly conform to an interfaces contract\nwhile still not referencing it directly; this can be extremely useful in\ndesigning systems for independently upgradeable pieces.")]),e._v(" "),a("p",[e._v("(There are other yet more detailed ways in which these styles vary, but\nsince they're not really important in this document, we'll rest here.)")]),e._v(" "),a("h2",{attrs:{id:"types-in-the-wild"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#types-in-the-wild"}},[e._v("#")]),e._v(" Types in the Wild")]),e._v(" "),a("p",[e._v("These different categories of types are present in most programming languages,\nbut not all of them are present in every language (!),\nand they often go by different names in different programming communities.\nHere's a few (non-exhaustive) examples in a handful of languages:")]),e._v(" "),a("h3",{attrs:{id:"enums-in-the-wild"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#enums-in-the-wild"}},[e._v("#")]),e._v(" enums in the wild")]),e._v(" "),a("p",[e._v("In Java, the "),a("code",[e._v("enum")]),e._v(" keyword maps directly the category of "),a("a",{attrs:{href:"#enumerated-types"}},[e._v("enum")]),e._v(" we've defined here.")]),e._v(" "),a("p",[e._v("In Go, "),a("em",[e._v("there is no direct support for enums")]),e._v(".\nHowever, it's often implemented in practice by a typedef of an int, and a table of named constants.")]),e._v(" "),a("p",[e._v("In Rust, there's an "),a("code",[e._v("enum")]),e._v(" keyword, and it may be used to implement "),a("a",{attrs:{href:"#enumerated-types"}},[e._v("enum")]),e._v(" as we've defined it here.\nHowever, if you're coming from a Rust background, and trying to understand this document and compare to other languages,\nbe cautious here: the Rust "),a("code",[e._v("enum")]),e._v(" keyword "),a("em",[e._v("also")]),e._v(" provides what we call "),a("a",{attrs:{href:"#sum-types"}},[e._v("sum types")]),e._v(".")]),e._v(" "),a("h4",{attrs:{id:"booleans"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#booleans"}},[e._v("#")]),e._v(" booleans")]),e._v(" "),a("p",[e._v("In many languages, the concept of "),a("code",[e._v("boolean")]),e._v(" can be understood as a particular instance of an enum --\nit's just an enum with two values!\nSure, it may be implemented as 'primitive' in many languages... but clearly,\nfor cardinality counting, we can see a boolean as exactly \"|2|\".")]),e._v(" "),a("h3",{attrs:{id:"sum-types-in-the-wild"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sum-types-in-the-wild"}},[e._v("#")]),e._v(" sum types in the wild")]),e._v(" "),a("p",[e._v("In Java, "),a("em",[e._v("there is no direct support for sum types")]),e._v(".\nThe nearest thing possible is to create an interface,\nand promise that only a known number of types will implement it.")]),e._v(" "),a("p",[e._v("In Go, "),a("em",[e._v("there is no direct support for sum types")]),e._v(".\nThe nearest thing possible is to create an interface with an unexported method,\nand make sure only a known number of types in the same package implement it.\n(See https://github.com/BurntSushi/go-sumtype for tooling to help support this;\nthe readme also contains good documentation of the concept!)")]),e._v(" "),a("p",[e._v("In Rust, the "),a("code",[e._v("enum")]),e._v(" keyword (confusingly) also creates sum types.\nRust's sum types are at least properly closed (unlike Java's and Go's).")]),e._v(" "),a("h4",{attrs:{id:"maybe-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#maybe-types"}},[e._v("#")]),e._v(" maybe types")]),e._v(" "),a("p",[e._v("In "),a("em",[e._v("many")]),e._v(' languages, you may find a type in the standard library called "Maybe",\nor equally frequently, "Optional", or, "Either".\nThese are a sum type!\nThey\'re typically explained as "either '),a("strong",[e._v("none")]),e._v(", or "),a("strong",[e._v("some")]),e._v(' of a thing":\nso, they take the cardinality of a thing and simply "plus one" to it,\nand colloquially call that additional state the "none" state.')]),e._v(" "),a("p",[e._v("For some "),a("code",[e._v("Maybe<T>")]),e._v(', the cardinality is "1+|T|".')]),e._v(" "),a("p",[e._v("(This is also a great example for how we can use cardinality counting methods\nto create clear comparisons between differently named but functionally\nidentical concepts between programming language communities!)")]),e._v(" "),a("h4",{attrs:{id:"indiscriminate-unions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#indiscriminate-unions"}},[e._v("#")]),e._v(" indiscriminate unions")]),e._v(" "),a("p",[e._v('Some languages (notably, C/C++) have a concept of "union" which is related,\nbut markedly '),a("em",[e._v("not")]),e._v(' a sum type, because this particular concept of a union\nis not "discriminated" -- it doesn\'t actually itself contain all the info needed\nto completely understand or handle it.\nThis kind of "union" can be used to '),a("em",[e._v("build")]),e._v(' a sum type semantic,\nbut only in combination with an additional bit of memory used to indicate\n(or "discriminate", if you will) what member type the union actually contains.')]),e._v(" "),a("p",[e._v("We mention this here because the terminology is sometimes confusing.")]),e._v(" "),a("h3",{attrs:{id:"product-types-in-the-wild"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#product-types-in-the-wild"}},[e._v("#")]),e._v(" product types in the wild")]),e._v(" "),a("p",[e._v("In Java, "),a("code",[e._v("class")]),e._v(" creates a product type.")]),e._v(" "),a("p",[e._v("In Go, "),a("code",[e._v("struct")]),e._v(" creates a product type.")]),e._v(" "),a("p",[e._v("In Rust, "),a("code",[e._v("struct")]),e._v(" creates a product type.")]),e._v(" "),a("h3",{attrs:{id:"interfaces-in-the-wild"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interfaces-in-the-wild"}},[e._v("#")]),e._v(" interfaces in the wild")]),e._v(" "),a("p",[e._v("In Java, the "),a("code",[e._v("interface")]),e._v(" keyword introduces an interface.\nThese interfaces are "),a("a",{attrs:{href:"#explicit-versus-structural-interfaces"}},[a("em",[e._v("explicit")])]),e._v(": a class must use the "),a("code",[e._v("implements")]),e._v(' keyword to explicitly state that it can satisfy that interface.\n(That the class has sufficient methods to match the interface is then also checked at compile time -- but having the methods is not necessary rather than sufficient for the "implements" relationship to be considered true).')]),e._v(" "),a("p",[e._v("In Go, the "),a("code",[e._v("interface")]),e._v(" keyword introduces an interface.\nThese interfaces are "),a("a",{attrs:{href:"#explicit-versus-structural-interfaces"}},[a("em",[e._v("structural")])]),e._v(" -- a struct doesn't need to "),a("em",[e._v("say")]),e._v(" it implements an interface;\nif it has the relevant methods, then you can start using values of that type wherever the interface is required.")]),e._v(" "),a("p",[e._v("In Rust, the "),a("code",[e._v("trait")]),e._v(" feature combined with the "),a("code",[e._v("impl")]),e._v("+"),a("code",[e._v("for")]),e._v(" keywords is most comparable to the concept of interface in other languages.\nImplementing a trait is "),a("a",{attrs:{href:"#explicit-versus-structural-interfaces"}},[a("em",[e._v("explicit")])]),e._v(" -- a type must use the "),a("code",[e._v("impl")]),e._v("+"),a("code",[e._v("for")]),e._v(" keywords to explicitly state the methods that satisfy the trait.")]),e._v(" "),a("h3",{attrs:{id:"what-about-numbers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-about-numbers"}},[e._v("#")]),e._v(" what about numbers?")]),e._v(" "),a("p",[e._v("Numbers are... interesting.")]),e._v(" "),a("p",[e._v("For the most part in computing, we tend to pretend and build abstractions as if\nnumbers are "),a("a",{attrs:{href:"#infinite-scalars"}},[e._v("infinite scalars")]),e._v(".")]),e._v(" "),a("p",[e._v("Of course, this is rarely true in practice.\nIntegers are often implemented in such a way that values that would require beyond 32 (or 64, etc) bits are unrepresentable;\narguably, this makes them more like a (very ("),a("em",[e._v("very")]),e._v(") large) enum than anything else.\nFloating point numbers implemented in IEEE754 style also have their own entire host of foibles\n(they're still subject to limitations that stem from finite bit-size implementations;\nthey have different ranges of representability than an integer of the same bit size;\nthe "),a("em",[e._v("precision")]),e._v(" they can represent varies with "),a("em",[e._v("how big")]),e._v(" the number in question is;\nthey include "),a("em",[e._v("interesting")]),e._v(" values such as signed zeros which one might readily\nargue should not even be representable in an ideal system... and so on!).")]),e._v(" "),a("p",[e._v('Some languages provide "big" numbers in their standard libraries.\nThese "big" numbers are typically implemented by storing data as bytes,\nand expose mathematical operations on themselves as methods.\nBy using a non-fixed number of bytes, they can be true '),a("a",{attrs:{href:"#infinite-scalars"}},[e._v("infinite scalars")]),e._v('.\nHowever, these "big" numbers are typically '),a("em",[e._v("not interchangeable")]),e._v(' with the language\'s built-in number types,\nbecause the performance characteristics of these "big" numbers and their storage format\nis radically different than that of fixed-bit-size built-ins.\n(Attempts to shoe-horn "big" numbers and regular numbers into a single type tends\nto result in increasing the size of regular numbers, and few languages accept this tradeoff.)\nSince "big" numbers and built-in numbers usually aren\'t interchangeable,\n"big" numbers complicate rather than simplify the discussion;\nand since "big" numbers are the more rarely used of the two styles,\nmost of our concerns in practice continue to orbit around fixed-bit-size numbers.')]),e._v(" "),a("p",[e._v("The scope of this document is not to solve this conundrum, nor to try to convince you how you should consider numbers.\nIn IPLD, we usually do consider integers to be "),a("a",{attrs:{href:"#infinite-scalars"}},[e._v("infinite scalars")]),e._v(";\nwe add the caveat that libraries processing data which exceeds the boundaries they can process should error and halt explicitly.\n(In IPLD, we have the good fortune that this definition is unusually easy to stick to:\nsince we only carry data around, and don't provide mathematical operations on it,\nit's easy to expect that data which was processable on the way in will remain processable throughout the time we handle it.)")]),e._v(" "),a("h2",{attrs:{id:"types-in-ipld-schemas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#types-in-ipld-schemas"}},[e._v("#")]),e._v(" Types in IPLD Schemas")]),e._v(" "),a("p",[e._v("The core features of IPLD Schemas map very closely to the categories of types we've discussed:")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#enumerated-types"}},[e._v("enumerated types")]),e._v(" are "),a("code",[e._v("enum")]),e._v(".")]),e._v(" "),a("li",[a("a",{attrs:{href:"#sum-types"}},[e._v("sum types")]),e._v(" are "),a("code",[e._v("union")]),e._v(".")]),e._v(" "),a("li",[a("a",{attrs:{href:"#product-types"}},[e._v("product types")]),e._v(" are "),a("code",[e._v("struct")]),e._v(".")]),e._v(" "),a("li",[a("a",{attrs:{href:"#infinite-recursives"}},[e._v("infinite recursives")]),e._v(" appear as "),a("code",[e._v("list")]),e._v(" and "),a("code",[e._v("map")]),e._v(".")]),e._v(" "),a("li",[a("a",{attrs:{href:"#infinite-scalars"}},[e._v("infinite scalars")]),e._v(" appear as "),a("code",[e._v("string")]),e._v(", "),a("code",[e._v("bytes")]),e._v(", and "),a("code",[e._v("int")]),e._v(".")]),e._v(" "),a("li",[a("a",{attrs:{href:"#sum-types"}},[e._v("sum types")]),e._v(" specifically for "),a("a",{attrs:{href:"#maybe-types"}},[e._v("maybe")]),e._v(" show up as "),a("code",[e._v("optional")]),e._v(" and "),a("code",[e._v("nullable")]),e._v(".\n"),a("ul",[a("li",[e._v("(there are two of them because each creates a sum with a different "),a("a",{attrs:{href:"#unit-types"}},[e._v("unit type")]),e._v("!)")])])])]),e._v(" "),a("p",[e._v("IPLD Schemas don't have a concept of "),a("a",{attrs:{href:"#open-vs-closed-membership"}},[e._v("interfaces")]),e._v(".\nAt least, "),a("em",[e._v("not exactly")]),e._v(" -- not "),a("em",[e._v("within")]),e._v(" the schema.\nInstead, the "),a("em",[e._v("whole Schema")]),e._v(' is treated as an interface:\nsince you can take some data and take a schema, and attempt to unify them to get typed data if the schema "matches"...\nyou can use a series of Schemas in the same way as you\'d use a series of interfaces.\n(IPLD Schemas are effectively '),a("a",{attrs:{href:"#explicit-versus-structural-interfaces"}},[a("em",[e._v("structural")])]),e._v(" interfaces.)")])])}),[],!1,null,null,null);t.default=s.exports}}]);