(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{394:function(e,t,s){"use strict";s.r(t);var o=s(42),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"ipld-selectors"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipld-selectors"}},[e._v("#")]),e._v(" IPLD Selectors")]),e._v(" "),s("p",[e._v("This document is a designdoc for IPLD Selectors.")]),e._v(" "),s("h2",{attrs:{id:"meta-status-of-this-doc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#meta-status-of-this-doc"}},[e._v("#")]),e._v(" [Meta: Status of this doc]")]),e._v(" "),s("ul",[s("li",[e._v("This was written around 2018-10-16 ("),s("a",{attrs:{href:"https://drive.google.com/file/d/1NbbVxZQFKXwW6mdodxgTaftsI8eID-c1/view",target:"_blank",rel:"noopener noreferrer"}},[e._v("video presentation"),s("OutboundLink")],1),e._v(")")]),e._v(" "),s("li",[e._v("It narrows down the decision space enough to make significant progress.")]),e._v(" "),s("li",[e._v("good enough for trying out an implementation to learn more and make choices.")]),e._v(" "),s("li",[e._v("But it is not complete.")]),e._v(" "),s("li",[e._v("some choices that need to be made:\n"),s("ul",[s("li",[e._v("[ ] select general binary and string format structure for selectors. (options given here)")]),e._v(" "),s("li",[e._v("[ ] binary and string formats for each selector. doesn't have to be here.")]),e._v(" "),s("li",[e._v("[ ] whether to dump all selector codes into multicodec table, or one code.")]),e._v(" "),s("li",[e._v("[ ] which S expression selector variant to use (may be out of scope for this doc)")])])]),e._v(" "),s("li",[e._v("more prose here may help implementors.")])]),e._v(" "),s("h2",{attrs:{id:"motivation-what-are-selectors"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#motivation-what-are-selectors"}},[e._v("#")]),e._v(" Motivation - what are Selectors?")]),e._v(" "),s("p",[s("em",[e._v("Prerequisites: "),s("a",{attrs:{href:"https://github.com/ipld/ipld",target:"_blank",rel:"noopener noreferrer"}},[e._v("IPLD"),s("OutboundLink")],1),e._v(", IPLD data model, "),s("a",{attrs:{href:"https://github.com/ipld/cid",target:"_blank",rel:"noopener noreferrer"}},[e._v("CID"),s("OutboundLink")],1),e._v(".")])]),e._v(" "),s("p",[e._v('IPLD Selectors are expressions that identify ("select") a subset of nodes in an IPLD dag.')]),e._v(" "),s("p",[e._v("This is a useful primitive to use along with: (a) systems that require distributing or pinning dags (IPFS, Filecoin, bitswap, graphsync, ipfs-cluster), (b) applications that require fetching subsets of data in specific orders or at specific times (video players, dataset viewers, file systems), (c) programs that transform graphs into other graphs (data transformations, ETL, etc). In short, it is a fundamental primitive required by most systems and applications in the IPLD and IPFS ecosystems, as important as "),s("a",{attrs:{href:"https://github.com/multiformats/multihash",target:"_blank",rel:"noopener noreferrer"}},[e._v("multihash"),s("OutboundLink")],1),e._v(", "),s("a",{attrs:{href:"https://github.com/ipld/cid",target:"_blank",rel:"noopener noreferrer"}},[e._v("CIDs"),s("OutboundLink")],1),e._v(", "),s("a",{attrs:{href:"https://github.com/ipld/",target:"_blank",rel:"noopener noreferrer"}},[e._v("IPLD Formats"),s("OutboundLink")],1),e._v(", and more.")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/ipld/specs/920f671fe388cc401caf32234d2de98eed0cb9b7/selectors/selectors.jpg",alt:""}})]),e._v(" "),s("h2",{attrs:{id:"prior-work"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#prior-work"}},[e._v("#")]),e._v(" Prior Work")]),e._v(" "),s("p",[e._v("There have been a lot of articulations about selectors in the history of the IPFS and IPLD projects. Many documents exist extolling all the kinds of use cases for selectors. Instead of giving a complete articulation here, this document will mention a few use cases and link to the other documents.")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://github.com/ipld/specs/issues/35",target:"_blank",rel:"noopener noreferrer"}},[e._v("Designing IPLD Selectors (2017)"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/ipfs/notes/issues/272",target:"_blank",rel:"noopener noreferrer"}},[e._v("IPLD Selector Thoughts (2017)"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/ipld/js-ipld-selector",target:"_blank",rel:"noopener noreferrer"}},[e._v("exprimental js-ipld-selector (2017)"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/ipfs/2016-IPFS-Workshop-Lisbon/issues/5",target:"_blank",rel:"noopener noreferrer"}},[e._v("Designing IPLD Selectors - Workshop (2016)"),s("OutboundLink")],1),e._v(" (+ "),s("a",{attrs:{href:"https://github.com/ipld/specs/issues/4",target:"_blank",rel:"noopener noreferrer"}},[e._v("notes"),s("OutboundLink")],1),e._v(")")]),e._v(" "),s("li",[s("a",{attrs:{href:"https://github.com/ipfs/notes/issues/12",target:"_blank",rel:"noopener noreferrer"}},[e._v("IPLD Selector (original issue) (2015)"),s("OutboundLink")],1)])]),e._v(" "),s("h3",{attrs:{id:"important-design-notes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#important-design-notes"}},[e._v("#")]),e._v(" Important Design Notes")]),e._v(" "),s("p",[s("strong",[e._v("Learn from the best.")]),e._v(" There have been dozens of graph selector systems implemented over the last few decades. There have been only a few that have been extremely successful, and productive. Study and learn from these systems. These include: unix globs, regular expressions, XPath, css selectors, and more.")]),e._v(" "),s("p",[s("strong",[e._v("Selectors include paths to the root.")]),e._v(" In most cases using IPLD Selectors, programs need to be able to verify authenticated data structures (they need to hash all the nodes in a path, all the way to the root). Therefore, for all these distributed, authenticated use cases, it is drastically easier to count on Selectors that yield a result that is verifiable (checkable against the original query -- the root).")]),e._v(" "),s("p",[s("strong",[e._v("Self-describe and use multiple types.")]),e._v(" Over the years, there has been much designing, without arriving at a complete, perfect solution. We have now recognized this as a feature where self-description and upgradability fit better than forcing a single language: there should just be many types of selectors and applications should use the ones that fit their needs. Due to the wide variety of use cases, we will not have a single perfect syntax. This will become easier over time, as systems that use IPLD acquire the ability to execute authenticated code.")]),e._v(" "),s("p",[s("strong",[e._v("Aim for succinct, intuitive, human-readable, expressive power.")]),e._v(" The most successful selector systems (unix globs, regular expressions, css selectors, etc.) have created very poweful and succinct expressions, that balance the nuance between making something human-friendly and highly efficient. Understandability, intuitiveness, expressivity, familiarity, and similar qualities are desired in the human-readable syntax. Self-description and types make this drastically easier, enabling whole new types to be made over time as better and better syntaxes are discovered, and even existing familiar syntaxes to be ported over.")]),e._v(" "),s("p",[s("strong",[e._v("Aim for succinct, efficient, self-describing binary representations.")]),e._v(" Various systems that use IPLD Selectors may need to distribute and store billions of selectors. Succinctness of expression is key. Self-description and types make this drastically easier, enabling whole new types to be made over time as more efficient syntaxes are discovered.")]),e._v(" "),s("p",[s("strong",[e._v("Blocks have CIDs. IPLD Nodes have Paths.")]),e._v(" It is very important that we align on the following two statements: (1) Blocks have CIDs. (2) IPLD Nodes have paths, not CIDs. This is important because it means that IPLD nodes may begin within the middle of a block, and may not be addressable directly by a CID. This is a key realization, as Selectors must always support Paths as a dag root, not just a CID.")]),e._v(" "),s("h2",{attrs:{id:"ipld-selector-system"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipld-selector-system"}},[e._v("#")]),e._v(" IPLD Selector System")]),e._v(" "),s("h3",{attrs:{id:"narrowing-down-the-problem"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#narrowing-down-the-problem"}},[e._v("#")]),e._v(" Narrowing down the problem")]),e._v(" "),s("p",[e._v("The problem of IPLD Selectors is narrowed down to a very concrete, simple problem:")]),e._v(" "),s("blockquote",[s("ul",[s("li",[e._v("How can we succinctly identify a dag subset, connected to the root?")])])]),e._v(" "),s("p",[e._v("These other questions are solved in other systems, above or below IPLD Selectors:")]),e._v(" "),s("blockquote",[s("ul",[s("li",[e._v("How can we represent arbitrary data structures or files in dags? (IPLD data model, user code)")]),e._v(" "),s("li",[e._v("How can we succinctly identify a dag subset, "),s("u",[e._v("not connected to the root")]),e._v(" (User code on top of IPLD selectors)")]),e._v(" "),s("li",[e._v("How can we traverse a dag subset? (IPLD library implementations, using IPLD Selectors)")]),e._v(" "),s("li",[e._v("How can we make subset selection efficient? (IPLD library implementations)")]),e._v(" "),s("li",[e._v("How can we make selector combination efficient? (IPLD library implementations)")]),e._v(" "),s("li",[e._v("How can we strip a dag subset from links to objects not in the subset (IPLD Transformations, user code)")]),e._v(" "),s("li",[e._v("How can we convert one dag representation into another? (IPLD Transformations, user code)")]),e._v(" "),s("li",[e._v("How can we agree with multiple other parties who will pin or send subets of a dag? (ipfs-cluster, graphsync)")])])]),e._v(" "),s("p",[e._v("With our problem narrowed down, we can focus on solving just that, and let all other concerns be solved elsewhere in the stack.")]),e._v(" "),s("h3",{attrs:{id:"selector-requirements"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#selector-requirements"}},[e._v("#")]),e._v(" Selector Requirements")]),e._v(" "),s("ul",[s("li",[e._v("P0 - Selectors can express any valid dag subset (connected to the root).")]),e._v(" "),s("li",[e._v("P0 - Selectors can select based on IPLD paths.")]),e._v(" "),s("li",[e._v("P1 - Selectors can select based on values.")]),e._v(" "),s("li",[e._v("P2 - Selectors can select with seeded pseudorandomness.")]),e._v(" "),s("li",[e._v("P3 - Selectors can select based on sibling nodes (as in css3) and their descendants (as in css4).")]),e._v(" "),s("li",[e._v("P1 - Selectors can be composed.")]),e._v(" "),s("li",[e._v("P0 - Once written, selectors should work permanently. (selector code should not change under the users).")]),e._v(" "),s("li",[e._v("P1 - Selector languages can evolve and improve over time (faster than other selector systems).")]),e._v(" "),s("li",[e._v("P3 - Allow experimentation without requiring backward-compatible syntax (different from globs and css).")]),e._v(" "),s("li",[e._v("P0 - There is a 1-1 mapping between human readable and binary syntaxes.")]),e._v(" "),s("li",[e._v("P0 - Binary syntax is self-described, succinct, and efficient.")]),e._v(" "),s("li",[e._v("P0 - Human readable syntax is powerful and expressive.")]),e._v(" "),s("li",[e._v("P1 - Human readable syntax is intuitive and familiar.")])]),e._v(" "),s("p",[e._v("Some of these may seem mutually exclusive. They are not.")]),e._v(" "),s("h2",{attrs:{id:"approach-selector-types"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#approach-selector-types"}},[e._v("#")]),e._v(" Approach: Selector Types")]),e._v(" "),s("p",[e._v("The requirements stated above are hard to meet. We have spent lots of time in the last few years trying to reconcile them into one language and syntax, with no success. Earlier this year (2018) we recognized that the solution to this problem should be flexibility and interoperability: let many selector languages and syntaxes flourish, and let them evolve over time. This would allow us to satisfy all constraints above, including both a permanent model that can also improve over time. And it reduces the core of our system into three components:")]),e._v(" "),s("ul",[s("li",[e._v("(1) A system of selector types, that allows creating new selector languages and syntaxes, and can compose them.")]),e._v(" "),s("li",[e._v("(2) An easy path for plugging selector types into IPLD libraries and other consumers of IPLD Selectors.")]),e._v(" "),s("li",[e._v("(3) A light process for testing and admitting new selector types into standard IPLD libraries.")])]),e._v(" "),s("p",[e._v("These components imply or expand into the following things:")]),e._v(" "),s("ul",[s("li",[e._v("Well-defined binary and human-readable type self-description (codes in multicodec).")]),e._v(" "),s("li",[e._v("A narrow "),s("code",[e._v("Selector")]),e._v(" interface for most uses of selectors, agnostic to selector type.")]),e._v(" "),s("li",[e._v("A standard way to add selector type implementations to IPLD libraries")]),e._v(" "),s("li",[e._v("IPLD libraries that pervasively uses the abstract  "),s("code",[e._v("Selector")]),e._v(" type, and can plug in concrete types.")]),e._v(" "),s("li",[e._v("A few simple selector types that cover most common cases (cid, path, glob, ...)")]),e._v(" "),s("li",[e._v("A selector type to allow composing selectors (MultiSelector)")]),e._v(" "),s("li",[e._v("Aim for language independent implementations of selector implementations (parsers, execution, etc). (WASM?)")]),e._v(" "),s("li",[e._v("Allow language-specific implementations of selectors (parsers, execution, etc).")]),e._v(" "),s("li",[e._v("(IMPORTANT) Well-designed set of test vectors representing a variety of use cases for IPLD Selectors.")]),e._v(" "),s("li",[e._v("A recommended structure for implementing a selector type, with an easy to use test suite.")])]),e._v(" "),s("hr"),e._v(" "),s("hr"),e._v(" "),s("hr"),e._v(" "),s("h1",{attrs:{id:"additional-iterations"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#additional-iterations"}},[e._v("#")]),e._v(" Additional iterations")]),e._v(" "),s("p",[e._v("Text above is design history from some of the earliest drafts of selectors\n(as indicated by the inline dates!).")]),e._v(" "),s("p",[e._v("There have been several iterations on this work:")]),e._v(" "),s("ul",[s("li",[e._v("The first commit recognizable as this document is: "),s("code",[e._v("920f671fe388cc401caf32234d2de98eed0cb9b7")]),e._v(" ,\nwith comments at https://github.com/ipld/specs/pull/75 .\n"),s("ul",[s("li",[e._v("In parallel, note contemporary discussions https://github.com/ipld/specs/pull/66\nand https://github.com/ipld/specs/pull/78 .")])])]),e._v(" "),s("li",[e._v("Subsequent commits "),s("code",[e._v("bb106c0a83a809be07e0b798a87e2437136a62d3")]),e._v(" and "),s("code",[e._v("0b99488e7c6df91c305410fd4d8c63185fe9d509")]),e._v('\nintroduced the vision of a unified IPLD-native "AST" (with the idea of user-facing ergonomics\nbeing address by having multiple future DSLs mapping into that single well-specified AST).')]),e._v(" "),s("li",[e._v("Several more evolutions were contained in https://github.com/ipld/specs/pull/116 .")]),e._v(" "),s("li",[e._v("Several "),s("em",[e._v("more")]),e._v(" evolutions were contained in https://github.com/ipld/specs/pull/133 .")]),e._v(" "),s("li",[e._v("Finally, in https://github.com/ipld/specs/pull/142 , we're checkpointing this\npiece of design history into the "),s("code",[e._v('"./design-history"')]),e._v(" folder (it's still good\nreference for the original goals and to trace some of the problem-solving!);\nand editing the tip of the selectors docs to emphasize succinctness, and to\nfocus on the solutions rather than the journey we took to get there.")])])])}),[],!1,null,null,null);t.default=a.exports}}]);