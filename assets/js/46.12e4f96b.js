(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{395:function(e,t,a){"use strict";a.r(t);var n=a(42),i=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("This document was archived from https://github.com/ipld/specs/issues/130.")]),e._v(" "),a("h2",{attrs:{id:"_130-identifying-the-critical-decisions-in-ipld-advanced-data-structure-design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_130-identifying-the-critical-decisions-in-ipld-advanced-data-structure-design"}},[e._v("#")]),e._v(" #130: Identifying the critical decisions in IPLD advanced data structure design")]),e._v(" "),a("p",[e._v("Opened 2019-06-11T19:10:13Z by warpfork")]),e._v(" "),a("p",[e._v("(Forward: this is a collection of a "),a("em",[e._v("lot")]),e._v(' of stuff, and I\'m trying to be comprehensive, but will inevitably fail.  If you want to read this and visualize semi-continuous injections of "TODO: expand" and "TODO: more alternatives?", that will probably be appropriate!)')]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("There are approximately three distinct and critical decisions we need to regard:")]),e._v(" "),a("ol",[a("li",[e._v("Signaling")]),e._v(" "),a("li",[e._v("Referencing")]),e._v(" "),a("li",[e._v("Having the implementation")])]),e._v(" "),a("h3",{attrs:{id:"signaling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#signaling"}},[e._v("#")]),e._v(" Signaling")]),e._v(" "),a("p",[e._v('"Signaling" refers to deciding / detecting that we need any advanced layout\nengagement at all, rather than simply having another regular map, list, or\nbyte sequence.')]),e._v(" "),a("p",[e._v('Note that "signaling" refers '),a("em",[e._v("only")]),e._v(" to the conditional branch that decides\nwe're going to do "),a("em",[e._v("something")]),e._v(" -- it doesn't define what the something "),a("em",[e._v("is")]),e._v(';\nthat\'s the "referencing" decision.')]),e._v(" "),a("p",[e._v("(It's useful to regard signaling as a distinct issue because we should be\nable to point on a flow control map to the exact position where signaling\noccurs -- it's "),a("em",[e._v("one point")]),e._v(".)")]),e._v(" "),a("h3",{attrs:{id:"referencing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#referencing"}},[e._v("#")]),e._v(" Referencing")]),e._v(" "),a("p",[e._v('(alternate titles: "rendezvous", "implementation selection")')]),e._v(" "),a("p",[e._v('"Referencing" refers to the need to pick a particular implementation of code\nwe\'re about to use to understand the data layout.')]),e._v(" "),a("p",[e._v('Roughly, "referencing" is about how something says "I\'m a hamt!" or\n"i\'m a rabin chunked byte sequence!".')]),e._v(" "),a("p",[e._v("Note that referencing is about "),a("em",[e._v("which")]),e._v(' of those things a data structure is;\nthe "signaling" decision already handled whether or not '),a("em",[e._v("something")]),e._v(" special\nis about to happen.  (Referencing can involve more complex decision trees,\nwhereas signaling is a pure boolean.)")]),e._v(" "),a("h3",{attrs:{id:"having-the-implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#having-the-implementation"}},[e._v("#")]),e._v(" Having the implementation")]),e._v(" "),a("p",[e._v('"Having the implementation" refers to the need to have actual executable code\nwhich understands and manipulates the data layout.  This might refer to a\nplugin registration system, or a bytecode interpreting system, or... etc.')]),e._v(" "),a("h3",{attrs:{id:"other"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#other"}},[e._v("#")]),e._v(" Other")]),e._v(" "),a("p",[e._v("Some advanced layout algorithms have additional parameters than merely their reference;\nfor example, HAMTs can have a 'bitwidth' parameter.")]),e._v(" "),a("p",[e._v("These additional parameters may be worthy of special consideration, because\nthey have the interesting property of being variable without needing "),a("em",[e._v("new code")]),e._v('\nin the client libraries acting on the data.  (This also means that parameters\nas recorded in serial data can vary in ways that don\'t affect whether or not\nwe "have the implementation", which may be useful; however, by the other side\nof the same coin, it poses further interesting questions.)')]),e._v(" "),a("p",[e._v("We could also choose to remove these from the field of play entirely and\nsimply state that the must be part of the Referencing data overall and\nopaque to the rest of the system.")]),e._v(" "),a("h2",{attrs:{id:"known-so-far-solution-vectors"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#known-so-far-solution-vectors"}},[e._v("#")]),e._v(" Known (so far) solution vectors")]),e._v(" "),a("p",[e._v("(These are selected vectors in the solution space; they might not be exhaustive.)")]),e._v(" "),a("h3",{attrs:{id:"signaling-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#signaling-2"}},[e._v("#")]),e._v(" Signaling")]),e._v(" "),a("h4",{attrs:{id:"defacto-signaling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#defacto-signaling"}},[e._v("#")]),e._v(" defacto signaling")]),e._v(" "),a("p",[e._v('We can implement signaling by leaving it completely unspecified in the data\nand completely unstandardized in general, instead having applications "know"\nwhat advanced layouts they expect where.')]),e._v(" "),a("p",[e._v("This is defacto what applications like unixfsv1 already do.\n(Take heed: It does "),a("strong",[e._v("work")]),e._v("!)")]),e._v(" "),a("p",[e._v("The thing we don't like about defacto signaling is that since it eschews\nstandard conventions and has no support from library APIs, it involves a large\namount of work "),a("em",[e._v("per new application")]),e._v(".  It also does not make it trivial to\nlink from one kind of application data into another (e.g., gateways currently\ndefacto engage unixfsv1, but we don't want to embed "),a("em",[e._v("gateway http links")]),e._v(" in\nother documents; that would kind of miss the point.)")]),e._v(" "),a("p",[e._v('However, perhaps by systematizing some patterns that defacto systems already\nemploy, we could reach a happier place.  (This turns into "explicit signaling".)')]),e._v(" "),a("h4",{attrs:{id:"explicit-signaling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#explicit-signaling"}},[e._v("#")]),e._v(" explicit signaling")]),e._v(" "),a("p",[e._v("We can implement signaling by standardizing a system for doing it with some coupled data.\nThat coupled data may or may not contain the Reference; the Reference could also remain in the data itself.")]),e._v(" "),a("p",[e._v("Schemas seem very likely suitable for a mechanism to carry explicit signaling for several reasons;\nbut we can also define explicit signaling that's independent of schemas.")]),e._v(" "),a("p",[e._v("Explicit signaling has several nice features, such as allowing the same raw data\nto be perceived in different ways depending on explicit signal.")]),e._v(" "),a("h4",{attrs:{id:"in-band-signaling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#in-band-signaling"}},[e._v("#")]),e._v(" in-band signaling")]),e._v(" "),a("p",[e._v("We can implement signaling by reserving a special key string in maps,\nand having it contain the Reference.")]),e._v(" "),a("p",[e._v("N.b. this doesn't actually help produce new data; another solution to signaling\nis still required when producing new data.")]),e._v(" "),a("h5",{attrs:{id:"in-band-signaling-with-reserved-keys"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#in-band-signaling-with-reserved-keys"}},[e._v("#")]),e._v(" in-band signaling with reserved keys")]),e._v(" "),a("p",[e._v("(I think we're just done with this one right?  Blueboxing.  Not doing it.)")]),e._v(" "),a("h5",{attrs:{id:"in-band-signaling-with-multi-codecs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#in-band-signaling-with-multi-codecs"}},[e._v("#")]),e._v(" in-band signaling with multi-codecs")]),e._v(" "),a("p",[e._v("Multicodecs already give us a place to stash an extra 'bit' of information,\nwhich means we can use it to do in-band signaling without blueboxing problems.")]),e._v(" "),a("p",[e._v("Whether or not we want to use more multicodecs is a topic of debate.\n(TODO: expand)")]),e._v(" "),a("h3",{attrs:{id:"referencing-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#referencing-2"}},[e._v("#")]),e._v(" Referencing")]),e._v(" "),a("p",[e._v("Forward: Everyone wants an obvious slam dunk here, but there isn't one.")]),e._v(" "),a("h4",{attrs:{id:"behavioral-specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#behavioral-specification"}},[e._v("#")]),e._v(" behavioral specification")]),e._v(" "),a("p",[e._v("Behavioral specification refers to using some human-readable strings\nto define what we're doing.")]),e._v(" "),a("p",[e._v("For example, we might have a string property in an object with a format\nshaped roughly like "),a("code",[e._v('"ipld/experimental/hamt/v1"')]),e._v("; we would then try to\ntranslate that string into a lookup of an implementation which will do\nthe right thing.")]),e._v(" "),a("h4",{attrs:{id:"cid-linking"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cid-linking"}},[e._v("#")]),e._v(" CID linking")]),e._v(" "),a("p",[e._v("CID linking is the idea that we can reference a particular implementation\nof an algorithm by a CID.")]),e._v(" "),a("p",[e._v('(CID linking tends to be suggested with the specific implementation of "WASM" in\nmind, but there\'s nothing particularly special about WASM; any linkable code\nwhich can be dynamically interpreted would suffice.)')]),e._v(" "),a("p",[e._v("There are unresolved (possibly unresolvable?) issues with CID linking that\nmake some of the hopes and dreams we typically associate with merkle designs\nnot hold: namely, having a CID of some particular hash of a particular bytecode\nisn't necessarily a canonical thing.  (What's a 'canonical' compiler for a\n'canonical' expression of a behavior?)")]),e._v(" "),a("p",[e._v("A CID of some bytecode specifies implementation details rather than semantics\nand contract, and that's not necessarily the kind of useful that we're looking for.")]),e._v(" "),a("p",[e._v("A CID of some bytecode also does not itself address any issues of versioning\nthe interpreter of that bytecode itself, nor versioning any APIs for getting\ndata into and out of that bytecode's environment.")]),e._v(" "),a("h3",{attrs:{id:"having-the-implementation-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#having-the-implementation-2"}},[e._v("#")]),e._v(" Having the implementation")]),e._v(" "),a("p",[e._v('(There aren\'t that many options here,\nso just skip down to the "Probable Solutions" section.)')]),e._v(" "),a("h2",{attrs:{id:"a-note-about-context-freedom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-note-about-context-freedom"}},[e._v("#")]),e._v(" A note about context-freedom")]),e._v(" "),a("p",[e._v("We don't need to put the advanced layout Reference data in every layer\nof internal data structure: it would be redundant.")]),e._v(" "),a("p",[e._v("It's already the case that many multi-block data structures are unusable\nif you're linked directly into the middle of them (e.g., when traversing\nthe internal nodes of a HAMT, if you don't have information \"on the stack\"\nwhich recalls which prefix bytes we've already munched, navigation is not\npossible): therefore it should be noted that total context-freedom is "),a("em",[e._v("not")]),e._v('\ngenerally possible.  It follows that solutions to our various questions\nwhich lean on some degree of "on the stack" context '),a("em",[e._v("are potentially viable")]),e._v(",\nand warrant discussion.")]),e._v(" "),a("h2",{attrs:{id:"probable-outcomes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#probable-outcomes"}},[e._v("#")]),e._v(" Probable outcomes")]),e._v(" "),a("h3",{attrs:{id:"signaling-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#signaling-3"}},[e._v("#")]),e._v(" Signaling")]),e._v(" "),a("p",[e._v("Vigorous debate.")]),e._v(" "),a("h3",{attrs:{id:"referencing-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#referencing-3"}},[e._v("#")]),e._v(" Referencing")]),e._v(" "),a("p",[e._v("We seem to have a rough consensus that this should be a human-readable string.\nCID-linking approaches aren't even defined unless we have a blocking dependency\non WASM, which is no fun.")]),e._v(" "),a("p",[e._v('It should be some reasonably prefixy string pattern -- e.g., "ipld/experimental/hamt/v1" --\nand it does not need to be particularly short because it\'s not frequently appearing.')]),e._v(" "),a("h3",{attrs:{id:"having-the-implementation-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#having-the-implementation-3"}},[e._v("#")]),e._v(" Having the Implementation")]),e._v(" "),a("p",[e._v("Surprisingly, this is the easy part?")]),e._v(" "),a("p",[e._v("If using non-WASM plugins, they have to be registered in your library of choice,\nindexed by the Reference string.")]),e._v(" "),a("p",[e._v("If using WASM plugins, we can refer to their bytecode by CID.\n(However, do note there are at least two sub-problems this doesn't address:\nfirst, that the WASM interpreter itself and APIs will need versioning;\nsecond, that users may not want to download and run non-time-bounded code.)")]),e._v(" "),a("hr"),e._v(" "),a("h4",{attrs:{id:"_2019-06-11t20-14-59z-warpfork"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-06-11t20-14-59z-warpfork"}},[e._v("#")]),e._v(" (2019-06-11T20:14:59Z) warpfork:")]),e._v(" "),a("p",[e._v("Some previous discussion (I haven't yet checked for complete dedup with this; it has a lot of discussion): https://github.com/ipld/specs/issues/118")]),e._v(" "),a("hr"),e._v(" "),a("h4",{attrs:{id:"_2019-06-11t20-39-16z-warpfork"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-06-11t20-39-16z-warpfork"}},[e._v("#")]),e._v(" (2019-06-11T20:39:16Z) warpfork:")]),e._v(" "),a("p",[e._v("Related issue in an implementation poc repo: https://github.com/ipld/js-generics/issues/3")]),e._v(" "),a("hr"),e._v(" "),a("h4",{attrs:{id:"_2019-06-11t20-39-44z-warpfork"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-06-11t20-39-44z-warpfork"}},[e._v("#")]),e._v(" (2019-06-11T20:39:44Z) warpfork:")]),e._v(" "),a("p",[e._v("Earlier (but completely superceded) draft of this: https://gist.github.com/warpfork/b315f3518207075b7044f35a0a15d17a")]),e._v(" "),a("hr"),e._v(" "),a("h4",{attrs:{id:"_2019-06-11t21-02-19z-mikeal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-06-11t21-02-19z-mikeal"}},[e._v("#")]),e._v(" (2019-06-11T21:02:19Z) mikeal:")]),e._v(" "),a("p",[e._v("Related: https://github.com/ipld/specs/pull/126#discussion_r292591611")]),e._v(" "),a("p",[e._v("An issue I plan to resolve in the current spec is that the signaling and the definition are tightly coupled. That will be broken apart, so we’ll have a clear idea of what a “Definition” for an IPLD Generic is, and how we associate that with the data (signaling) will be its own problem space.")]),e._v(" "),a("p",[e._v("Also, the operation descriptions are probably going to move to being defined for WASM rather than generically. The JS implementation will try to closely match this, but the API signatures for WASM need to be well defined in a spec in a way other languages do not and it’s not "),a("em",[e._v("really")]),e._v(" a requirement in other languages that they closely match "),a("em",[e._v("any")]),e._v(" API given that they can choose to associate the string identifier with any implementation using any API they wish.")]),e._v(" "),a("p",[e._v("With WASM, I think we avoid the “referencing” and “having an implementation” problems (for the most part) but there could be some aspects of the system I don’t see yet given that we don’t yet have a working implementation.")]),e._v(" "),a("hr"),e._v(" "),a("h4",{attrs:{id:"_2019-06-12t02-40-17z-rvagg"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-06-12t02-40-17z-rvagg"}},[e._v("#")]),e._v(" (2019-06-12T02:40:17Z) rvagg:")]),e._v(" "),a("p",[e._v("Re WASM as the utopia used for aiming purposes -- even if we don't get there I still quite like the idea that we split out these algorithms into their functional components. "),a("em",[e._v("\"Here's how you GET on this thing, and here's how you KEYS on it\"")]),e._v(" as entirely independent pieces of code. What I'm finding is that it enforces a nice rigour on the algorithm implementations to get the abstractions right in terms of their relationship to blocks of data and pieces of the data model. A stylistic thing but in the same way that good code formatting can aid good code design and a good module system can aid .. modularity.")]),e._v(" "),a("p",[e._v("Re schemas -- it's worth registering that schemas are going to be a useful, perhaps mandatory, tool in the advanced layout / generics flow. I want an algorithm to be able to assert that it's getting the block shapes (or at least data shapes) that it expects at each stage of traversal and avoid lose assumptions. Schemas are also likely going to be important on the write side, particularly where codegen comes in to play, but also as a translation tool for the more awkward layouts (like unions and the various non-plain representations like stringjoin).")]),e._v(" "),a("p",[e._v('So, even though we\'re not using schemas for this yet, keep in mind that they are going to be in play. So it\'s not unreasonable to insert them as a mandatory part of this process. It could work in any of the signalling mechanisms cases outlined above - defacto = "expect univfsv2 blocks that look like this", explicit = "here\'s your link and it will be a hamt that looks like this", in-band = "i\'m a hamt and I conform to this".')]),e._v(" "),a("p",[e._v("For referencing, I still like associating serialised schema CIDs with implementations in spite of the naysaying. But maybe we can come back to that later because I think objections are overblown and using strings has the URL-mutability problem and the namespacing problem and I like to think we're trying to move away from both of those problems as much as possible not entangling more of them.")]),e._v(" "),a("hr"),e._v(" "),a("h4",{attrs:{id:"_2019-06-20t07-02-14z-warpfork"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-06-20t07-02-14z-warpfork"}},[e._v("#")]),e._v(" (2019-06-20T07:02:14Z) warpfork:")]),e._v(" "),a("blockquote",[a("p",[e._v("For referencing, I still like associating serialised schema CIDs with implementations")])]),e._v(" "),a("p",[e._v("I should maybe try to clarify my position on this a bit.  I'm "),a("em",[e._v("fine")]),e._v(' with this.  I just think that if trying to check the boxes in the phrase "{necessary} {and|but not} {sufficient}", it\'s "nice" rather than "necessary", and also not "sufficient" (more than one behaviorally distinct piece of code that assembles the final view of the data can exist and have the same topological structure of serial data).')]),e._v(" "),a("p",[e._v('But "nice and not sufficient" can still be traits of an overall good idea.')]),e._v(" "),a("p",[e._v("And maybe a schema that has sufficiently high entropy (e.g. some fields with intentionally unusual names, such that "),a("a",{attrs:{href:"https://github.com/ipld/go-ipld-prime/blob/f2d595797253f736988a9a2402c2a5a0a05d4e93/doc/schema.md#using-schema-match-checking-as-version-detection",target:"_blank",rel:"noopener noreferrer"}},[e._v('it effectively becomes "version"-detection'),a("OutboundLink")],1),e._v(') can actually make "sufficient" for-all-practical-purposes true.  Hrm.')]),e._v(" "),a("hr"),e._v(" "),a("h4",{attrs:{id:"_2019-06-20t09-36-08z-referenced-by-warpfork-in-commit-7bef6e7226e34ee532c2d49f97706d5828bc0736"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-06-20t09-36-08z-referenced-by-warpfork-in-commit-7bef6e7226e34ee532c2d49f97706d5828bc0736"}},[e._v("#")]),e._v(" (2019-06-20T09:36:08Z) Referenced by warpfork in commit 7bef6e7226e34ee532c2d49f97706d5828bc0736")])])}),[],!1,null,null,null);t.default=i.exports}}]);