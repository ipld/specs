(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{417:function(e,t,a){"use strict";a.r(t);var o=a(44),s=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("This document was archived from https://github.com/ipld/specs/issues/120.")]),e._v(" "),a("h2",{attrs:{id:"_120-graphsync-data-deduplication-across-simultaneous-queries"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_120-graphsync-data-deduplication-across-simultaneous-queries"}},[e._v("#")]),e._v(" #120: GraphSync: Data Deduplication Across Simultaneous Queries")]),e._v(" "),a("p",[e._v("Opened 2019-05-03T19:02:15Z by aschmahmann")]),e._v(" "),a("h2",{attrs:{id:"overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),a("p",[e._v("There are a few important cases where it would be very useful to have multiple queries that access similar data be bunched together. These can be handled at the either at the Selectors layer or at the GraphSync layer. Given both my interest in data deduplication, as opposed to query traversal, and the concerns with CID selectors raised in #116 I propose handling this at the GraphSync layer.")]),e._v(" "),a("h2",{attrs:{id:"useful-examples"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#useful-examples"}},[e._v("#")]),e._v(" Useful Examples")]),e._v(" "),a("p",[e._v("To understand the utility of handling a query of these simultaneous queries let's look at two examples:")]),e._v(" "),a("h3",{attrs:{id:"resuming-interrupted-queries"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#resuming-interrupted-queries"}},[e._v("#")]),e._v(" Resuming Interrupted Queries")]),e._v(" "),a("p",[e._v("We ask for the full graph starting at Root:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Root\n/    |    \\\nA0   B0   C0\n|     |     |\nA1   ...   ...\n|\nA2\n")])])]),a("p",[e._v("We then get interrupted in our DFS resolution of the graph and only receive nodes "),a("code",[e._v("Root, A0, A1")]),e._v(". If we want to resume our session, whether with the same peer or a different one, we would like to not get repeats of the nodes we already have. There are a variety of ways to describe how to resume our sync, they are of the form: I want the graph rooted at "),a("code",[e._v("Root")]),e._v(" and I")]),e._v(" "),a("ol",[a("li",[e._v("Have first 3 nodes of the query")]),e._v(" "),a("li",[e._v("Have nodes "),a("code",[e._v("Root, A0, A1")]),e._v(" (or some condensed form like "),a("code",[e._v("A1")]),e._v(" and all parents)")]),e._v(" "),a("li",[e._v("Want to start with "),a("code",[e._v("A2, B0, C0")])])]),e._v(" "),a("p",[e._v("While option 1 is the most efficient it requires both peers doing the traversals in the same order which we might not be prepared to guarantee - something I think has already been looked into and that I'm probably just lacking context for. Options 2 and 3 are similar as they are essentially inverses.")]),e._v(" "),a("p",[a("strong",[e._v("Option 3")]),e._v(" would be greatly helped by allowing data deduplication across queries/queries being grouped together.")]),e._v(" "),a("h3",{attrs:{id:"versioned-data-git-operational-transform-crdts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#versioned-data-git-operational-transform-crdts"}},[e._v("#")]),e._v(" Versioned Data (Git, Operational Transform, CRDTs, ....)")]),e._v(" "),a("p",[e._v("We start with a graph "),a("code",[e._v("G")]),e._v(" at state "),a("code",[e._v("G0")]),e._v(", and then created two modified versions of the graph "),a("code",[e._v("G1")]),e._v(" and "),a("code",[e._v("G2")]),e._v(" both of which reference the previous state, "),a("code",[e._v("G0")]),e._v(". We then give a friend the CIDs to the latest versions of "),a("code",[e._v("G")]),e._v(" (which as far as we know are "),a("code",[e._v("G1")]),e._v(" and "),a("code",[e._v("G2")]),e._v("). The friend then uses GraphSync to ask us (or some other peer) for the full graphs under "),a("code",[e._v("G1")]),e._v(" and "),a("code",[e._v("G2")]),e._v(". We would like to not get the data under "),a("code",[e._v("G0")]),e._v(" more than once.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("G1      G2\n\\    /\nG0\n")])])]),a("h2",{attrs:{id:"how-we-might-handle-this"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-we-might-handle-this"}},[e._v("#")]),e._v(" How we might handle this")]),e._v(" "),a("p",[e._v("Fundamentally what's being asked for is that GraphSync retain the list of sent blocks per peer longer. The balancing act required in the solution is how we support this while not allowing a single peer to eat up all of a GraphSync responder's resources.")]),e._v(" "),a("h3",{attrs:{id:"send-bundled-requests"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#send-bundled-requests"}},[e._v("#")]),e._v(" Send Bundled Requests")]),e._v(" "),a("p",[e._v("Allow sending multiple requests together such that GraphSync knows not to GC its list of sent blocks per peer. The protocol already allows for sending multiple requests together so all we could easily support this by just A) holding off on the GC until the full multi-request is complete or B) add a flag saying that for this particular multi-request we should hold off the GC until the multi-request is complete.")]),e._v(" "),a("h3",{attrs:{id:"allow-append-requests"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#allow-append-requests"}},[e._v("#")]),e._v(" Allow Append Requests")]),e._v(" "),a("p",[e._v("All subrequests are still processed individually, but the requests can have a field tying those requests to other on-going requests for GC purposes.")]),e._v(" "),a("hr"),e._v(" "),a("h4",{attrs:{id:"_2019-05-03t21-22-38z-stebalien"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-05-03t21-22-38z-stebalien"}},[e._v("#")]),e._v(" (2019-05-03T21:22:38Z) Stebalien:")]),e._v(" "),a("p",[e._v("Make sure to look at https://github.com/ipfs/notes/issues/272#issuecomment-341996490 and https://github.com/ipfs/notes/issues/272#issuecomment-345897231. Those proposals tried to address this by ensuring that every node touched got sent back to the client.")]),e._v(" "),a("p",[e._v("However, you bring up a very real problem: we need to be able to sync things like git repos.")]),e._v(" "),a("blockquote",[a("p",[e._v("How we might handle this")])]),e._v(" "),a("p",[e._v('I\'m not sure if either of these solutions are sufficient. I need to be able to say "I already have everything from commit Y back, only give me nodes introduced between Head and Y". I may have fetched '),a("code",[e._v("Y")]),e._v(" ages ago or from another peer.")]),e._v(" "),a("p",[e._v("IIRC, "),a("em",[e._v("git")]),e._v(" does this by keeping local metadata. I wonder if we need to do the same.")]),e._v(" "),a("hr"),e._v(" "),a("h4",{attrs:{id:"_2019-05-03t23-48-27z-aschmahmann"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-05-03t23-48-27z-aschmahmann"}},[e._v("#")]),e._v(" (2019-05-03T23:48:27Z) aschmahmann:")]),e._v(" "),a("p",[e._v("@Stebalien @hannahhoward @warpfork correct me if I'm wrong here, but we are already planning to use the "),a("a",{attrs:{href:"https://github.com/ipld/specs/blob/4fc79023df9e4bd0eb226c24db12701fca6498ee/selectors/selectors.md#recursive-selector",target:"_blank",rel:"noopener noreferrer"}},[e._v("Recursive selector"),a("OutboundLink")],1),e._v(" to implement")]),e._v(" "),a("blockquote",[a("p",[e._v('"I already have everything from commit Y back, only give me nodes introduced between Head and Y"')])]),e._v(" "),a("p",[e._v("The problem becomes when I want to say I have the heads of branches "),a("code",[e._v("A,B,C")]),e._v(" and the latest commits in each of these nodes are "),a("code",[e._v("A0,B0,C0")]),e._v(" where maybe "),a("code",[e._v("B0")]),e._v(" points to "),a("code",[e._v("C0")]),e._v(" and it's possible all 3 of these branches merged in between "),a("code",[e._v("A0,B0,C0")]),e._v(" and "),a("code",[e._v("A, B, C")]),e._v(".")]),e._v(" "),a("p",[e._v("If we use the "),a("strong",[e._v("Send Bundled Request")]),e._v(" solution then we send something like "),a("code",[e._v("[RecursiveSelect(A to A0), RecursiveSelect(B to B0), RecursiveSelect(C to C0)]")]),e._v(". This will get us back the right data, however if we don't use any compound query smarts and we're unlucky we could send back all the nodes from "),a("code",[e._v("C")]),e._v(" to "),a("code",[e._v("C0")]),e._v(", including the nodes from "),a("code",[e._v("B0")]),e._v(" to "),a("code",[e._v("C0")]),e._v(", before we start any processing on "),a("code",[e._v("B")]),e._v(" and noticing the overlap.")]),e._v(" "),a("p",[e._v("If we use the "),a("strong",[e._v("Allow Append Requests")]),e._v(" option then we send "),a("code",[e._v("RecursiveSelect(A to A0)")]),e._v(" (which has query ID QA), "),a("code",[e._v("[RecursiveSelect(B to B0), attach to QA]")]),e._v(", "),a("code",[e._v("[RecursiveSelect(C to C0), attach to QB]")]),e._v(". Alternatively we could create an ID for this particular message group QG and use that. As we start to receive nodes in the "),a("code",[e._v("C")]),e._v(" branch that we already have such as "),a("code",[e._v("B0")]),e._v(" we send a cancel command that tells GraphSync to stop sending "),a("code",[e._v("B0")]),e._v(" or its subnodes.")]),e._v(" "),a("p",[e._v('You might notice that the "cancel" commands here are effectively the same as the sub/children selectors since it the command ends up being an unSelector/a selector describing nodes we don\'t want. We could certainly limit the complexity of these unselectors to be basically just "I have this subnode". However, I definitely see the temptations to make arbitrary selectors work here and I would bet that folks, such as @warpfork, would have serious concerns about the possibly NP-complete problems we would then be putting on GraphSync responders.')]),e._v(" "),a("p",[e._v("Alternatively, there's a perhaps simpler (if more verbose and costly) solution. If we use BFS instead of DFS on the selectors and we notice that that we already have "),a("code",[e._v("B0")]),e._v(", a node in "),a("code",[e._v("C")]),e._v("s history, we wait until we are sent one of "),a("code",[e._v("B0")]),e._v("s predecessor nodes (let's call it "),a("code",[e._v("B1")]),e._v("). Then because we are using BFS and have received "),a("code",[e._v("B1")]),e._v(" we are guaranteed to have all of "),a("code",[e._v("B0")]),e._v("s siblings that are in "),a("code",[e._v("C")]),e._v("s history, let's call them "),a("code",[e._v("S0, S1,...")]),e._v(". We can then send a multi-request "),a("code",[e._v("{[RecursiveSelect(S0 to C0), attach to QC], [RecursiveSelect(S1 to C0), attach to QC],...Cancel(Request C)}")])]),e._v(" "),a("p",[e._v("Since we already have the ability to cancel GraphSync requests this means the only new part of this  scheme is the grouping of requests across multiple messages.")]),e._v(" "),a("hr"),e._v(" "),a("h4",{attrs:{id:"_2019-05-05t19-56-11z-warpfork"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-05-05t19-56-11z-warpfork"}},[e._v("#")]),e._v(" (2019-05-05T19:56:11Z) warpfork:")]),e._v(" "),a("p",[e._v("There's more going on here than I can immediately mentally unpack and fully engage with, but there's a couple quick factual bits I can toss in...")]),e._v(" "),a("p",[e._v("Git does this with wantlists and havelists and the reconciliation between them is not particularly free. Simply exchanging those messages is O(n) in the wantlength and the havelength.  Git does not know anything about branches and lineages when syncing.  Here are implementations of this in a go-git project: "),a("a",{attrs:{href:"https://github.com/src-d/go-git/blob/662e2c226e9b8352a90cd1951233fab30a4e5042/plumbing/protocol/packp/uppackreq.go#L68",target:"_blank",rel:"noopener noreferrer"}},[e._v("wants"),a("OutboundLink")],1),e._v(", "),a("a",{attrs:{href:"https://github.com/src-d/go-git/blob/662e2c226e9b8352a90cd1951233fab30a4e5042/plumbing/protocol/packp/uppackreq.go#L68",target:"_blank",rel:"noopener noreferrer"}},[e._v("haves"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("Git is great, but it's not necessarily correct to assume it's going to scale awesomely if you took all content in all repos ever and hucked them together in one big content-addressable store with no additional protocol improvements.")]),e._v(" "),a("p",[e._v("In general, these discussions need "),a("code",[e._v("O")]),e._v("'s and "),a("code",[e._v("n")]),e._v("'s attached to them or it's very hard to get anywhere.")]),e._v(" "),a("hr"),e._v(" "),a("h4",{attrs:{id:"_2019-05-06t11-06-09z-vmx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-05-06t11-06-09z-vmx"}},[e._v("#")]),e._v(" (2019-05-06T11:06:09Z) vmx:")]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("Option 3")]),e._v(" would be greatly helped by allowing data deduplication across queries/queries being grouped together.")])]),e._v(" "),a("p",[e._v("That's kind of what I had in mind in the "),a("a",{attrs:{href:"https://github.com/ipld/specs/blob/69bd0215c9ecb372b1cf20b5a81eae9d99fabf0b/graphsync.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("GraphSync (A) proposal"),a("OutboundLink")],1),e._v(". That GraphSync itself has enough state locally to resume queries.")]),e._v(" "),a("hr"),e._v(" "),a("h4",{attrs:{id:"_2019-05-06t16-11-00z-aschmahmann"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2019-05-06t16-11-00z-aschmahmann"}},[e._v("#")]),e._v(" (2019-05-06T16:11:00Z) aschmahmann:")]),e._v(" "),a("p",[e._v("@vmx yes and even with the existing GraphSync proposal there is enough information to be able to resume queries from some application level above GraphSync. Unfortunately, if we don't make some change to GraphSync (like one of the two mentioned above) the application level resuming won't be able to be as efficient as it could be.")]),e._v(" "),a("p",[e._v("@warpfork I agree with your point about wanting more asymptotic quantification of what we're gaining/losing with particular changes and algorithms. Due to most of these algorithms/strategies having performance highly dependent on DAG shape and pre-existing state (e.g. what data a GraphSync client already has) as well as networking factors like latency, I suspect anything we come up with is not going to look like "),a("code",[e._v("O(n)")]),e._v(" but instead will instead be a function of many variables.")]),e._v(" "),a("p",[e._v("Let's look at a couple cases where current GraphSync will get us our data, but be more expensive then if it were tweaked with one of the mechanisms above:")]),e._v(" "),a("h3",{attrs:{id:"versioned-data-resuming-interrupted-queries-example"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#versioned-data-resuming-interrupted-queries-example"}},[e._v("#")]),e._v(" Versioned Data/Resuming Interrupted Queries Example")]),e._v(" "),a("p",[e._v("If we take the graph from Resuming Interrupted Queries and assert that all "),a("code",[e._v("h")]),e._v(" of the heads (e.g. "),a("code",[e._v("A2, B0, C0, ...")]),e._v(") all point to a graph "),a("code",[e._v("G")]),e._v(" with "),a("code",[e._v("n")]),e._v(" nodes then, in the case of unlucky garbage collection, we end up with O("),a("code",[e._v("hn")]),e._v(") nodes if we don't send any cancellations. Alternatively, if "),a("code",[e._v("l")]),e._v(" nodes can be sent from the resolver to the requester during a single round-trip time then the requester receives "),a("code",[e._v("O(lh + h)")]),e._v(" nodes if we always send cancellations.")]),e._v(" "),a("p",[e._v("However, if we utilize either of the above proposals the requester ends up with only "),a("code",[e._v("O(h)")]),e._v(" nodes.")]),e._v(" "),a("h3",{attrs:{id:"pathological-highly-overlapping-graph"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pathological-highly-overlapping-graph"}},[e._v("#")]),e._v(" Pathological highly overlapping graph")]),e._v(" "),a("p",[e._v("We have a DAG "),a("code",[e._v("D")]),e._v(" where each node has "),a("code",[e._v("b+1")]),e._v(" children where "),a("code",[e._v("b")]),e._v(" of the children point into a subgraph "),a("code",[e._v("G")]),e._v(" and the last child has "),a("code",[e._v("b+1")]),e._v(" children that follow the same pattern (unless it's the bottom of the DAG and it has 0 children).")]),e._v(" "),a("p",[e._v("We initiated two GraphSyncs together, one for "),a("code",[e._v("G")]),e._v(" and the other for "),a("code",[e._v("D")]),e._v(". We received "),a("code",[e._v("G")]),e._v(" in its entirety before starting to receive anything from "),a("code",[e._v("D")]),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("Currently:")]),e._v(" We will not store any references to "),a("code",[e._v("G")]),e._v(" as we're sending "),a("code",[e._v("D")]),e._v(" since they are garbage collected once the "),a("code",[e._v("G")]),e._v(" request is finished. Therefore, as we use DFS to walk down "),a("code",[e._v("D")]),e._v(", every time the client receives the root of "),a("code",[e._v("G")]),e._v(" it sends a cancel request followed by requests for all of the siblings of that "),a("code",[e._v("G")]),e._v("s parent node. This is "),a("code",[e._v("b + Sum_(i=1...b) i= O(b^2)")]),e._v(" cancel requests + regular requests per node containing new information. For "),a("code",[e._v("D")]),e._v(" with depth "),a("code",[e._v("d")]),e._v(" (of nodes not in "),a("code",[e._v("G")]),e._v(") this means "),a("code",[e._v("O(d*b^2)")]),e._v(" requests are made. Additionally if "),a("code",[e._v("l")]),e._v(" nodes can be sent from the resolver to the requester during a single round-trip time then an additional "),a("code",[e._v("O(d*l)")]),e._v(" nodes from "),a("code",[e._v("G")]),e._v(" that the requester already has are resent.  If "),a("code",[e._v("G")]),e._v(" has many more nodes than "),a("code",[e._v("d(b^2+l)")]),e._v(" then while we've wasted resources it's still more efficient then if we hadn't sent any cancellations and new requests. However, if not then our premature optimization has in fact made things worse.")]),e._v(" "),a("p",[a("strong",[e._v("Either of the above proposals:")]),e._v(" We store references to "),a("code",[e._v("G")]),e._v(" even as we're walking down "),a("code",[e._v("D")]),e._v(" since the two are bound together. This results in none of the excess "),a("code",[e._v("O(d*[b^2+l])")]),e._v(" messages from before.")]),e._v(" "),a("p",[a("strong",[e._v("What's missing:")]),e._v(" If instead of retrieving "),a("code",[e._v("G")]),e._v(" and "),a("code",[e._v("D")]),e._v(" from the same peer I ask for "),a("code",[e._v("D")]),e._v(" without "),a("code",[e._v("G")]),e._v(" (e.g. I already have it, I received it from an interrupted query for "),a("code",[e._v("G")]),e._v(" + "),a("code",[e._v("D")]),e._v(", I'm asking for it from another peer, etc,) I still end up with the excess messages. This stems from our lack of a "),a("code",[e._v("havelist")]),e._v(" and our reliance on cancel + rerequest as a solution here.")]),e._v(" "),a("h2",{attrs:{id:"conclusion"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" Conclusion")]),e._v(" "),a("p",[e._v("Having any way at all for the requester to inject information into the GraphSync process running on the resolver could help reduce extraneous messages. However, I'm a bit concerned about how deep the rabbit hole on using selectors for this could be. Therefore, I'm suggesting that maybe we can start by just using one or two simple mechanisms that can potentially save a lot of resources.")])])}),[],!1,null,null,null);t.default=s.exports}}]);