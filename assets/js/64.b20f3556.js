(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{419:function(e,t,a){"use strict";a.r(t);var s=a(42),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"authoring-ipld-schemas"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#authoring-ipld-schemas"}},[e._v("#")]),e._v(" Authoring IPLD Schemas")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#basics"}},[e._v("Basics")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#records-type-and-advanced"}},[e._v("Records: "),a("code",[e._v("type")]),e._v(" and "),a("code",[e._v("advanced")])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#newlines-and-whitespace"}},[e._v("Newlines and Whitespace")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#comments"}},[e._v("Comments")])])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#schema-kinds"}},[e._v("Schema Kinds")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#naming-types"}},[e._v("Naming Types")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#named-scalar-types-typedefs"}},[e._v("Named Scalar Types (typedefs)")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#links"}},[e._v("Links")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#inline-recursive-types"}},[e._v("Inline Recursive Types")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#representations"}},[e._v("Representations")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#representation-parameters"}},[e._v("Representation Parameters")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#general-representation-parameters"}},[e._v("General Representation Parameters")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#field-specific-representation-parameters"}},[e._v("Field-specific Representation Parameters")])])])])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#structs"}},[e._v("Structs")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#enums"}},[e._v("Enums")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#unions"}},[e._v("Unions")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#introduction-to-unions-kinded-unions"}},[e._v("Introduction to Unions: Kinded Unions")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#limitations-of-union-discrimination"}},[e._v("Limitations of Union Discrimination")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#alternative-discrimination-strategies"}},[e._v("Alternative Discrimination Strategies")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#keyed"}},[e._v("Keyed")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#envelope"}},[e._v("Envelope")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#inline"}},[e._v("Inline")])])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#byteprefix-unions-for-bytes"}},[e._v("Byteprefix Unions for Bytes")])])])]),e._v(" "),a("li",[a("a",{attrs:{href:"#copy"}},[e._v("Copy")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#advanced-data-layouts"}},[e._v("Advanced Data Layouts")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#schemas-in-markdown"}},[e._v("Schemas in Markdown")])])]),e._v(" "),a("p",[e._v("IPLD Schemas can be represented in a compact, human-friendly "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Domain_specific_language",target:"_blank",rel:"noopener noreferrer"}},[e._v("DSL"),a("OutboundLink")],1),e._v(". IPLD Schemas can also be naturally represented as an IPLD node graph, typically presented in JSON form. The human-friendly DSL compiles into this IPLD-native format.")]),e._v(" "),a("h2",{attrs:{id:"basics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#basics"}},[e._v("#")]),e._v(" Basics")]),e._v(" "),a("h3",{attrs:{id:"records-type-and-advanced"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#records-type-and-advanced"}},[e._v("#")]),e._v(" Records: "),a("code",[e._v("type")]),e._v(" and "),a("code",[e._v("advanced")])]),e._v(" "),a("p",[e._v("IPLD Schemas typically comprise a collection of optionally interdependent types. Each type definition starts with a "),a("code",[e._v("type")]),e._v(" prefix at the beginning of a line, followed by the type's name and then its definition. One other style of record optionally exists within an IPLD Schema, Advanced Data Layouts. These replace the "),a("code",[e._v("type")]),e._v(" keyword with "),a("code",[e._v("advanced")]),e._v(" and have specific rules about their contents. More on this below.")]),e._v(" "),a("h3",{attrs:{id:"newlines-and-whitespace"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#newlines-and-whitespace"}},[e._v("#")]),e._v(" Newlines and Whitespace")]),e._v(" "),a("p",[e._v("The DSL treats newlines as significant, they are used to break up records ("),a("code",[e._v("type")]),e._v(" and "),a("code",[e._v("advanced")]),e._v(") and descriptors within records. Newlines are used in a similar way to programming languages that substitute C-style "),a("code",[e._v(";")]),e._v(" breaks with significant newlines.")]),e._v(" "),a("p",[e._v("Multiple newline characters are folded in to one during parsing, so newlines may be used for formatting and documentation purposes where appropriate. It is also not necessary to separate records by a specific number of newlines, although a single blank line is typical.")]),e._v(" "),a("p",[e._v("Whitespace characters (tab and space) are also folded in to a single space during parsing, so may be used for formatting and documentation purposes where appropriate. Most tokens that don't need to be proceeded by a newline should be separated by at least one newline character. There are other tokens that don't strictly require a newline (e.g. "),a("code",[e._v("{String:Int}")]),e._v(" for Map definitions where 5 tokens may be conjoined, but also may be separated, "),a("code",[e._v("{ String : Int }")]),e._v("). Indenting is not strictly required for record component descriptors but are typical as they can be used to express intent.")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  a   Int\n  b   Int\n  msg Message\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Message")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("string")]),e._v("\n")])])]),a("p",[e._v("In this example:")]),e._v(" "),a("ul",[a("li",[e._v("The whitespace between non-punctuation tokens is required ("),a("code",[e._v("typeMessagestring")]),e._v(" would be nonsense!)")]),e._v(" "),a("li",[e._v("At least one newline between each component of the "),a("code",[e._v("Foo")]),e._v(" record are required such that "),a("code",[e._v("a")]),e._v(", "),a("code",[e._v("b")]),e._v(", and "),a("code",[e._v("msg")]),e._v(" are all on separate lines.")]),e._v(" "),a("li",[e._v("The indenting for "),a("code",[e._v("a")]),e._v(", "),a("code",[e._v("b")]),e._v(", and "),a("code",[e._v("msg")]),e._v(" is optional but helps express the ownership of these items to the parent record.")]),e._v(" "),a("li",[e._v("The additional spaces between "),a("code",[e._v("a")]),e._v(", "),a("code",[e._v("b")]),e._v(" and their "),a("code",[e._v("Int")]),e._v(" type descriptors is optional and used as a formatting nicety to line up the types in a Struct.")]),e._v(" "),a("li",[e._v("The blank line between the close of "),a("code",[e._v("Foo")]),e._v(" and "),a("code",[e._v("Message")]),e._v(" is optional but is intended to help with readability.")]),e._v(" "),a("li",[e._v("Newline and space rules for "),a("code",[e._v("{")]),e._v(" and "),a("code",[e._v("}")]),e._v(" are lax but convention is to use the locations and spacing in this example.")])]),e._v(" "),a("h3",{attrs:{id:"comments"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#comments"}},[e._v("#")]),e._v(" Comments")]),e._v(" "),a("p",[e._v("All characters on a line following a "),a("code",[e._v("#")]),e._v(" character are ignored during parsing. This allows for full-line comments and comments trailing Schema DSL tokens:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This is a (pseudo)block comment")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  a Int "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# An inline comment")]),e._v("\n  b Int\n  msg Message\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Another full-line comment")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Message")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("string")]),e._v("\n")])])]),a("h2",{attrs:{id:"schema-kinds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#schema-kinds"}},[e._v("#")]),e._v(" Schema Kinds")]),e._v(" "),a("p",[e._v("See "),a("RouterLink",{attrs:{to:"/html/schemas/schema-kinds.html"}},[e._v("IPLD Schema Kinds")]),e._v(" for more information on this topic.")],1),e._v(" "),a("p",[e._v("The schema kinds have matching tokens that appear throughout IPLD Schemas. Depending on context, the tokens are either lower-case (e.g. "),a("code",[e._v("int")]),e._v(") or title-case (e.g. "),a("code",[e._v("Int")]),e._v("), or may omitted entirely because they can be reliably inferred. This will become clear as we proceed.")]),e._v(" "),a("ul",[a("li",[e._v("Null: may appear as a typedef'd "),a("code",[e._v("null")]),e._v(" but there is discussion regarding the possibility of changing the semantics of how Null is used in Schemas. It is not commonly useful outside of the "),a("code",[e._v("nullable")]),e._v(" signifier for Struct fields.")]),e._v(" "),a("li",[e._v("Boolean: may appear as "),a("code",[e._v("Bool")]),e._v(" for a component specifier or "),a("code",[e._v("bool")]),e._v(" as a typedef.")]),e._v(" "),a("li",[e._v("Integer: May appear as "),a("code",[e._v("Int")]),e._v(" for a component specifier or "),a("code",[e._v("int")]),e._v(" as a typedef. There are no additional specifiers for integer size or signedness (although this may appear as adjuncts for codegen in the future).")]),e._v(" "),a("li",[e._v("Float: May appear as "),a("code",[e._v("Float")]),e._v(" for a component specifier or "),a("code",[e._v("float")]),e._v(" as a typedef. There are no additional specifiers for size or byte representation (although this may appear as adjuncts for codegen in the future).")]),e._v(" "),a("li",[e._v("String: May appear as "),a("code",[e._v("String")]),e._v(" for a component specifier or "),a("code",[e._v("string")]),e._v(" as a typedef. The Data Model assumes unicode. Specific string encodings also appear as representation forms, see below.")]),e._v(" "),a("li",[e._v("Bytes: May appear as "),a("code",[e._v("Bytes")]),e._v(" for a component specifier or "),a("code",[e._v("bytes")]),e._v(" as a typedef. There are no additional specifiers for byte array length and there is no way to specify a single byte. The "),a("code",[e._v("byteprefix")]),e._v(" Union representation type is a special case indicating a single byte dictates the type of the proceeding bytes, see below.")]),e._v(" "),a("li",[e._v("List: Is inferred by the "),a("code",[e._v("[Type]")]),e._v(' shorthand for both typedefs and inline component specification. The token "List" is not used in the Schema DSL and all Lists must have value type specified (although Unions allow for significant flexibility here).')]),e._v(" "),a("li",[e._v("Map: Is inferred by the "),a("code",[e._v("{KeyType:ValueType}")]),e._v(' shorthand for both typedefs and inline component specification. The token "Map" is not used in the Schema DSL and all Maps must have key and value type specified (although Unions allow for significant flexibility here).')]),e._v(" "),a("li",[e._v("Link: The "),a("code",[e._v("&")]),e._v(" token prefixing a type is used as a shorthand for links. A generic link to an untyped resource uses the special "),a("code",[e._v("&Any")]),e._v(", while a link where there is an expected type to be found uses that type name as a hinting mechanism, "),a("code",[e._v("&Foo")]),e._v(". See below and "),a("RouterLink",{attrs:{to:"/html/schemas/links.html"}},[e._v("Links and IPLD Schemas")]),e._v(" for more information.")],1),e._v(" "),a("li",[e._v("Union: Appears as "),a("code",[e._v("union")]),e._v(" following "),a("code",[e._v("type")]),e._v(" and the Union's type name.")]),e._v(" "),a("li",[e._v("Struct: Appears as "),a("code",[e._v("struct")]),e._v(" following "),a("code",[e._v("type")]),e._v(" and the Struct's type name.")]),e._v(" "),a("li",[e._v("Enum: Appears as "),a("code",[e._v("enum")]),e._v(" following "),a("code",[e._v("type")]),e._v(" and the Enum's type name.")]),e._v(" "),a("li",[e._v("Copy: Uses the shorthand "),a("code",[e._v("=")]),e._v(" to indicate a copy type, as in "),a("code",[e._v("type Foo = Bar")]),e._v('. The token "Copy" does not directly appear in the Schema DSL.')])]),e._v(" "),a("h2",{attrs:{id:"naming-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#naming-types"}},[e._v("#")]),e._v(" Naming Types")]),e._v(" "),a("p",[e._v("Type names "),a("em",[e._v("must")]),e._v(" only contain alphanumeric ASCII characters and underscores. The first character "),a("em",[e._v("must")]),e._v(" be a capital letter. Multiple connected underscores "),a("em",[e._v("should")]),e._v(" be avoided (they should be reserved for codegen purposes). A strict regular expression for type names would be: "),a("code",[e._v("[a-zA-Z][a-zA-Z0-9_]*")]),e._v(". A regular expression following convention would be: "),a("code",[e._v("[A-Z][a-zA-Z0-9_]*")]),e._v(" (disregarding the multiple-underscore rule for simplicity).")]),e._v(" "),a("p",[e._v("Camel case with an upper case first character is recommended. Underscore "),a("code",[e._v("_")]),e._v(" should be used sparingly. "),a("code",[e._v("ThisIsRecommend")]),e._v(", "),a("code",[e._v("This_Not_So_Much")]),e._v(", "),a("code",[e._v("Thisisnotrecommended")]),e._v(", "),a("code",[e._v("neitherIsThis")]),e._v(".")]),e._v(" "),a("p",[e._v("Type names are unique within a Schema and are ideally unique within related Schema documents; overlapping names are generally not ideal for documentation purposes. Certain forms of Schema kind identifiers are forbidden and those forms that are not forbidden should be avoided to save confusion for documentation purposes. i.e. "),a("code",[e._v("Null")]),e._v(", "),a("code",[e._v("Boolean")]),e._v(", "),a("code",[e._v("Int")]),e._v(", "),a("code",[e._v("Float")]),e._v(", "),a("code",[e._v("String")]),e._v(", "),a("code",[e._v("Bytes")]),e._v(" are strictly not allowed as type names (they are already implicit type names), and their lower-case counterparts and the additional schema kinds should be avoided.")]),e._v(" "),a("p",[a("strong",[e._v("Type names should be used as a documentation tool")]),e._v(". They don't need to be short if long names are more helpfully descriptive.")]),e._v(" "),a("h2",{attrs:{id:"named-scalar-types-typedefs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#named-scalar-types-typedefs"}},[e._v("#")]),e._v(" Named Scalar Types (typedefs)")]),e._v(" "),a("p",[e._v("The non-recursive (scalar) Schema kinds (Boolean, Integer, Float, String, Bytes, Link) may all appear as typedef'd types. That is, a unique name may be assigned to a kind and that name may be used in place of the kind later in the schema. Multiple unique type names may share the same kind.")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("string")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Bar")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Boom")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("Foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("Bar"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("In terms of data layout, this is equivalent to:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Boom")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("Int"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("(Note that even though the Data Model only allows for string keys of maps, the indirection through type "),a("code",[e._v("Foo")]),e._v(" is allowed since it has a string representation.)")]),e._v(" "),a("p",[e._v("There are a number of reasons to typedef a scalar Schema kind:")]),e._v(" "),a("ul",[a("li",[e._v("Documentation: A stand-alone type can be more easily documented in the Schema DSL. This may be helpful where there are additional rules that surround a type that are not expressible in the DSL but readers of the Schema may need to be aware of. You will find a lot of such typedefs in the "),a("RouterLink",{attrs:{to:"/html/schemas/schema-schema.ipldsch.html"}},[e._v("schema-schema")]),e._v(".")],1),e._v(" "),a("li",[e._v("Highlighting re-use: Where the re-use of a particular Schema kind is noteworthy, naming it may help in expressing intent.")]),e._v(" "),a("li",[e._v("Codegen: the use of named types will have implications for codegen tools. It may be desirable for code generated from a Schema to have recognizable type names in certain positions.")])]),e._v(" "),a("h2",{attrs:{id:"links"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[e._v("#")]),e._v(" Links")]),e._v(" "),a("p",[e._v('Links in IPLD Schemas are a special-case. The Data Model kind "Link" is expressed by a token prefixed with the '),a("code",[e._v("&")]),e._v(" character. The remainder of the token should be "),a("code",[e._v("Any")]),e._v(" or the name of a type.")]),e._v(" "),a("p",[e._v("Links can be typedef'd, "),a("code",[e._v("type Foo &Bar")]),e._v(" or can appear inline: "),a("code",[e._v("type Baz {String:&Bang}")]),e._v(".")]),e._v(" "),a("p",[e._v("Further, the type name is not a strict assertion that can be directly tested against underlying data, it is simply a hint regarding what should be found when following the link identified by the "),a("a",{attrs:{href:"https://github.com/ipld/specs/blob/master/block-layer/CID.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("CID"),a("OutboundLink")],1),e._v(" at the position indicated by the Schema link. Strict assertions of this expected type may be applied at layers above the Schema validation layer when the link is resolved and the node decoded.")]),e._v(" "),a("p",[e._v("For more information about Links in Schemas, see "),a("RouterLink",{attrs:{to:"/html/schemas/links.html"}},[e._v("Links and IPLD Schemas")]),e._v(".")],1),e._v(" "),a("h2",{attrs:{id:"inline-recursive-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inline-recursive-types"}},[e._v("#")]),e._v(" Inline Recursive Types")]),e._v(" "),a("p",[e._v("The scalar types (Boolean, Integer, Float, String, Bytes, Link) may appear inline or be typedef'd. In addition, both Map and Link types may appear both inline and as their own type. The additional Schema kinds (Struct, Enum, Union, Copy) do not have an inline variant.")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("IntList")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Int"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MapOfIntLists")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("IntList"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  id Int\n  data MapOfIntLists\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("is equivalent to:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  id Int\n  data "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Int"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("As with typedef'd scalar kinds, this has implications for codegen and other API interactions with Schema types. Rather than having a explicit names, "),a("code",[e._v("MapOfIntLists")]),e._v(" and "),a("code",[e._v("IntList")]),e._v(", auto-generated names may be applied to "),a("code",[e._v("Foo->data")]),e._v(" and the type of the List nodes found within that Map. (e.g. perhaps "),a("code",[e._v("Foo__dataType")]),e._v(", "),a("code",[e._v("Foo__data__valueType")]),e._v(").")]),e._v(" "),a("p",[e._v("The inline facility is provided for convenience but explicitness is always recommended above expedience, including this case, in order to improve the documentation role of Schemas. By naming Map and List elements the author can express intent to the user and provide clarity through Schema-consuming tools.")]),e._v(" "),a("h2",{attrs:{id:"representations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#representations"}},[e._v("#")]),e._v(" Representations")]),e._v(" "),a("p",[e._v('The concept of "representations" is a key component of IPLD Schemas and should be understood in order to create and read effective IPLD Schemas.')]),e._v(" "),a("p",[e._v('In the Data Model there are only 9 kinds (Null, Boolean, Integer, Float, String, Bytes, List, Map & Link). The Schema layer adds 4 more (Union, Struct, Enum & Copy). These aren\'t present at the Data Model and are opaque to serialization formats. Instead, they must be "represented" as a base Data Model kind. Each data type at the Schema layer, therefore, has a "representation kind". Scalar kinds are represented as the same kind at the Data Model layer (except in the case of Advanced Data Layouts, see below).')]),e._v(" "),a("p",[e._v("A Struct is represented as a Map by default when serialized and deserialized. The Struct adds the ability to apply additional constraints about the keys, the types found when consuming the value nodes of the Map, whether certain keys must be present and what to do when they aren't present. Enums also have a default representation; when one is not specified, they are assumed to be represented as Strings when serialized or deserialized, but with constraints about valid strings for the node(s) where the Enum appears.")]),e._v(" "),a("p",[e._v("A Copy type is a special case, it copies all properties of the copied type other than its name, including the representation.")]),e._v(" "),a("p",[e._v("Unions don't have a default representation as they express a concept that is commonly represented in a number of ways, so a representation must be supplied when defining a Union type.")]),e._v(" "),a("p",[e._v('Some Schema kinds have alternative representation "strategies" that dictate how a type is to be represented in serialized form. Most of these strategies change the representation kind of the type but some retain the same kind and simply alter how the type is encoded within that kind. The '),a("code",[e._v("stringjoin")]),e._v(" and "),a("code",[e._v("stringpairs")]),e._v(" representation strategies that can be used for Struct types both change the representation kind for a Struct from the default Map to a String. The method for encoding to a single String is different for both. A "),a("code",[e._v("stringjoin")]),e._v(" strategy appends the fields in order separated by a delimiter  (e.g. "),a("code",[e._v('"v1,v2"')]),e._v(") while a "),a("code",[e._v("stringpairs")]),e._v(" strategy include the field names, requiring a field delimited as well as an entry delimited (e.g. "),a("code",[e._v('"f1=v1,f2=v2"')]),e._v("). Similarly, the "),a("code",[e._v("listpairs")]),e._v(" and "),a("code",[e._v("tuple")]),e._v(" Struct representations both use a List representation kind but use different strategies to encode within a List.")]),e._v(" "),a("p",[e._v("To specify a type's representation, the keyword "),a("code",[e._v("representation")]),e._v(" is supplied after the main type definition and is followed by a representation strategy name valid for that type.")]),e._v(" "),a("p",[e._v("For example, consider this Struct:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOne "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("nullable")]),e._v(" String\n  fieldTwo Bool\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("We could decode the following JSON (using the DAG-JSON codec) into a "),a("code",[e._v("Foo")]),e._v(" type:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"fieldOne"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"This is field one of Foo"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"fieldTwo"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("A Struct can also have the default representation expressed explicitly:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOne "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("nullable")]),e._v(" String\n  fieldTwo Bool\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" map\n")])])]),a("p",[e._v("These two descriptors of "),a("code",[e._v("Foo")]),e._v(" are identical when parsed as the "),a("code",[e._v("representation map")]),e._v(" is implicit for Structs when a representation is not supplied.")]),e._v(" "),a("p",[e._v("The Struct can also be represented as a List when we supply the "),a("code",[e._v("tuple")]),e._v(" representation type:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOne "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("nullable")]),e._v(" String\n  fieldTwo Bool\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" tuple\n")])])]),a("p",[e._v("When encountering a Map at the Data Layer where this variant of "),a("code",[e._v("Foo")]),e._v(" is expected, an error or failed-validation would occur. Instead, the data for this Struct is a simple List of two elements, the first one a String and the second a Bool. In JSON this may look like:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"This is field one of Foo"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),a("p",[e._v("A full list of the available representation strategies and their kinds that can be supplied for various Schema kinds can be found in "),a("RouterLink",{attrs:{to:"/html/schemas/schema-kinds.html"}},[e._v("Representations of IPLD Schema Kinds")]),e._v(".")],1),e._v(" "),a("h3",{attrs:{id:"representation-parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#representation-parameters"}},[e._v("#")]),e._v(" Representation Parameters")]),e._v(" "),a("p",[e._v("Some representation strategies have additional parameters that can be supplied and some have required parameters that are required in order to properly shape the type representation. There are two methods that representation parameters are supplied: within the "),a("code",[e._v("representation")]),e._v(" block for general parameters and inline adjacent to type fields in parens where representation parameters are specific to fields.")]),e._v(" "),a("h4",{attrs:{id:"general-representation-parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#general-representation-parameters"}},[e._v("#")]),e._v(" General Representation Parameters")]),e._v(" "),a("p",[e._v("Our "),a("code",[e._v("Foo")]),e._v(" struct with a "),a("code",[e._v("tuple")]),e._v(" representation may be serialized in an alternate field order by supplying the general "),a("code",[e._v("fieldOrder")]),e._v(" parameter:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOne "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("nullable")]),e._v(" String\n  fieldTwo Bool\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" tuple "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOrder "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"fieldTwo"')]),e._v(", "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"fieldOne"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Serialization of such a type in JSON may appear as:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"This is field one of Foo"')]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),a("p",[e._v("The "),a("code",[e._v("stringjoin")]),e._v(" representation for Structs has a required parameter, "),a("code",[e._v("join")]),e._v(". There is no default for this parameter, so a Schema specifying a "),a("code",[e._v("stringjoin")]),e._v(" Struct without it is invalid:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOne "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("nullable")]),e._v(" String\n  fieldTwo Bool\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" stringjoin "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  join "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('":"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("This representation for "),a("code",[e._v("Foo")]),e._v(" would seriaize into a single String node:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"This is field one of Foo:false"')]),e._v("\n")])])]),a("p",[e._v("This representation for Structs has limitations as there is no escaping mechanism for the join character, so it should be used with caution. Similar restrictions apply to the "),a("code",[e._v("stringpairs")]),e._v(" Map representation. See "),a("RouterLink",{attrs:{to:"/html/schemas/schema-kinds.html"}},[e._v("Representations of IPLD Schema Kinds")]),e._v(" for more details on such restrictions.")],1),e._v(" "),a("h4",{attrs:{id:"field-specific-representation-parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#field-specific-representation-parameters"}},[e._v("#")]),e._v(" Field-specific Representation Parameters")]),e._v(" "),a("p",[e._v("The content in the main "),a("code",[e._v("type")]),e._v(" declaration block (between opening "),a("code",[e._v("{")]),e._v(" and closing "),a("code",[e._v("}")]),e._v(") is intended to represent the type as a user-facing concept, including the "),a("RouterLink",{attrs:{to:"/html/schemas/schema-kinds.html#Understanding-Cardinality"}},[e._v("cardinality")]),e._v(" of the fields. However, content in parens ("),a("code",[e._v("(")]),e._v(", "),a("code",[e._v(")")]),e._v(") presented next to individual fields is an exception to this rule. This content is field-specific representation parameters. That is, the parameters presented inside these parens would ordinarily belong below in the "),a("code",[e._v("representation")]),e._v(" block because it regards the interaction with the serialized form. It is present next to the fields to primarily avoid the duplication of re-declaring the fields in the "),a("code",[e._v("representaiton")]),e._v(" block.")],1),e._v(" "),a("p",[e._v("Two common field-specific representation parameters for Structs are "),a("code",[e._v("implicit")]),e._v(" and "),a("code",[e._v("rename")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOne "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("nullable")]),e._v(" String "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("rename "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"one"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  fieldTwo Bool "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("rename "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"two"')]),e._v(" implicit "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"false"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("A cleaner declaration that separates type declaration from serialized form representation details might present this as:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('# This is not valid IPLD Schema but is presented to illustrate the additional verbosity being avoided\n\ntype Foo struct {\n  fieldOne nullable String\n  fieldTwo Bool\n} representation map {\n  fields {\n    fieldOne rename "one"\n    fieldTwo rename "two" implicit "false"\n  }\n}\n')])])]),a("p",[e._v("In our example we can see that "),a("code",[e._v("nullable")]),e._v(" is a distinct parameter for the field compared to "),a("code",[e._v("rename")]),e._v(" and "),a("code",[e._v("implicit")]),e._v(". This is because "),a("code",[e._v("nullable")]),e._v(" impacts the shape of the user-facing API for "),a("code",[e._v("Foo")]),e._v(", whereas "),a("code",[e._v("rename")]),e._v(" and "),a("code",[e._v("implicit")]),e._v(" only impact the serialization (representation) of "),a("code",[e._v("Foo")]),e._v(" so are effectively hidden to the user.")]),e._v(" "),a("p",[e._v("See "),a("RouterLink",{attrs:{to:"/html/schemas/schema-kinds.html#Value-Type-Modifiers"}},[e._v("Value Type Modifiers")]),e._v(" for a discussion on such matters as well as the impacts on value cardinality.")],1),e._v(" "),a("p",[e._v("A "),a("code",[e._v("rename")]),e._v(" parameter specifies that at serialization and deserialization, a field has an alternate name than that present in the Schema. An "),a("code",[e._v("implicit")]),e._v(" specifies that, when not present in the serialized form, the field should have a certain value.")]),e._v(" "),a("p",[e._v("Recall our original serialized form for "),a("code",[e._v("Foo")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"fieldOne"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"This is field one of Foo"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"fieldTwo"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("With the "),a("code",[e._v("rename")]),e._v(" and "),a("code",[e._v("implicit")]),e._v(" parameters above, this same data would be serialized as:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"one"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"This is field one of Foo"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("See "),a("RouterLink",{attrs:{to:"/html/schemas/schema-kinds.html#Fields-with-Implicit-Values"}},[e._v("Fields with Implicit Values")]),e._v(" for more information on "),a("code",[e._v("implicit")]),e._v(". In the same document you will also find a discussion regarding combining "),a("code",[e._v("nullable")]),e._v(", "),a("code",[e._v("optional")]),e._v(" and "),a("code",[e._v("implicit")]),e._v(" and the limitations thereof.")],1),e._v(" "),a("p",[e._v("Whenever a value appears in a representation parameter, it must be quoted, regardless of type. In our example above, "),a("code",[e._v('implicit "false"')]),e._v(" quoted a Bool parameter. This will be interpreted appropriately depending on context, in this case it is clear that the type of the quoted value should be a Bool.")]),e._v(" "),a("p",[e._v("Another example of field parameters is the "),a("code",[e._v("int")]),e._v(" representation for Enums, where the field parameter is mandatory:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Status")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("enum")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Nope  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"0"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Yep   "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"1"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Maybe "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"100"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v("\n")])])]),a("p",[e._v("In this case we are mapping Int values at in the serialized form to the three Enum values. Note also that the values are again quoted, but will be interpreted appropriately as integers because the context makes that clear.")]),e._v(" "),a("h2",{attrs:{id:"structs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#structs"}},[e._v("#")]),e._v(" Structs")]),e._v(" "),a("p",[e._v("The basic DSL form of a Struct has the following structure:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type TypeName struct {\n  field1Name Field1Type\n  field2Name Field2Type\n  ... etc.\n}\n")])])]),a("p",[e._v("Where "),a("code",[e._v("TypeName")]),e._v(" is a unique name for the type and follows the naming rules above. Field names follow the same rules as for type naming except that a lower-case first character is allowed and is encouraged as the conventional form. All fields have a type and the type should be one of the existing implicit Schema types ("),a("code",[e._v("Int")]),e._v(", "),a("code",[e._v("String")]),e._v(" etc.) or be present as a named type elsewhere within the document. Field types can be recursive in that they can refer to the parent type, indicating a nested data structure (obviously such a nested data structure must have nullable or optional elements that prevent it from being necessarily infinitely recursive).")]),e._v(" "),a("p",[e._v("Structs must always have a body, enclosed by "),a("code",[e._v("{")]),e._v(", "),a("code",[e._v("}")]),e._v(". Fields must new-line delimited and should be indented for clarity.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("representation")]),e._v(" strategy for Structs is "),a("code",[e._v("map")]),e._v(" by default, so may be omitted. Additional representation strategies See "),a("RouterLink",{attrs:{to:"/html/schemas/representations.html"}},[e._v("Representations of IPLD Schema Kinds")]),e._v(" for more details on these representation strategies.")],1),e._v(" "),a("p",[e._v("Field representation parameters are presented in parens when present and representations requiring additional general parameters is presented in a separate "),a("code",[e._v("representation")]),e._v(" block enclosed by "),a("code",[e._v("{")]),e._v(", "),a("code",[e._v("}")]),e._v(". For example, a Struct with both field representation parameters and general representation parameters:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOne "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("nullable")]),e._v(" String "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("rename "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"one"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  fieldTwo Bool "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("rename "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"two"')]),e._v(" implicit "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"false"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" stringpairs "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  innerDelim "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"="')]),e._v("\n  entryDelim "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('","')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Leading to a serialized form such as:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"one=This is field one of Foo,two=true"')]),e._v("\n")])])]),a("p",[e._v("More details regarding "),a("code",[e._v("stringpairs")]),e._v(" can be found below and in "),a("RouterLink",{attrs:{to:"/html/schemas/representations.html"}},[e._v("Representations of IPLD Schema Kinds")]),e._v(".")],1),e._v(" "),a("p",[e._v("Valid representation strategies for Structs are:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("map")])]),e._v(" "),a("li",[a("code",[e._v("tuple")])]),e._v(" "),a("li",[a("code",[e._v("stringpairs")])]),e._v(" "),a("li",[a("code",[e._v("stringjoin")])]),e._v(" "),a("li",[a("code",[e._v("listpairs")])])]),e._v(" "),a("p",[e._v("More details about these representation strategies, including their various parameters and their representation kinds can be found in "),a("RouterLink",{attrs:{to:"/html/schemas/representations.html"}},[e._v("Representations of IPLD Schema Kinds")]),e._v(".")],1),e._v(" "),a("h2",{attrs:{id:"enums"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#enums"}},[e._v("#")]),e._v(" Enums")]),e._v(" "),a("p",[e._v("Enums are used to indicate a distinct, fixed list of values. Enums in IPLD Schemas have a String representation kind, using the value token as the serialized value by default.")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Status")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("enum")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Nope\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Yep\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Maybe\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Response")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  timestamp Int\n  status Status\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("In this example, where "),a("code",[e._v("Status")]),e._v(" is used, as the "),a("code",[e._v("status")]),e._v(" field in the "),a("code",[e._v("Response")]),e._v(" Struct, we expect to find a String in the serialized form that is one of "),a("code",[e._v('"Nope"')]),e._v(", "),a("code",[e._v('"Yep"')]),e._v(" or "),a("code",[e._v('"Maybe"')]),e._v(". This string value is not presented via an API interacting via this Schema, rather, the special tokens "),a("code",[e._v("Nope")]),e._v(", "),a("code",[e._v("Yep")]),e._v(" and "),a("code",[e._v("Maybe")]),e._v(" may be used instead. Codegen would present these values as distinct types that can be passed to a struct / class implementing "),a("code",[e._v("Response")]),e._v(" when interacting with the "),a("code",[e._v("status")]),e._v(" field.")]),e._v(" "),a("p",[e._v("The serialized strings may be different from values:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Status")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("enum")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Nope "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Nay"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Yep  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Yay"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Maybe\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Creating a differential between the Strings at the Data Model layer and the tokens that an API may use at the Schema layer.")]),e._v(" "),a("p",[e._v("An alternate representation strategy for Enums may be specified: "),a("code",[e._v("int")]),e._v(". With an "),a("code",[e._v("int")]),e._v(" representation strategy, the values are serialized and deserialized as Data Model Ints but the Enum value tokens are presented at the Schema Layer:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Status")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("enum")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Nope  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"0"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Yep   "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"1"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Maybe "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"100"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v("\n")])])]),a("p",[e._v("Note again that the Int values are quoted in the field representation parens, they will be interpreted and validated as integers when parsing as the context of an "),a("code",[e._v("int")]),e._v(" representation strategy makes this clear.")]),e._v(" "),a("p",[e._v("More details about these representation strategies can be found in "),a("RouterLink",{attrs:{to:"/html/schemas/representations.html"}},[e._v("Representations of IPLD Schema Kinds")]),e._v(".")],1),e._v(" "),a("h2",{attrs:{id:"unions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#unions"}},[e._v("#")]),e._v(" Unions")]),e._v(" "),a("h3",{attrs:{id:"introduction-to-unions-kinded-unions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#introduction-to-unions-kinded-unions"}},[e._v("#")]),e._v(" Introduction to Unions: Kinded Unions")]),e._v(" "),a("p",[e._v("IPLD Schema Unions describe various means for nodes that may be one of a number of kinds or forms. Consider a node that contains the following data, perhaps as part of a signalling protocol:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Something bad happened"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"payload"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ERROR"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("And an alternative form that is also acceptable but signals a different state and meaning:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"All good"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"payload"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"percent"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"last"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"61626378797a"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("In this example, we have a Map that can be represented as a Struct since it has only two fields, but the "),a("code",[e._v("payload")]),e._v(" field dosn't have a stable kind so we can't use any of the existing Schema types to represent the field type. Instead, we can introduce a Union and can take different forms depending on the different acceptable forms.")]),e._v(" "),a("p",[e._v("IPLD Schemas are intended to be efficient, so the ability to discriminate on Union types is limited to what we can find "),a("em",[e._v("at the current node")]),e._v(". That is, we can't inspect whether a node has a child that takes a particular form and use that as a discriminator (such as inspecting the keys or values of a Map). A Schema must be able to fail validation at a node being inspected where the data does not match the expected form.")]),e._v(" "),a("p",[e._v("In our example, the discriminator for type found at "),a("code",[e._v("payload")]),e._v(" is the "),a("em",[e._v("kind")]),e._v(" of node present. It is either a String kind of a Map kind. We can make an immediate determination of type based on this piece of information.")]),e._v(" "),a("p",[e._v("Our Schema for this data could be written as:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Message")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  msg String\n  payload Payload\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Payload")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("union")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Error "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("string")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Progress map\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" kinded\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Error")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("string")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Progress")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  percent Float\n  last String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Our "),a("code",[e._v("Payload")]),e._v(' Union can be read as "one of '),a("code",[e._v("Error")]),e._v(" or "),a("code",[e._v("Progress")]),e._v('" and could have additional elements if there are different forms that a '),a("code",[e._v('"payload"')]),e._v(" could take. All Unions require a representation strategy to be stated, there is no default strategy. In this case we are specifying the "),a("code",[e._v("kinded")]),e._v(" strategy, so we are opting to discriminate the type by inspecting the kind present at the data model layer. If we find a String at the data model layer then we can safely assume it is an "),a("code",[e._v("Error")]),e._v(". If we find a Map then we assume it's a "),a("code",[e._v("Progress")]),e._v(" type but we have to proceed to validate it against "),a("code",[e._v("Progress")]),e._v(" and check whether the Map has the required two elements, but at this point the validation job of "),a("code",[e._v("Payload")]),e._v(" is done, it only needs to check for the presence of String or Map.")]),e._v(" "),a("h3",{attrs:{id:"limitations-of-union-discrimination"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#limitations-of-union-discrimination"}},[e._v("#")]),e._v(" Limitations of Union Discrimination")]),e._v(" "),a("p",[e._v("Authoring Unions in IPLD Schemas help expose some of the limitations of quickly validating data that is allowed to vary. If we extend our example and introduce another acceptable form of "),a("code",[e._v('"payload"')]),e._v(" we can see how this ability to quickly discriminate breaks down and introduces the need to do child-contents checking to discriminate:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Ping"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"payload"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"ts"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1572935564043")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"nonce"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"424f524b"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("We've introduced a new message type but lost the ability to discriminate based in kind as our new type is also a Map. A Schema that accommodates for this additional payload type is possible but forces the burden of discrimination and onto the consumer of the data as well as some additional validation burden:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Message")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  msg String\n  payload Payload\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Payload")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("union")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Error "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("string")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" ProgressOrPing map\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" kinded\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Error")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("string")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ProgressOrPing")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  percent "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("optional")]),e._v(" Float\n  last "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("optional")]),e._v(" String\n  ts "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("optional")]),e._v(" Int\n  nonce "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("optional")]),e._v(" String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Now the user of such a Schema must do their own field inspection to determine whether a "),a("code",[e._v("ProgressOrPing")]),e._v(" is a progress message or a ping. Additionally, the burden of ensuring that both "),a("code",[e._v("percent")]),e._v(" and "),a("code",[e._v("last")]),e._v(" are present "),a("em",[e._v("or")]),e._v(" "),a("code",[e._v("ts")]),e._v(" and "),a("code",[e._v("nonce")]),e._v(" are present is left to the user, the Schema layer can't help here. The trade-off present in this scenario regards validation of a node by inspection of its child nodes. This type of data is common in the real world but IPLD Schemas encourage better data shape design to allow for fast validation through clear discrimination where such variance exists.")]),e._v(" "),a("h3",{attrs:{id:"alternative-discrimination-strategies"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#alternative-discrimination-strategies"}},[e._v("#")]),e._v(" Alternative Discrimination Strategies")]),e._v(" "),a("p",[e._v("If we are designing the data layout for our example protocol (rather than consuming something we have no control over the design of), we could choose a alternate strategy that would allow more efficient discrimination. Unions allow for five different representation strategies that allow for different kinds of discrimination.")]),e._v(" "),a("h4",{attrs:{id:"keyed"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keyed"}},[e._v("#")]),e._v(" Keyed")]),e._v(" "),a("p",[e._v("If our generic "),a("code",[e._v('"payload"')]),e._v(" could be replaced with a specific key that discriminates the type of the payload, we could use a "),a("code",[e._v("keyed")]),e._v(" Union:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Something bad happened"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"error"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ERROR"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"All good"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"progress"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"percent"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"last"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"61626378797a"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Ping"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"ping"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"ts"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1572935564043")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"nonce"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"424f524b"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("We can now easily handle this data with the following Schema:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Message")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  msg String\n  payload Payload\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Payload")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("union")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Error "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"error"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Progress "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"progress"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Ping "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ping"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" keyed\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Error")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("string")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Progress")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  percent Float\n  last String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Ping")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  ts Int\n  nonce String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Our "),a("code",[e._v("Payload")]),e._v(" union now has the "),a("code",[e._v("keyed")]),e._v(" representation strategy. This strategy still assumes a Map representation kind at the current node but one that has various keys that are used to discriminate the type present. "),a("code",[e._v("Payload")]),e._v(" now lists quotes string keys next to the types, rather than the kinds of the previous "),a("code",[e._v("kinded")]),e._v(" Union. Validation of such data can now check for the presence of each of these keys, "),a("em",[e._v("exactly one")]),e._v(" of them exists, and then hand off validation to the expected type at the node found in the valud of that key. If an "),a("code",[e._v('"error"')]),e._v(" key is found, it will proceed to validate "),a("code",[e._v("Error")]),e._v(" which assumes that the node is a String. If a "),a("code",[e._v('"progress"')]),e._v(" key is found, it will proceed to validate that it finds a Map at the value node and that it matches the "),a("code",[e._v("Progress")]),e._v(" type, etc.")]),e._v(" "),a("h4",{attrs:{id:"envelope"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#envelope"}},[e._v("#")]),e._v(" Envelope")]),e._v(" "),a("p",[e._v("A strategy similar to "),a("code",[e._v("keyed")]),e._v(", but more explicit and allowing for the retention of the "),a("code",[e._v('"payload"')]),e._v(" node is the "),a("code",[e._v("envelope")]),e._v(" representation strategy. With this strategy we expect that the type will be present as the value of a fixed key of a Map ("),a("code",[e._v('"payload"')]),e._v("), but we can discriminate the type of data to be found by inspecting the value of another key in the Map:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Something bad happened"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"tag"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"error"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"payload"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ERROR"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"All good"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"tag"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"progress"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"payload"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"percent"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"last"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"61626378797a"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Ping"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"tag"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ping"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"payload"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"ts"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1572935564043")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"nonce"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"424f524b"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("This strategy takes us back to the original form of the messages but adds an explicit discriminator to the Map. Our Schema can now take the following form:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Message")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  msg String\n  payload Payload\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Payload")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("union")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Error "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"error"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Progress "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"progress"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Ping "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ping"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" envelope "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  discriminantKey "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"tag"')]),e._v("\n  contentKey "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"payload"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Error")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("string")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Progress")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  percent Float\n  last String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Ping")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  ts Int\n  nonce String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("This "),a("code",[e._v("envelope")]),e._v(" representation strategy requires the parameters "),a("code",[e._v("discriminantKey")]),e._v(" and "),a("code",[e._v("contentKey")]),e._v(". The "),a("code",[e._v("discriminantKey")]),e._v(" tells the Schema the key of the discriminator value, while the discriminator values are listed next to the types of the Union (in this case, the same values as for the "),a("code",[e._v("keyed")]),e._v(" Union).")]),e._v(" "),a("h4",{attrs:{id:"inline"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inline"}},[e._v("#")]),e._v(" Inline")]),e._v(" "),a("p",[e._v("An "),a("code",[e._v("inline")]),e._v(" representation strategy "),a("em",[e._v("pulls up")]),e._v(" nested structures into the current node rather than navigating down to a child nodes to interpret the constituent type as per the previous Union representation strategies. Discrimination between types use a "),a("code",[e._v("discriminantKey")]),e._v(", also in the current node. This necessarily means that the current node must be a map representation kind and constituent types of a Union must also have map representation kinds.")]),e._v(" "),a("p",[e._v("Our example must be extended so that the "),a("code",[e._v("Error")]),e._v(" type can be extracted from a map representation:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Something bad happened"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"tag"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"error"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"message"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ERROR"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"All good"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"tag"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"progress"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"percent"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"last"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"61626378797a"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Ping"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"tag"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ping"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"ts"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1572935564043")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"nonce"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"424f524b"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Message")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  msg String\n  payload Payload\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Payload")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("union")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Error "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"error"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Progress "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"progress"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Ping "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ping"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" inline "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  discriminantKey "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"tag"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Error")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  message String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Progress")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  percent Float\n  last String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Ping")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  ts Int\n  nonce String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("The interface presented by this Schema is adjusted in comparison to the previous Unions as "),a("code",[e._v("Error")]),e._v(" is now a Struct with a "),a("code",[e._v("message")]),e._v(" field.")]),e._v(" "),a("h3",{attrs:{id:"byteprefix-unions-for-bytes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#byteprefix-unions-for-bytes"}},[e._v("#")]),e._v(" Byteprefix Unions for Bytes")]),e._v(" "),a("p",[e._v('A special case union exists for handling Bytes kinds. Where a node contains a byte array (Bytes kind), we may want to discriminate between two different uses of that byte array at the application layer. For example, consider two different encoding schemes where we store a "key" field that is distinct for the each encoding scheme. For practical purposes they are both byte arrays, but at the application layer it helps to have them separated into distinct forms, perhaps so we can make simple assertions about getting the expected key type for the given encoding scheme. There are additional documentation clarity benefits for extracting distinct forms and naming them in a Schema that may factor in to such a decision.')]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Authorization")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  key PublicKey\n  keySize Int\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("PublicKey")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("union")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" RsaPubkey "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Ed25519Pubkey "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" byteprefix\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RsaPubkey")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("bytes")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Ed25519Pubkey")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("bytes")]),e._v("\n")])])]),a("p",[e._v("By declaring a "),a("code",[e._v("byteprefix")]),e._v(" union, we specify that the first byte of the byte array found at the "),a("code",[e._v("key")]),e._v(" node of "),a("code",[e._v("Authorization")]),e._v(" will discriminate which "),a("code",[e._v("type")]),e._v(" the public key is. That first byte will be sliced off and expected to be either "),a("code",[e._v("0x0")]),e._v(" or "),a("code",[e._v("0x1")]),e._v(", then the remainder of the byte array will be extracted and encapsulated inside either "),a("code",[e._v("RsaPubkey")]),e._v(" or "),a("code",[e._v("Ed25519Pubkey")]),e._v(" depending on the discriminator byte.")]),e._v(" "),a("h2",{attrs:{id:"copy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copy"}},[e._v("#")]),e._v(" Copy")]),e._v(" "),a("p",[e._v("The Copy Schema kind is a special case that provides a mechanism for copying the definition of one named type into a new name. It uses the "),a("code",[e._v("=")]),e._v(" token after the new type's name followed by name of the type being copied. It is not possible to copy an unnamed (anonymous) type.")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Ping")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  ts Int\n  nonce String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Pong")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" Ping\n")])])]),a("p",[e._v("This example is strictly equivalent to the following in terms of the interaction above the Schema layer:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Ping")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  ts Int\n  nonce String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Pong")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  ts Int\n  nonce String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("The Schema tooling and the reified form of the Schema retains a "),a("code",[e._v("copy")]),e._v(" kind marker, but tooling that consumes Schemas is expected to treat this marker as an indirection to the named type being copied and copy the entirety of that type's definition to the new name.")]),e._v(" "),a("p",[e._v("The Copy type is provided for convenience and should also prove beneficial in pointing out relationships between types.")]),e._v(" "),a("h2",{attrs:{id:"advanced-data-layouts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#advanced-data-layouts"}},[e._v("#")]),e._v(" Advanced Data Layouts")]),e._v(" "),a("p",[e._v("Advanced Data Layouts (ADL) are a mechanism for breaking out of Schema processing into custom logic where such logic cannot be expressed in Schemas but where connection with Schema kinds may be beneficial.")]),e._v(" "),a("p",[e._v("ADLs are not considered "),a("code",[e._v("type")]),e._v("s in the Schema sense, rather, they masquerade as types, or more specifically, have the ability to masquerade as Schema kinds when used in certain conditions.")]),e._v(" "),a("p",[e._v("Declaration of an ADL is similar to declaring a "),a("code",[e._v("type")]),e._v(" but only requires a name:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("advanced")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ROT13")])]),e._v("\n")])])]),a("p",[e._v("Once declared as an entity in the Schema, the name ("),a("code",[e._v("ROT13")]),e._v(" in this case) may be used as a "),a("em",[e._v("representation")]),e._v(" elsewhere in the Schema. We do this with "),a("code",[e._v("representation advanced")]),e._v(" followed by the name:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MyString")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("string")]),e._v(" representation advanced ROT13\n")])])]),a("p",[e._v("Coupling this "),a("code",[e._v("type")]),e._v(" and the "),a("code",[e._v("advanced")]),e._v(" definition, we are declaring that there exists above the Schema layer some logic labelled "),a("code",[e._v("ROT13")]),e._v(" that is able to interact with the Data Model layer on behalf of "),a("code",[e._v("MyString")]),e._v(" and present a standard String kind interface for such a purpose.")]),e._v(" "),a("p",[e._v("How the ADL logic is wired in to the Schema tooling will be language and tooling specific. For the purpose of Schema authoring, an "),a("code",[e._v("advanced")]),e._v(" definition and usage can be considered as a mechanism to break out of the standard "),a("em",[e._v("Data-model-to-Schema")]),e._v(" processing that is performed, and instead, inserting custom logic in that flow for the particular node in question such that it becomes "),a("em",[e._v("Data-model-to-ADL-to-Schema")]),e._v(".")]),e._v(" "),a("p",[e._v("The interaction with the Data Model is also left up to the ADL, so it is not limited to consuming a particular node. Rather, it can consume any number of nodes (or no nodes!) and even traverse links in an opaque fashion. Another example of an ADL example provides an example of this. In this case, we declare a sharded Map kind which may be used to scale to Maps of very large size and therefore include multiple, independent, blocks:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("advanced")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ShardedMap")])]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MyMap")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" String "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("&")]),e._v("Any "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" representation advanced ShardedMap\n")])])]),a("p",[e._v("In this case, we declare a "),a("code",[e._v("MyMap")]),e._v(" type that is considered a Map kind for the purpose of the rest of the Schema and presents as such above the Schema layer. Meanwhile we have inserted custom logic, labelled "),a("code",[e._v("ShardedMap")]),e._v(", that takes care of the decode/encode and traversal required to present a standard Map kind to the user of such a Schema.")]),e._v(" "),a("p",[a("strong",[a("code",[e._v("representation advanced")]),e._v(" is currently only available for Map, List and Bytes kinds")]),e._v(". Additional use cases (such as the hypothetical String kind above) may be considered in the future.")]),e._v(" "),a("p",[e._v("See "),a("RouterLink",{attrs:{to:"/html/schemas/advanced-layouts.html"}},[e._v("Advanced Layouts for IPLD Schemas")]),e._v(" for more details regarding Advanced Data Layouts.")],1),e._v(" "),a("h2",{attrs:{id:"schemas-in-markdown"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#schemas-in-markdown"}},[e._v("#")]),e._v(" Schemas in Markdown")]),e._v(" "),a("p",[e._v("IPLD Schemas are intended to serve a documentation role as well as a programmatic declarative role. In this documentation role, inline comments ("),a("code",[e._v("#")]),e._v(") can be helpful to expand on declarations with explanations, but expanding this documentation form to embedding IPLD Schemas in consumable Markdown is also possible. When embedded in Markdown in code blocks with the right language marker, IPLD Schema tooling can accept Markdown files and extract only those IPLD Schema portions it finds, substituting for a stand-alone Schema file.")]),e._v(" "),a("p",[e._v("When embedding IPLD Schema declarations in Markdown, use code blocks with the language marker "),a("code",[e._v("ipldsch")]),e._v(", i.e.:")]),e._v(" "),a("pre",{staticClass:"language-markdown"},[a("code",[e._v("\n```ipldsch\ntype Foo struct {\n  a   Int\n  b   Int\n  msg Message\n}\n\ntype Message string\n```\n")])]),e._v(" "),a("p",[e._v("Any such block found in a Markdown document will be extracted and stitched together to form a single Schema document.")]),e._v(" "),a("p",[e._v("Additionally, it is also possible to perform this process across multiple Markdown documents for sufficiently complex Schema declarations. When the IPLD Schema tooling is provided a list of Markdown files it will extract the "),a("code",[e._v("ipldsch")]),e._v(" blocks and stitch them all together and assume they comprise a single stand-alone Schema document.")])])}),[],!1,null,null,null);t.default=n.exports}}]);