(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{355:function(t,e,s){t.exports=s.p+"assets/img/selectors.816ebf8a.jpg"},441:function(t,e,s){"use strict";s.r(e);var n=s(42),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"specification-ipld-selectors"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#specification-ipld-selectors"}},[t._v("#")]),t._v(" Specification: IPLD Selectors")]),t._v(" "),n("p",[n("strong",[t._v("Status: Prescriptive - Draft")])]),t._v(" "),n("h2",{attrs:{id:"introduction"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[t._v("#")]),t._v(" Introduction")]),t._v(" "),n("h3",{attrs:{id:"motivation-what-are-selectors"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#motivation-what-are-selectors"}},[t._v("#")]),t._v(" Motivation - what are Selectors?")]),t._v(" "),n("p",[n("em",[t._v("Prerequisites: "),n("a",{attrs:{href:"https://github.com/ipld/ipld",target:"_blank",rel:"noopener noreferrer"}},[t._v("IPLD"),n("OutboundLink")],1),t._v(", IPLD data model, "),n("a",{attrs:{href:"https://github.com/ipld/cid",target:"_blank",rel:"noopener noreferrer"}},[t._v("CID"),n("OutboundLink")],1),t._v(".")])]),t._v(" "),n("p",[t._v('IPLD Selectors are expressions that identify ("select") a subset of nodes in an IPLD dag.')]),t._v(" "),n("p",[t._v("This is a useful primitive to use along with: (a) systems that require distributing or pinning dags (IPFS, Filecoin, bitswap, graphsync, ipfs-cluster), (b) applications that require fetching subsets of data in specific orders or at specific times (video players, dataset viewers, file systems), (c) programs that transform graphs into other graphs (data transformations, ETL, etc). In short, it is a fundamental primitive required by most systems and applications in the IPLD and IPFS ecosystems, as important as "),n("a",{attrs:{href:"https://github.com/multiformats/multihash",target:"_blank",rel:"noopener noreferrer"}},[t._v("multihash"),n("OutboundLink")],1),t._v(", "),n("a",{attrs:{href:"https://github.com/ipld/cid",target:"_blank",rel:"noopener noreferrer"}},[t._v("CIDs"),n("OutboundLink")],1),t._v(", "),n("a",{attrs:{href:"https://github.com/ipld/",target:"_blank",rel:"noopener noreferrer"}},[t._v("IPLD Formats"),n("OutboundLink")],1),t._v(", and more.")]),t._v(" "),n("p",[n("img",{attrs:{src:s(355),alt:""}})]),t._v(" "),n("p",[t._v("(Note: syntaxes in the image are for quick understanding, but are not literal selector syntaxes (yet; we have an extension pathway).)")]),t._v(" "),n("h2",{attrs:{id:"specification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[t._v("#")]),t._v(" Specification")]),t._v(" "),n("p",[t._v('Selectors are defined by an "AST" (Abstract Syntax Tree) which is itself\nspecified in IPLD, and uses IPLD Schemas for clarity.')]),t._v(" "),n("p",[t._v('Implementations of Selectors read this "AST" and evaluate its instructions to\ntraverse a graph, and select nodes in it.')]),t._v(" "),n("h3",{attrs:{id:"schema"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#schema"}},[t._v("#")]),t._v(" Schema")]),t._v(" "),n("p",[t._v("This code block describes Selectors using "),n("RouterLink",{attrs:{to:"/schemas/"}},[t._v("IPLD Schemas")]),t._v(" syntax.")],1),t._v(" "),n("p",[t._v("Descriptions of how each node should be evaluated can be found in comments\ninline in the schema.")]),t._v(" "),n("div",{staticClass:"language-ipldsch extra-class"},[n("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## SelectorEnvelope is the recommended top-level value for serialized messages")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## that don't have established existing context with marks the start of a selector:")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## it\'s a single-member union used to kick us towards "nominative typing".')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## See https://github.com/ipld/specs/tree/master/schemas/migration.md")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## for a background on the theory behind this gentle-nominative concept.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SelectorEnvelope")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Selector "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"selector"')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Selector")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Matcher "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"."')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" ExploreAll "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"a"')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" ExploreFields "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"f"')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" ExploreIndex "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"i"')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" ExploreRange "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"r"')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" ExploreRecursive "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"R"')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" ExploreUnion "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"|"')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" ExploreConditional "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"&"')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" ExploreRecursiveEdge "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"@"')]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# sentinel value; only valid in some positions.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ExploreAll is similar to a `*` -- it traverses all elements of an array,")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## or all entries in a map, and applies a next selector to the reached nodes.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ExploreAll")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tnext Selector "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rename "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('">"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ExploreFields traverses named fields in a map (or equivalently, struct, if")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## traversing on typed/schema nodes) and applies a next selector to the")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## reached nodes.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## Note that a concept of exploring a whole path (e.g. "foo/bar/baz") can be')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## represented as a set of three nexted ExploreFields selectors, each")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## specifying one field.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ExploreFields")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tfields "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("String"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("Selector"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rename "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"f>"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ExploreIndex traverses a specific index in a list, and applies a next")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## selector to the reached node.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ExploreIndex")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tindex Int "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rename "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"i"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tnext Selector "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rename "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('">"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ExploreRange traverses a list, and for each element in the range specified,")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## will apply a next selector to those reached nodes.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ExploreRange")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tstart Int "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rename "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"^"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tend Int "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rename "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"$"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tnext Selector "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rename "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('">"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ExploreRecursive traverses some structure recursively.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## To guide this exploration, it uses a "sequence", which is another Selector')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## tree; some leaf node in this sequence should contain an ExploreRecursiveEdge")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## selector, which denotes the place recursion should occur.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## In implementation, whenever evaluation reaches an ExploreRecursiveEdge marker")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## in the recursion sequence's Selector tree, the implementation logically")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## produces another new Selector which is a copy of the original")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ExploreRecursive selector, but with a decremented depth parameter for limit")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## (if limit is of type depth), and continues evaluation thusly.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## It is not valid for an ExploreRecursive selector's sequence to contain")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## no instances of ExploreRecursiveEdge; it *is* valid for it to contain")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## more than one ExploreRecursiveEdge.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ExploreRecursive can contain a nested ExploreRecursive!")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## This is comparable to a nested for-loop.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## In these cases, any ExploreRecursiveEdge instance always refers to the")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## nearest parent ExploreRecursive (in other words, ExploreRecursiveEdge can")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## be thought of like the 'continue' statement, or end of a for-loop body;")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## it is *not* a 'goto' statement).")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Be careful when using ExploreRecursive with a large depth limit parameter;")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## it can easily cause very large traversals (especially if used in combination")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## with selectors like ExploreAll inside the sequence).")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## limit is a union type -- it can have an integer depth value (key "depth") or')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## no value (key "none"). If limit has no value it is up to the ')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## implementation library using selectors to identify an appropriate max depth")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## as neccesary so that recursion is not infinite")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ExploreRecursive")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tsequence Selector "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rename "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('":>"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tlimit RecursionLimit "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rename "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"l"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tstopAt "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" Condition "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rename "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"!"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# if a node matches, we won't match it nor explore its children.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RecursionLimit")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" RecursionLimit_None "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"none"')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" RecursionLimit_Depth "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"depth"')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RecursionLimit_None")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RecursionLimit_Depth")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ExploreRecursiveEdge is a special sentinel value which is used to mark")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## the end of a sequence started by an ExploreRecursive selector: the recursion")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## goes back to the initial state of the earlier ExploreRecursive selector,")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## and proceeds again (with a decremented maxDepth value).")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## An ExploreRecursive selector that doesn't contain an ExploreRecursiveEdge")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## is nonsensical.  Containing more than one ExploreRecursiveEdge is valid.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## An ExploreRecursiveEdge without an enclosing ExploreRecursive is an error.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ExploreRecursiveEdge")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ExploreUnion allows selection to continue with two or more distinct selectors")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## while exploring the same tree of data.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ExploreUnion can be used to apply a Matcher on one node (causing it to")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## be considered part of a (possibly labelled) result set), while simultaneously")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## continuing to explore deeper parts of the tree with another selector,")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## for example.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ExploreUnion")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("Selector"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Note that ExploreConditional versus a Matcher with a Condition are distinct:")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ExploreConditional progresses deeper into a tree;")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## whereas a Matcher with a Condition may look deeper to make its decision,")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## but returns a match for the node it's on rather any of the deeper values.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ExploreConditional")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tcondition Condition "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rename "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"&"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\tnext Selector "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("rename "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('">"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## Matcher marks a node to be included in the "result" set.')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## (All nodes traversed by a selector are in the "covered" set (which is a.k.a.')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## "the merkle proof"); the "result" set is a subset of the "covered" set.)')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## In libraries using selectors, the "result" set is typically provided to')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## some user-specified callback.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## A selector tree with only "explore*"-type selectors and no Matcher selectors')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## is valid; it will just generate a "covered" set of nodes and no "result" set.')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Matcher")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tonlyIf "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" Condition "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# match is true based on position alone if this is not set.")]),t._v("\n\tlabel "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" String "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# labels can be used to match multiple different structures in one selection.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Condition is expresses a predicate with a boolean result.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Condition clauses are used several places:")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##   - in Matcher, to determine if a node is selected.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##   - in ExploreRecursive, to halt exploration.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##   - in ExploreConditional,")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TODO -- Condition is very skeletal and incomplete.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## The place where Condition appears in other structs is correct;")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## the rest of the details inside it are not final nor even completely drafted.")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token typedef"}},[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Condition")])]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# We can come back to this and expand it later...")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# TODO: figure out how to make this recurse correctly, so I can say "hasField{hasField{or{hasValue{1}, hasValue{2}}}}".')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Condition_HasField "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hasField"')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Condition_HasValue "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"="')]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# will need to contain a kinded union, lol.  these conditions are gonna get deep.)")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Condition_HasKind "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%"')]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# will ideally want to refer to the DataModel ReprKind enum...!  will we replicate that here?  don't want to block on cross-schema references, but it's interesting that we've finally found a good example wanting it.")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Condition_IsLink "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/"')]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# will need this so we can use it in recursions to say "stop at CID QmFoo".')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Condition_GreaterThan "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"greaterThan"')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Condition_LessThan "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"lessThan"')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Condition_And "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"and"')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Condition_Or "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"or"')]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# REVIEW: since we introduced "and" and "or" here, we\'re getting into dangertown again.  we\'ll need a "max conditionals limit" (a la \'gas\' of some kind) near here.')]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n")])])]),n("h2",{attrs:{id:"known-issues"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#known-issues"}},[t._v("#")]),t._v(" Known issues")]),t._v(" "),n("ul",[n("li",[t._v('Note that the status of this document is "Draft"!')]),t._v(" "),n("li",[t._v('The "Condition" system is not fully specified -- it is a placeholder awaiting further design.')])]),t._v(" "),n("h2",{attrs:{id:"other-related-work"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#other-related-work"}},[t._v("#")]),t._v(" Other related work")]),t._v(" "),n("h3",{attrs:{id:"implementations"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#implementations"}},[t._v("#")]),t._v(" Implementations")]),t._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://github.com/ipld/go-ipld-prime/tree/master/traversal/selector",target:"_blank",rel:"noopener noreferrer"}},[t._v("Selectors package in go-ipld-prime"),n("OutboundLink")],1),t._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://godoc.org/github.com/ipld/go-ipld-prime/traversal#Traverse",target:"_blank",rel:"noopener noreferrer"}},[t._v("Traversal func which uses Selectors"),n("OutboundLink")],1)]),t._v(" "),n("li",[t._v("note that these are still skeletal PoC implementations and not yet feature-complete")])])])]),t._v(" "),n("h3",{attrs:{id:"design-history"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#design-history"}},[t._v("#")]),t._v(" Design History")]),t._v(" "),n("ul",[n("li",[t._v("See "),n("RouterLink",{attrs:{to:"/design/history/exploration-reports/2018.10-selectors-design-goals.html"}},[t._v("Selector Design Goals")]),t._v(" (2018).")],1)])])}),[],!1,null,null,null);e.default=a.exports}}]);