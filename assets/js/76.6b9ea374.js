(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{433:function(e,t,a){"use strict";a.r(t);var s=a(42),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"representations-of-ipld-schema-kinds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#representations-of-ipld-schema-kinds"}},[e._v("#")]),e._v(" Representations of IPLD Schema Kinds")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#available-representation-strategies"}},[e._v("Available Representation Strategies")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#representation-strategy-reference"}},[e._v("Representation Strategy Reference")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"#struct-map-representation"}},[e._v("Struct "),a("code",[e._v("map")]),e._v(" Representation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#struct-tuple-representation"}},[e._v("Struct "),a("code",[e._v("tuple")]),e._v(" Representation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#struct-stringpairs-representation"}},[e._v("Struct "),a("code",[e._v("stringpairs")]),e._v(" Representation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#struct-stringjoin-representation"}},[e._v("Struct "),a("code",[e._v("stringjoin")]),e._v(" Representation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#struct-listpairs-representation"}},[e._v("Struct "),a("code",[e._v("listpairs")]),e._v(" Representation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#map-map-representation"}},[e._v("Map "),a("code",[e._v("map")]),e._v(" Representation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#map-stringpairs-representation"}},[e._v("Map "),a("code",[e._v("stringpairs")]),e._v(" Representation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#map-listpairs-representation"}},[e._v("Map "),a("code",[e._v("listpairs")]),e._v(" Representation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#union-keyed-representation"}},[e._v("Union "),a("code",[e._v("keyed")]),e._v(" Representation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#union-kinded-representation"}},[e._v("Union "),a("code",[e._v("kinded")]),e._v(" Representation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#union-envelope-representation"}},[e._v("Union "),a("code",[e._v("envelope")]),e._v(" Representation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#union-inline-representation"}},[e._v("Union "),a("code",[e._v("inline")]),e._v(" Representation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#union-byteprefix-representation"}},[e._v("Union "),a("code",[e._v("byteprefix")]),e._v(" Representation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#enum-string-representation"}},[e._v("Enum "),a("code",[e._v("string")]),e._v(" Representation")])]),e._v(" "),a("li",[a("a",{attrs:{href:"#enum-int-representation"}},[e._v("Enum "),a("code",[e._v("int")]),e._v(" Representation")])])])])]),e._v(" "),a("p",[e._v('A type at the Schema layer must be mapped onto a representation expressible within the Data Model. Each Schema type, therefore, has a "representation kind" which dictates what Data Model kind it is represented as. Each Schema type has a "representation strategy" for converting it, where required, into a "representation kind".')]),e._v(" "),a("p",[e._v("For all Schema kinds which have direct equivalents in the Data Model (e.g. Int, String, Float), that kind is also the representation kind and there is a default representation strategy (mostly implicitly) named after that kind, i.e. a String schema kind has a String representation kind and also a "),a("code",[e._v("string")]),e._v(" representation strategy that is a direct transferrence through the Data Model. The default representation is, broadly speaking, a no-op: a string remains a string, and a map is easy to enough to represent as a map!")]),e._v(" "),a("p",[e._v("The Schema layer introduces additional kinds (see "),a("RouterLink",{attrs:{to:"/html/schemas/schema-kinds.html"}},[e._v("IPLD Schema Kinds")]),e._v(') that can be thought of as "perceived kinds", in that they have no direct equivalent in the Data Model but can be represented there and perceived as something different when passing through the Schema layer. Most also have default mappings.')],1),e._v(" "),a("p",[e._v("For example, A Struct maps directly to a Data Model Map, where the Struct's fields are Map keys and the Struct's field's values are the values found at the values of the Map's keys:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  x   Int\n  y   Int\n  msg String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("May be deserialized from a JSON map:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"x"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("10005510")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"y"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("-21183")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"A treasure chest is found at this location"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("By default, Enums map to String kinds where no other strategy is declared. Unions are a special case as there's no single widely agreed upon transcription pattern for unions (from before the establishment of IPLD), so these require\nan explicit choice.")]),e._v(" "),a("p",[e._v("Maps, Structs, Enums and Unions all have more than one possible representation strategy.")]),e._v(" "),a("p",[e._v("The default representation strategy for Maps, Struct and Enums is implicit and need not be stated, but we could rewrite our example above to be explicit:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  x   Int\n  y   Int\n  msg String\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" map\n")])])]),a("p",[e._v("Representation strategies are identified by one primary keyword, which indicates what kind in the Data Model will be transcribed to. Some representation strategies have additional parameters, some optional and some mandatory. Such parameters, where they apply to the type as a whole, may be located inside a separate block ("),a("code",[e._v("{")]),e._v(", "),a("code",[e._v("}")]),e._v(") following the declaration of the representation strategy. Where those parameters impact specific fields of a type, they are presented inline with the field in parens ("),a("code",[e._v("(")]),e._v(", "),a("code",[e._v(")")]),e._v(") to indicate that they do not directly impact the user-facing form of the type but rather the serialized form.")]),e._v(" "),a("p",[e._v("For example, a type declaration laden with representation parameters:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  x Int "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("rename "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"a"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  y Int "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("rename "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"b"')]),e._v(" implicit "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"0"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  msg String\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" stringpairs "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  innerDelim "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"="')]),e._v("\n  entryDelim "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('","')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("h2",{attrs:{id:"available-representation-strategies"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#available-representation-strategies"}},[e._v("#")]),e._v(" Available Representation Strategies")]),e._v(" "),a("p",[e._v("Schema kinds for which no meaningful customization is possible: Null, Boolean, Integer, Float, String, Bytes, List and Link are not included in this list. Custom custom representation strategies for these kinds has not been ruled out and may be introduced in the future.")]),e._v(" "),a("p",[e._v("Discussion of Advanced Data Layouts and their ability to override the representation strategy of various type can be found in "),a("RouterLink",{attrs:{to:"/html/schemas/advanced-layouts.html"}},[e._v("Advanced Layouts for IPLD Schemas")]),e._v(".")],1),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Map")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("map")]),e._v(": "),a("em",[e._v("(default)")]),e._v(" transcribes to "),a("em",[e._v("Map")]),e._v(" in the Data Model.")]),e._v(" "),a("li",[a("code",[e._v("stringpairs")]),e._v(": transcribes to "),a("em",[e._v("String")]),e._v(" in the Data Model.")]),e._v(" "),a("li",[a("code",[e._v("listpairs")]),e._v(": transcribes to "),a("em",[e._v("List")]),e._v(" (of Lists) in the Data Model.")])])]),e._v(" "),a("li",[a("strong",[e._v("Union")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("keyed")]),e._v(": transcribes to a single-entry "),a("em",[e._v("Map")]),e._v(" in the Data Model.")]),e._v(" "),a("li",[a("code",[e._v("kinded")]),e._v(": transcribes to varying kinds in the Data Model, see below for details.")]),e._v(" "),a("li",[a("code",[e._v("envelope")]),e._v(": transcribes to a dual-entry "),a("em",[e._v("Map")]),e._v(" in the Data Model.")]),e._v(" "),a("li",[a("code",[e._v("inline")]),e._v(": transcribes to a "),a("em",[e._v("Map")]),e._v(" in the Data Model (and has additional limitations).")]),e._v(" "),a("li",[a("code",[e._v("byteprefix")]),e._v(": transcribes to "),a("em",[e._v("Bytes")]),e._v(" in the Data Model, only usable for unions of Bytes.")])])]),e._v(" "),a("li",[a("strong",[e._v("Struct")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("map")]),e._v(": "),a("em",[e._v("(default)")]),e._v(" transcribes to "),a("em",[e._v("Map")]),e._v(" in the Data Model.")]),e._v(" "),a("li",[a("code",[e._v("tuple")]),e._v(": transcribes to "),a("em",[e._v("List")]),e._v(" in the Data Model.")]),e._v(" "),a("li",[a("code",[e._v("stringpairs")]),e._v(": transcribes to "),a("em",[e._v("String")]),e._v(" in the Data Model.")]),e._v(" "),a("li",[a("code",[e._v("stringjoin")]),e._v(": transcribes to "),a("em",[e._v("String")]),e._v(" in the Data Model.")]),e._v(" "),a("li",[a("code",[e._v("listpairs")]),e._v(": transcribes to "),a("em",[e._v("List")]),e._v(" (of Lists) in the Data Model.")])])]),e._v(" "),a("li",[a("strong",[e._v("Enum")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("string")]),e._v(": "),a("em",[e._v("(default)")]),e._v(" transcribes the enum values as "),a("em",[e._v("String")]),e._v(" in the Data Model.")]),e._v(" "),a("li",[a("code",[e._v("int")]),e._v(": transcribes the enum values as "),a("em",[e._v("Int")]),e._v(" in the Data Model.")])])])]),e._v(" "),a("p",[e._v("Each of these representation strategies will be explored in detail in below.")]),e._v(" "),a("h2",{attrs:{id:"representation-strategy-reference"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#representation-strategy-reference"}},[e._v("#")]),e._v(" Representation Strategy Reference")]),e._v(" "),a("h3",{attrs:{id:"struct-map-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#struct-map-representation"}},[e._v("#")]),e._v(" Struct "),a("code",[e._v("map")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: Map")])]),e._v(" "),a("p",[e._v("A Data Model Map representation of Structs means that the Struct is represented as a Map, where the keys are the names of the Struct fields. This is a common and natural way to represent Structs and is therefore their default representation. As the default, this strategy is inferred in absence of any other.")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOne String\n  fieldTwo Bool\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" map\n")])])]),a("p",[e._v("In this case, "),a("code",[e._v("representation map")]),e._v(" could have been elided.")]),e._v(" "),a("p",[e._v("Some data matching the "),a("code",[e._v("Foo")]),e._v(" Struct (shown as JSON) is:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"fieldOne"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"this is field one"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"fieldTwo"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("The "),a("code",[e._v("map")]),e._v(" Struct representation strategy also allows for field-specific parameters which may be specified after the fields in the main declaration. The two parameters are:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("rename")]),e._v(" to declare that at serialization and deserialization, this field has an alternate name in the underlying Data Model Map. This may be useful for providing verbose names at the Schema layer but compact names in the encoding, for example.")]),e._v(" "),a("li",[a("code",[e._v("implicit")]),e._v(" to declare that a particular value of this field is assumed if the field is omitted from serialized form. This applies to both serialization and deserialization. A common example may be "),a("code",[e._v('implicit "false"')]),e._v(" so that a Bool field need only be present in the serialized form when it is "),a("code",[e._v("true")]),e._v(".")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOne String "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("rename "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"one"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  fieldTwo Bool "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("rename "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"two"')]),e._v(" implicit "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"false"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" map\n")])])]),a("p",[e._v("The field-specific parameters ("),a("code",[e._v("rename")]),e._v(" and "),a("code",[e._v("implicit")]),e._v(") are only available for the "),a("code",[e._v("map")]),e._v(" Struct representation strategy. They are technically possible in some other forms (i.e. "),a("code",[e._v("listpairs")]),e._v(" and "),a("code",[e._v("stringpairs")]),e._v(") and support may be extended in the future.")]),e._v(" "),a("p",[e._v("See "),a("RouterLink",{attrs:{to:"/html/schemas/schema-kinds.html#Value-Type-Modifiers"}},[e._v("Value Type Modifiers")]),e._v(" for a discussion on such matters as well as the impacts on value cardinality.")],1),e._v(" "),a("h3",{attrs:{id:"struct-tuple-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#struct-tuple-representation"}},[e._v("#")]),e._v(" Struct "),a("code",[e._v("tuple")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: List")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("tuple")]),e._v(" Struct representation strategy allows Structs to be packed into a compact List representation. This List representation drops the Struct field's names from the representation entirely and relies entirely on the order of elements to denote meaning. As such, it is generally a very compact way to represent data.")]),e._v(" "),a("p",[a("code",[e._v("tuple")]),e._v(' Struct representation strategies should be used cautiously. Since they contain little in the way of "self-describing" information, '),a("code",[e._v("tuple")]),e._v(" Struct representations can make for very fragile protocols, increase the difficulty of migrations, and make serialized data incomprehensible without the schema information in hand.")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOne String\n  fieldTwo Bool\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" tuple\n")])])]),a("p",[e._v("Some data matching the "),a("code",[e._v("Foo")]),e._v(" Struct (shown as JSON) is:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"this is field one"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),a("p",[e._v("Notice how this is the same data as in the "),a("code",[e._v("map")]),e._v(" Struct representation strategy example above; it's just much more compact than it was in the map representation (and beware: correspondingly less self-describing!).")]),e._v(" "),a("p",[e._v("Optional or implicit fields are not possible with the "),a("code",[e._v("tuple")]),e._v(" Struct representation strategy, all elements must be present.")]),e._v(" "),a("p",[e._v("No field-specific parameters are available for the "),a("code",[e._v("tuple")]),e._v(" Struct representation strategy (i.e. "),a("code",[e._v("implicit")]),e._v(" and "),a("code",[e._v("rename")]),e._v(" which are available for "),a("code",[e._v("map")]),e._v("). One general parameter is available:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("fieldOrder")]),e._v(" declares that the fields are serialized in a particular order that may be different from the order presented in the type descriptor. This option is implicitly set to the declared order but may be overridden where needed.")])]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOne String\n  fieldTwo Bool\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" tuple "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOrder "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"fieldTwo"')]),e._v(", "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"fieldOne"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Serialization of such a type in JSON may appear as:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"this is field one"')]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),a("h3",{attrs:{id:"struct-stringpairs-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#struct-stringpairs-representation"}},[e._v("#")]),e._v(" Struct "),a("code",[e._v("stringpairs")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: String")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("stringpairs")]),e._v(" Struct representation strategy encodes a Struct to a single String. It should be used with special caution as there are no escaping mechanisms in place to prevent incompatible data from disrupting the encoding and causing errors during decode operations.")]),e._v(" "),a("p",[e._v("The encoding presents key / value pairs as a delimited String. e.g. "),a("code",[e._v('"k1=v1,k2=v2"')]),e._v(" rather than "),a("code",[e._v('{ "k1": "v1", "k2": "v2" }')]),e._v(" if the same data used a "),a("code",[e._v("map")]),e._v(" Struct representation strategy. The entry delimiter and the key / value (inner) delimiter must be specified as general parameters when "),a("code",[e._v("stringpairs")]),e._v(" is used, there is no default for these. In our example, the "),a("code",[e._v("entryDelim")]),e._v(" would be "),a("code",[e._v('","')]),e._v(" while the "),a("code",[e._v("innerDelim")]),e._v(" would be "),a("code",[e._v('"="')]),e._v(".")]),e._v(" "),a("p",[e._v("This serial representation is strictly limited: the domain of available for field names must exclude the "),a("code",[e._v("innerDelim")]),e._v(" in any position and values and keys must exclude the "),a("code",[e._v("entryDelim")]),e._v(" in any position. There is no facility for escaping, such as in escaped CSV. This also leads to a further restriction that this representation is only valid for Structs whose values may all be encoded to String kind in the Data Model layer. It is recommended, therefore, that its use be limited to Structs containing values with the basic data model kinds that exclude multiple values, i.e. no Maps, Lists, and therefore Structs or Unions or any other type that has a recursive representation kind.")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOne String\n  fieldTwo Bool\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" stringpairs "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  innerDelim "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"="')]),e._v("\n  entryDelim "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('","')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Some data matching the "),a("code",[e._v("Foo")]),e._v(" Struct (shown as JSON) is:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"fieldOne=this is field one,fieldTwo=true"')]),e._v("\n")])])]),a("p",[e._v("No field-specific parameters are available for the "),a("code",[e._v("stringpairs")]),e._v(" Struct representation strategy (i.e. "),a("code",[e._v("implicit")]),e._v(" and "),a("code",[e._v("rename")]),e._v(" which are available for "),a("code",[e._v("map")]),e._v("). The two general parameters are mandatory:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("innerDelim")]),e._v(" declares a quoted string that is used to delimit a key from a value")]),e._v(" "),a("li",[a("code",[e._v("entryDelim")]),e._v(" declares a quoted string that is used to delimit entries from each other")])]),e._v(" "),a("h3",{attrs:{id:"struct-stringjoin-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#struct-stringjoin-representation"}},[e._v("#")]),e._v(" Struct "),a("code",[e._v("stringjoin")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: String")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("stringjoin")]),e._v(" Struct representation strategy encodes a Struct to a single String. It should be used with special caution as there are no escaping mechanisms in place to prevent incompatible data from disrupting the encoding and causing errors during decode operations.")]),e._v(" "),a("p",[a("code",[e._v("stringjoin")]),e._v(" is very similar to "),a("code",[e._v("stringpairs")]),e._v(" and caries many of the same notes of caution. The difference is that "),a("code",[e._v("stringjoin")]),e._v(" omits the keys and relies instead on declared field order to assume the location of the field values, similar to the "),a("code",[e._v("tuple")]),e._v(" representation.")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Fizzlebop")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  a String\n  b String\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" stringjoin "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  join "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('":"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Some data matching the "),a("code",[e._v("Fizzlebop")]),e._v(" Struct (shown as JSON) is:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"value-of-a:value-of-b"')]),e._v("\n")])])]),a("p",[e._v("Since there is no escaping mechanism, no value can contain the string used for "),a("code",[e._v("join")]),e._v(" as this would disrupt decoding and result in an error. Additionally, optional or implicit fields are not possible with the "),a("code",[e._v("stringjoin")]),e._v(" Struct representation strategy, all elements must be present.")]),e._v(" "),a("p",[e._v("No field-specific parameters are available for the "),a("code",[e._v("stringjoin")]),e._v(" Struct representation strategy (i.e. "),a("code",[e._v("implicit")]),e._v(" and "),a("code",[e._v("rename")]),e._v(" which are available for "),a("code",[e._v("map")]),e._v("). The single general parameter is mandatory:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("join")]),e._v(" declares a quoted string that is used to delimit field values")])]),e._v(" "),a("h3",{attrs:{id:"struct-listpairs-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#struct-listpairs-representation"}},[e._v("#")]),e._v(" Struct "),a("code",[e._v("listpairs")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: List")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("listpairs")]),e._v(" Struct representation strategy encodes a Struct to a List of Lists at the Data Model layer. Similar to the "),a("code",[e._v("tuple")]),e._v(" representation but the keys are also included in the encoding so the serialized form is not as opaque and more self-describing than "),a("code",[e._v("tuple")]),e._v(".")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  fieldOne String\n  fieldTwo Bool\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" listpairs\n")])])]),a("p",[e._v("Some data matching the "),a("code",[e._v("Foo")]),e._v(" Struct (shown as JSON) is:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"fieldOne"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"this is field one"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"fieldTwo"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),a("p",[e._v("Each entry of the parent List is a List containing exactly two entries, where the first is the exact field name and the second is the value.")]),e._v(" "),a("p",[e._v("No field-specific parameters are available for the "),a("code",[e._v("listpairs")]),e._v(" Struct representation strategy (i.e. "),a("code",[e._v("implicit")]),e._v(" and "),a("code",[e._v("rename")]),e._v(" which are available for "),a("code",[e._v("map")]),e._v(").")]),e._v(" "),a("h3",{attrs:{id:"map-map-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map-map-representation"}},[e._v("#")]),e._v(" Map "),a("code",[e._v("map")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: Map")])]),e._v(" "),a("p",[e._v("Schema Maps are represented as Data Model Maps by default. Schema Maps differ from Data Model Maps in that their value types are constrained.")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("FloatMap")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("Float"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Some data matching the "),a("code",[e._v("FloatMap")]),e._v(" Map (shown as JSON) is:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"x"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.812411")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"y"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.15")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"z"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.0")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("No parameters are available for the "),a("code",[e._v("map")]),e._v(" Map representation strategy.")]),e._v(" "),a("h3",{attrs:{id:"map-stringpairs-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map-stringpairs-representation"}},[e._v("#")]),e._v(" Map "),a("code",[e._v("stringpairs")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: String")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("stringpairs")]),e._v(" Map representation strategy is roughly the same the "),a("code",[e._v("stringpairs")]),e._v(" for Structs. It encodes a Map to a single String. It should be used with special caution as there are no escaping mechanisms in place to prevent incompatible data from disrupting the encoding and causing errors during decode operations.")]),e._v(" "),a("p",[e._v("The encoding presents key / value pairs as a delimited String. e.g. "),a("code",[e._v('"k1=v1,k2=v2"')]),e._v(" rather than "),a("code",[e._v('{ "k1": "v1", "k2": "v2" }')]),e._v(" if the same data used a "),a("code",[e._v("map")]),e._v(" Map representation strategy. The entry delimiter and the key / value (inner) delimiter must be specified as general parameters when "),a("code",[e._v("stringpairs")]),e._v(" is used, there is no default for these. In our example, the "),a("code",[e._v("entryDelim")]),e._v(" would be "),a("code",[e._v('","')]),e._v(" while the "),a("code",[e._v("innerDelim")]),e._v(" would be "),a("code",[e._v('"="')]),e._v(".")]),e._v(" "),a("p",[e._v("This serial representation is strictly limited: the domain of available for keys must exclude the "),a("code",[e._v("innerDelim")]),e._v(" in any position and values and keys must exclude the "),a("code",[e._v("entryDelim")]),e._v(" in any position. There is no facility for escaping, such as in escaped CSV. This also leads to a further restriction that this representation is only valid for Maps whose values may all be encoded to String kind in the Data Model layer. It is recommended, therefore, that its use be limited to Maps containing values with the basic data model kinds that exclude multiple values, i.e. no Maps, Lists, and therefore Structs or Unions or any other type that has a recursive representation kind.")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("p",[e._v("A string that is similar in format to the options found in an /etc/fstab file might be defined as:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MountOptions")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" representation stringpairs "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  innerDelim "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"="')]),e._v("\n  entryDelim "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('","')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Some data matching the "),a("code",[e._v("MountOptions")]),e._v(" Struct (shown as JSON) is:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"keys=values,serialized=thusly"')]),e._v("\n")])])]),a("p",[e._v("The two general parameters for the "),a("code",[e._v("stringpairs")]),e._v(" Map representation strategy are mandatory:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("innerDelim")]),e._v(" declares a quoted string that is used to delimit a key from a value")]),e._v(" "),a("li",[a("code",[e._v("entryDelim")]),e._v(" declares a quoted string that is used to delimit entries from each other")])]),e._v(" "),a("h3",{attrs:{id:"map-listpairs-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#map-listpairs-representation"}},[e._v("#")]),e._v(" Map "),a("code",[e._v("listpairs")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: List")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("listpairs")]),e._v(" Map representation strategy is roughly the same the "),a("code",[e._v("listpairs")]),e._v(" for Structs. It encodes a Map to a List of Lists at the Data Model layer.")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("FloatMap")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("Float"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" representation listpairs\n")])])]),a("p",[e._v("Some data matching the "),a("code",[e._v("FloatMap")]),e._v(" Map (shown as JSON) is:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"x"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.812411")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"y"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.15")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"z"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])]),a("p",[e._v("Each entry of the parent List is a List containing exactly two entries, where the first is the key String and the second is the value.")]),e._v(" "),a("p",[e._v("No parameters are available for the "),a("code",[e._v("listpairs")]),e._v(" Map representation strategy.")]),e._v(" "),a("h3",{attrs:{id:"union-keyed-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#union-keyed-representation"}},[e._v("#")]),e._v(" Union "),a("code",[e._v("keyed")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: Map")]),e._v(" (single entry of current node)")]),e._v(" "),a("p",[e._v("A Union using a "),a("code",[e._v("keyed")]),e._v(" representation strategy determines which of the types in the Union is present by looking at the keys in the Map at the current node. Exactly one of the keys listed in the Union must be present at any such Union node for it to be valid.")]),e._v(" "),a("p",[e._v("When using a "),a("code",[e._v("keyed")]),e._v(" Union representation strategy, the Union lists the quoted keys after each constituent type. These keys must be unique strings.")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MyKeyedUnion")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("union")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Foo "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"foo"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Bar "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"bar"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" keyed\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  froz Bool\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Bar")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v("\n")])])]),a("p",[e._v("Some data matching "),a("code",[e._v("MyKeyedUnion")]),e._v(", finding "),a("code",[e._v("Foo")]),e._v(" present, (shown as JSON) is:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"foo"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"froz"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("This data would also match, as "),a("code",[e._v("Bar")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"bar"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("12")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("No parameters are available for the "),a("code",[e._v("keyed")]),e._v(" Union representation strategy.")]),e._v(" "),a("h3",{attrs:{id:"union-kinded-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#union-kinded-representation"}},[e._v("#")]),e._v(" Union "),a("code",[e._v("kinded")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: "),a("em",[e._v("Various")])])]),e._v(" "),a("p",[a("code",[e._v("kinded")]),e._v(" Unions discriminate between constituent types of the Union by inspecting the "),a("em",[e._v("representation kind")]),e._v(" present at the current node. Each type in the union must be associated with a unique representation kind and exactly one of these representation kinds must be present at the node for it to be a valid Union of the type in question.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("kinded")]),e._v(" Union representation strategy doesn't introduce any kind of wrapping Map in the serialized form at all. Maps are only present if "),a("code",[e._v("map")]),e._v(" is one of the kinds listed in the Union. Contrast this with other union representation strategies, all of which use at least one layer of Map in their representation (other than "),a("code",[e._v("byteprefix")]),e._v(" Unions which are a special case).")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MyKindedUnion")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("union")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Foo map\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Bar "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" kinded\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  froz Bool\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Bar")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v("\n")])])]),a("p",[e._v("Some data matching "),a("code",[e._v("MyKindedUnion")]),e._v(", finding "),a("code",[e._v("Foo")]),e._v(" present, (shown as JSON) is:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"froz"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("This data would also match, as "),a("code",[e._v("Bar")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[e._v("12")]),e._v("\n")])])]),a("p",[e._v("The syntax used in the type declaration is different for "),a("code",[e._v("kinded")]),e._v(" Unions in comparison to other Union representation strategies. "),a("code",[e._v("kinded")]),e._v(" Unions list a representation kind, unquoted, unlike other representation strategies which list a quoted key or discriminator (other than "),a("code",[e._v("byteprefix")]),e._v(" Unions, a special case).")]),e._v(" "),a("p",[e._v("The kind listed after each element of the Union must be a valid representation kind, that is, a kind at the Data Model layer, such as "),a("code",[e._v("string")]),e._v(" and "),a("code",[e._v("map")]),e._v(". Schema kinds are not valid as they don't denote representation kinds (i.e. "),a("code",[e._v("struct")]),e._v(" would not be a valid kind for a "),a("code",[e._v("kinded")]),e._v(" Union).")]),e._v(" "),a("p",[e._v("It is only possible to discriminate "),a("em",[e._v("distinct")]),e._v(" representation kinds in a "),a("code",[e._v("kinded")]),e._v(" Union, there may be at most one of each possible representation kind present in such a Union.")]),e._v(" "),a("p",[e._v("Note that a type that has a different Schema kind to its representation kind uses the latter:")]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MyKindedUnion")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("union")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Foo map\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Bar "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Bang "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("string")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" kinded\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  froz Bool\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Bar")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Bang")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("Int"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" representation stringpairs "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  innerDelim "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('":"')]),e._v("\n  entryDelim "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"|"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("In this instance, even though "),a("code",[e._v("Bang")]),e._v(" presents as a user-facing Schema Map kind, it encodes to a String representation kind and is therefore listed as a "),a("code",[e._v("string")]),e._v(" in the "),a("code",[e._v("kinded")]),e._v(" Union.")]),e._v(" "),a("p",[e._v("No parameters are available for the "),a("code",[e._v("kinded")]),e._v(" Union representation strategy.")]),e._v(" "),a("h3",{attrs:{id:"union-envelope-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#union-envelope-representation"}},[e._v("#")]),e._v(" Union "),a("code",[e._v("envelope")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: Map")]),e._v(" (two entries of current node)")]),e._v(" "),a("p",[e._v("An "),a("code",[e._v("envelope")]),e._v(" Union representation strategy discriminates between constituent types of the Union by inspecting the value of a pre-determined discriminator key ("),a("code",[e._v("discriminantKey")]),e._v(") in a Map, while the content of the type is decoded from the value of a predetermined content key ("),a("code",[e._v("contentKey")]),e._v("). "),a("code",[e._v("envelope")]),e._v(" Unions are only valid for nodes that are Maps in the Data Model layer, it requires the ability to look up two distinct keys.")]),e._v(" "),a("p",[e._v("Each constituent type of an "),a("code",[e._v("envelope")]),e._v(" Union is accompanied by a quoted string that is unique amongst the types that is used to match against the value of "),a("code",[e._v("discriminantKey")]),e._v(" in the current node.")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MyEnvelopeUnion")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("union")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Foo "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"foo"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Bar "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"bar"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" envelope "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  discriminantKey "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"tag"')]),e._v("\n  contentKey "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"msg"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  froz Bool\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Bar")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v("\n")])])]),a("p",[e._v("Some data matching "),a("code",[e._v("MyEnvelopeUnion")]),e._v(", finding "),a("code",[e._v("Foo")]),e._v(" present, (shown as JSON) is:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"tag"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"foo"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"froz"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("This data would also match, as "),a("code",[e._v("Bar")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"tag"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"bar"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"msg"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("12")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("The "),a("code",[e._v("envelope")]),e._v(' Union representation strategy is an "envelope" in the sense that the type is addressed within a value of the current node and the type itself is wrapped in another value of the current node, the current node being the envelope that exists only to contain and discriminate the type. '),a("code",[e._v("envelope")]),e._v(" Unions are more self-describing and explicit than "),a("code",[e._v("inline")]),e._v(" or "),a("code",[e._v("kinded")]),e._v(" unions but are roughly comparable to "),a("code",[e._v("keyed")]),e._v(" unions in that sense.")]),e._v(" "),a("p",[e._v("Two general parameters are mandatory for the "),a("code",[e._v("envelope")]),e._v(" Union representation strategy:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("discriminantKey")]),e._v(" defines a quoted string that is used to look up a string in the Map at the current node to match against the keys provided with each of the constituent types of the Union.")]),e._v(" "),a("li",[a("code",[e._v("contentKey")]),e._v(" defines a quoted string that is used to look up a node that may decode to the type that the discriminator determines is the type of the Union.")])]),e._v(" "),a("h3",{attrs:{id:"union-inline-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#union-inline-representation"}},[e._v("#")]),e._v(" Union "),a("code",[e._v("inline")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: Map")]),e._v(" (only some entries of current node)")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("inline")]),e._v(" Union representation strategy decodes a Map node from the Data Model layer into one of the constituent types of the union by discriminating based on the value of a pre-determined key of that Map ("),a("code",[e._v("discriminantKey")]),e._v(").")]),e._v(" "),a("p",[e._v("This strategy is similar to the "),a("code",[e._v("envelope")]),e._v(" Union representation strategy but it does not traverse into a child node to decode the type, instead it decodes that type from the current node. Therefore, constituent type of an "),a("code",[e._v("inline")]),e._v(" Union "),a("em",[e._v("must")]),e._v(" have a Map representation kind (i.e. a Struct or a Map with default representation strategies).")]),e._v(" "),a("p",[e._v("Each constituent type of an "),a("code",[e._v("inline")]),e._v(" Union is accompanied by a quoted string that is unique amongst the types that is used to match against the value of "),a("code",[e._v("discriminantKey")]),e._v(" in the current node.")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MyInlineUnion")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("union")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Foo "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"foo"')]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Bar "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"bar"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" inline "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  discriminantKey "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"tag"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Foo")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  froz Bool\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Note that Bar is not an int as in our previous examples since this is not")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# possible with an inline Union")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Bar")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  bral String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Some data matching "),a("code",[e._v("MyInlineUnion")]),e._v(", finding "),a("code",[e._v("Foo")]),e._v(" present, (shown as JSON) is:")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"tag"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"foo"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"froz"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("This data would also match, as "),a("code",[e._v("Bar")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"tag"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"bar"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"bral"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"zot"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Using a type that has a representation kind other than a Map with an "),a("code",[e._v("inline")]),e._v(" Union would result in an error.")]),e._v(" "),a("p",[e._v("One general parameter is mandatory for the "),a("code",[e._v("inline")]),e._v(" Union representation strategy:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("discriminantKey")]),e._v(" defines a quoted string that is used to look up a string in the Map at the current node to match against the keys provided with each of the constituent types of the Union.")])]),e._v(" "),a("h3",{attrs:{id:"union-byteprefix-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#union-byteprefix-representation"}},[e._v("#")]),e._v(" Union "),a("code",[e._v("byteprefix")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: Bytes")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("byteprefix")]),e._v(" Union representation strategy is used strictly for Bytes representation kinds. As there are currently no representation strategies other than the default for Bytes that encode as Bytes at the Data Model layer, the "),a("code",[e._v("byteprefix")]),e._v(" Union representation strategy can only be used as a Union between named Bytes types.")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Signature")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("union")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Secp256k1Signature "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Bls12_381Signature "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" byteprefix\n\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Secp256k1Signature")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("bytes")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Bls12_381Signature")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("bytes")]),e._v("\n")])])]),a("p",[e._v("At the Data Model layer, this presents as Bytes (a byte array), where the first byte is the discriminator ("),a("code",[e._v("0x00")]),e._v(" or "),a("code",[e._v("0x01")]),e._v(") and the remainder is sliced to form either of the two types depending on the discriminator.")]),e._v(" "),a("p",[e._v("No parameters are available for the "),a("code",[e._v("byteprefix")]),e._v(" Union representation strategy.")]),e._v(" "),a("h3",{attrs:{id:"enum-string-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#enum-string-representation"}},[e._v("#")]),e._v(" Enum "),a("code",[e._v("string")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: String")])]),e._v(" "),a("p",[e._v("By default, a Schema Enum is simply represented as a String in the data model. An Enum in a Schema simply defines the list of possible strings that could be used at that node.")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Status")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("enum")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Nope\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Yep\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Maybe\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("This Enum dictates that where "),a("code",[e._v("Status")]),e._v(" is used, we should find one of "),a("code",[e._v('"Nope"')]),e._v(", "),a("code",[e._v('"Yep"')]),e._v(" or "),a("code",[e._v('"Maybe"')]),e._v(".  No other value is valid where "),a("code",[e._v("Status")]),e._v(" is used.")]),e._v(" "),a("p",[e._v("Where the serialized Strings are different to the values used for the Enum, they may be provided in parens as field-specific representation parameters:")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Status")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("enum")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Nope "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Nay"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Yep  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Yay"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Maybe\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("In this example, the serialization expects, and uses, the strings "),a("code",[e._v("Nay")]),e._v(", "),a("code",[e._v("Yay")]),e._v(" and "),a("code",[e._v("Maybe")]),e._v(".")]),e._v(" "),a("p",[e._v("No general parameters are available for the "),a("code",[e._v("string")]),e._v(" Enum representation strategy.")]),e._v(" "),a("h3",{attrs:{id:"enum-int-representation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#enum-int-representation"}},[e._v("#")]),e._v(" Enum "),a("code",[e._v("int")]),e._v(" Representation")]),e._v(" "),a("p",[a("strong",[e._v("Representation Kind: Int")])]),e._v(" "),a("p",[e._v("An alternative representation strategy for enums is "),a("code",[e._v("int")]),e._v(", which is closer to what users may expect from Enums in some programming languages that map enum values to integers. In IPLD Schemas we explicitly define the mapping to integers, so the user can dictate the appropriate data model values.")]),e._v(" "),a("p",[a("strong",[e._v("Example")])]),e._v(" "),a("div",{staticClass:"language-ipldsch extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[a("code",[a("span",{pre:!0,attrs:{class:"token typedef"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("type")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Status")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("enum")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Nope  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"0"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Yep   "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"1"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("|")]),e._v(" Maybe "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"100"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token representation"}},[e._v("} "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("representation")])]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v("\n")])])]),a("p",[e._v("As with the "),a("code",[e._v("string")]),e._v(" representaiton strategy, Enums with an "),a("code",[e._v("int")]),e._v(" representation strategy still quote the integer strings when provided as field-specific representation parameters. This is standard practice for field-specific representation parameters as they are converted to the correct type depending on context. In this context, they are assumed to be integers so must be convertable to integers.")]),e._v(" "),a("p",[e._v("There are no optional values, as in the "),a("code",[e._v("string")]),e._v(" representation strategy, all values must be provided when using "),a("code",[e._v("int")]),e._v(" representation strategy.")]),e._v(" "),a("p",[e._v("In our example, serialization expects, and uses, data model integer values "),a("code",[e._v("0")]),e._v(", "),a("code",[e._v("1")]),e._v(", and "),a("code",[e._v("100")]),e._v(". No other values at this position are valid.")]),e._v(" "),a("p",[e._v("No general parameters are available for the "),a("code",[e._v("int")]),e._v(" Enum representation strategy.")])])}),[],!1,null,null,null);t.default=n.exports}}]);