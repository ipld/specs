(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{434:function(t,e,s){"use strict";s.r(e);var n=s(42),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"language-ipldsch extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ipldsch"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## -----")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## This is the schema describing the schema declarations for IPLD Schemas.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Yes, it's self-describing! :)")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## -----")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Type names are a simple alias of string.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## There are some additional rules that should be applied. Type names:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##   - *Must* only contain alphanumeric ASCII characters and underscores")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##   - *Must* begin with a capital letter")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##   - *Should* avoid more than one connected underscore character,")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##     multiple-underscores may be used for codegen")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Type names are strings meant for human consumption at a local scope.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## When making a Schema, note that the TypeName is the key of the map:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## a TypeName must be unique within the Schema.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeName")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("string")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## SchemaMap is a complete set of types;")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## it is simply a map of TypeName to detailed declaration of that Type.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## A simple schema map with one type might look like this:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ```")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## {")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('##   "MyFooType": {')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('##     "type": "string"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##   }")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## }")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ```")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SchemaMap")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("TypeName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("Type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## AdvancedDataLayoutName defines the name of an ADL as a string.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## The same constraints and conventions apply as for TypeName.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## This identifier is used for keys in the AdvancedDataLayoutMap and also as")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## references to ADLs where the "advanced" representation strategy is used for')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## the types that support it.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AdvancedDataLayoutName")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("string")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## AdvancedDataLayoutMap defines the set of ADLs found within the schema. It")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## maps the name (AdvancedDataLayoutName) to the AdvancedDataLayout, which is")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## currently an empty map.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AdvancedDataLayoutMap")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("AdvancedDataLayoutName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("AdvancedDataLayout"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Schema is a single-member union, which can be used in serialization")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## to make a form of "nominative type declaration".')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## A complete (if quite short) Schema might look like this:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ```")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## {")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('##   "schema": {')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('##     "MyFooType": {')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('##       "type": "string"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##     }")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##   }")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## }")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ```")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Schema")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\ttypes SchemaMap\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("\tadvanced")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AdvancedDataLayoutMap")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## The types of Type are a union.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## The Type union is serialized using "inline" union representation,')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## which means all of its members have map representations, and there will be")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## an entry in that map called "type" which contains the union discriminant.')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Some of the kinds of type are so simple the union discriminant is the only")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## content at all, e.g. strings:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ```")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## {")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('##   "type": "string"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## }")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ```")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Other types have more content.  Consider this example of a map type:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ```")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## {")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('##   "type": "map",')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('##   "keyType": "String",')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('##   "valueType": "Int"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## }")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ```")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Type")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeBool "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bool"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeString "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"string"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeBytes "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bytes"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeInt "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"int"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeFloat "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"float"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeMap "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"map"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeList "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"list"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeLink "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"link"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeUnion "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"union"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeStruct "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"struct"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeEnum "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"enum"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeCopy "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"copy"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" inline "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tdiscriminantKey "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"kind"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TypeKind enumerates all the major kinds of type.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Notice this enum's members are the same as the set of strings used as")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## discriminants in the Type union.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TODO: not actually sure we'll need to declare this.  Only usage is")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## in the Type union representation details?")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeKind")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("enum")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Bool\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" String\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Bytes\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Int\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Float\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Map\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" List\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Link\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Union\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Struct\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Enum\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## RepresentationKind is similar to TypeKind, but includes only those concepts")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## which exist at the IPLD *Data Model* level.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## In other words, structs, unions, and enumerations are not present:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## those concepts are introduced in the IPLD Schema system, and when serialized,")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## all of them must be transformable to one of these representation kinds")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## (e.g. a "struct" TypeKind will usually be transformed to a "map"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## RepresentationKind; "enum" TypeKind are always "string" RepresentationKind;')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## and so on.)")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## RepresentationKind strings are sometimes used to to indicate part of the")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## definition in the details of Type; for example, they're used describing")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## some of the detailed behaviors of a "kinded"-style union type.')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("RepresentationKind")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("enum")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Bool\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" String\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Bytes\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Int\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Float\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Map\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" List\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Link\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## AnyScalar defines a union of the basic non-complex kinds.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Useful defining usage of IPLD nodes that do compose from other nodes.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AnyScalar")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Bool "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bool")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" String "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("string")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Bytes "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("bytes")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Int "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" Float "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("float")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" kinded\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## AdvancedDataLayout defines `advanced` definitions which are stored in the")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## top-level "advanced" map (AdvancedDataLayoutMap)')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Used as `advanced Foo` rather than `type Foo` to indicate an advanced data")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## layout (ADL) with that name which can be used as a representation for type")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## definitions whose kind the ADL is able to support.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## The AdvancedDataLayoutName is currently the only identifier that can be used")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## to make a connection with the algorithm/logic behind this ADL. Future")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## iterations may formalize this connection by some other means.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AdvancedDataLayout")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TypeBool describes a simple boolean type.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## It has no details.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeBool")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TypeString describes a simple string type.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## It has no details.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeString")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TypeBytes describes a simple byte array type.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeBytes")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\trepresentation BytesRepresentation\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## BytesRepresentation specifies how a TypeBytes is to be serialized. By")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## default it will be stored as bytes in the data model but it may be replaced")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## with an ADL.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BytesRepresentation")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" BytesRepresentation_Bytes "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bytes"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" AdvancedDataLayoutName "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"advanced"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## BytesRepresentation_Bytes is the default representation for TypeBytes and")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## will be used implicitly if no representation is specified.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BytesRepresentation_Bytes")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TypeInt describes a simple integer numeric type.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## It has no details.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeInt")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TypeFloat describes a simple floating point numeric type.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## It has no details.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeFloat")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TypeMap describes a key-value map.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## The keys and values of the map have some specific type of their own.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## A constraint on keyType is that the referenced type must have a string")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## representation kind. The IPLD Data Model only allows for string keys on maps,")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## so this constraint is imposed here.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeMap")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tkeyType TypeName\n\tvalueType TypeTerm\n\tvalueNullable Bool "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("implicit "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"false"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\trepresentation MapRepresentation\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## MapRepresentation describes how a map type should be mapped onto")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## its IPLD Data Model representation.  By default a map is a map in the")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Data Model but other kinds can be configured.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MapRepresentation")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" MapRepresentation_Map "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"map"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" MapRepresentation_StringPairs "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"stringpairs"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" MapRepresentation_ListPairs "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"listpairs"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" AdvancedDataLayoutName "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"advanced"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## MapRepresentation_Map describes that a map should be encoded as")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## a map in the Data Model")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MapRepresentation_Map")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## MapRepresentation_StringPairs describes that a map should be encoded as a")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## string of delimited "k/v" entries, e.g. "k1=v1,k2=v2".')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## The separating delimiter may be specified with "entryDelim", and the k/v')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## delimiter may be specified with "innerDelim". So a "k=v" naive')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## comma-separated form would use an "innerDelim" of "=" and an "entryDelim"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## of ",".')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## This serial representation is limited: the domain of keys must")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## exclude the "innerDelim" and values and keys must exclude ",".')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## There is no facility for escaping, such as in escaped CSV.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## This also leads to a further restriction that this representation is only")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## valid for maps whose keys and values may all be encoded to string form")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## without conflicts in delimiter character. It is recommended, therefore,")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## that its use be limited to maps containing values with the basic data")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## model kinds that exclude multiple values (i.e. no maps, lists, and therefore")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## structs or unions).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MapRepresentation_StringPairs")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tinnerDelim String\n\tentryDelim String\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## MapRepresentation_ListPairs describes that a map should be encoded as a")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## list in the IPLD Data Model. This list comprises a sub-list for each entry,")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## in the form: [[k1,v1],[k2,v2]].")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## This representation type is similar to StructRepresentation_Tuple except")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## it includes the keys. This is critical for maps since the keys are not")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## defined in the schema (hence "tuple" representation isn\'t available for')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## maps).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MapRepresentation_ListPairs")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TypeList describes a list.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## The values of the list have some specific type of their own.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeList")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tvalueType TypeTerm\n\tvalueNullable Bool "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("implicit "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"false"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\trepresentation ListRepresentation\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ListRepresentation describes how a map type should be mapped onto")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## its IPLD Data Model representation.  By default a list is a list in the")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## data model but it may be replaced with an ADL.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ListRepresentation")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" ListRepresentation_List "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"list"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" AdvancedDataLayoutName "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"advanced"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## ListRepresentation_List is the default representation for TypeList and")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## will be used implicitly if no representation is specified.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ListRepresentation_List")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TypeLink describes a hash linking to another object (a CID).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## A link also has an "expectedType" that provides a hinting mechanism')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## suggesting what we should find if we were to follow the link. This")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## cannot be strictly enforced by a node or block-level schema")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## validation but may be enforced elsewhere in an application relying on")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## a schema.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## The expectedType is specified with the `&Any` link shorthand, where")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## `Any` may be replaced with a specific type.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Unlike other kinds, we use `&Type` to denote a link Type rather than")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## `Link`. In this usage, we replace `Type` the expected Type, with `&Any`")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## being shorthand for "a link which may resolve to a type of any kind".')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## `expectedType` is a String, but it should validate as "Any" or a TypeName')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## found somewhere in the schema.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeLink")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\texpectedType String "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("implicit "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Any"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## TypeUnion describes a union (sometimes called a "sum type", or')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## more verbosely, a "discriminated union").')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## A union is a type that can have a value of several different types, but")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## unlike maps or structs, in a union only one of those values may be present")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## at a time.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Unions can be defined as representing in several different ways: see")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## the documentation on the UnionRepresentation type for details.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## The set of types which the union can contain are specified in a map")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## inside the representation field.  (The key type of the map varies per")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## representation strategy, so it's not possible to keep on this type directly.)")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeUnion")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\trepresentation UnionRepresentation\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## UnionRepresentation is a union of all the distinct ways a TypeUnion's values")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## can be mapped onto a serialized format for the IPLD Data Model.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## There are five strategies that can be used to encode a union:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## "keyed", "envelope", "inline", "byteprefix", and "kinded".')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## The "keyed", "envelope", and "inline" strategies are all ways to produce')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## representations in a map format, using map keys as type discriminators")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## (some literature may describe this as a "tagged" style of union).')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## The "byteprefix" strategy, only available only for unions in which all')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## member types themselves represent as bytes in the data model, uses another")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## byte as the type discrimination hint (and like the map-oriented strategies,")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## may also be seen as a form of "tagged" style unions).')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## The "kinded" strategy can describe a union in which member types have')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## several different representation kinds, and uses the representation kind")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## itself as the type discrimination hint to do so.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## Note: Unions can be used to produce a "nominative" style of type declarations')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## -- yes, even given that IPLD Schema systems are natively "structural" typing!')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UnionRepresentation")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" UnionRepresentation_Kinded "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"kinded"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" UnionRepresentation_Keyed "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"keyed"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" UnionRepresentation_Envelope "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"envelope"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" UnionRepresentation_Inline "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"inline"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" UnionRepresentation_BytePrefix "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"byteprefix"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## "Kinded" union representations describe a bidirectional mapping between')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## a RepresentationKind and a Type (referenced by name) which should be the")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## union member decoded when one sees this RepresentationKind.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## The referenced type must of course produce the RepresentationKind it's")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## matched with!")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UnionRepresentation_Kinded")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("RepresentationKind"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("TypeName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## "Keyed" union representations will encode as a map, where the map has')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## exactly one entry, the key string of which will be used to look up the name")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## of the Type; and the value should be the content, and be of that Type.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Note: when writing a new protocol, it may be wise to prefer keyed unions")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## over the other styles wherever possible; keyed unions tend to have good")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## performance characteristics, as they have most "mechanical sympathy" with')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## parsing and deserialization implementation order.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UnionRepresentation_Keyed")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("String"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("TypeName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## "Envelope" union representations will encode as a map, where the map has')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## exactly two entries: the two keys should be of the exact strings specified")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## for this envelope representation.  The value for the discriminant key")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## should be one of the strings in the discriminant table.  The value for")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## the content key should be the content, and be of the Type matching the")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## lookup in the discriminant table.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UnionRepresentation_Envelope")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tdiscriminantKey String\n\tcontentKey String\n\tdiscriminantTable "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("String"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("TypeName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## "Inline" union representations require that all of their members encode')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## as a map, and encode their type info into the same map as the member data.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Thus, the map for an inline union may have any number of entries: it is")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## however many fields the member value has, plus one (for the discriminant).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## All members of an inline union must be struct types and must encode to")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## the map RepresentationKind.  Other types which encode to map (such as map")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## types themselves!) cannot be used: the potential for content values with")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## with keys overlapping with the discriminantKey would result in undefined")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## behavior!  Similarly, the member struct types may not have fields which")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## have names that collide with the discriminantKey.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## When designing a new protocol, use inline unions sparringly; despite")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## appearing simple, they have the most edge cases of any kind of union")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## representation, and their implementation is generally the most complex and")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## is difficult to optimize deserialization to support.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UnionRepresentation_Inline")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tdiscriminantKey String\n\tdiscriminantTable "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("String"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("TypeName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## UnionRepresentation_BytePrefix describes a union representation for unions")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## whose member types are all bytes. It is encoded to a byte array whose")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## first byte is the discriminator and subsequent bytes form the discriminated")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## type.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## byteprefix is an invalid representation for any union that contains a type")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## that does not have a bytes representation.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UnionRepresentation_BytePrefix")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tdiscriminantTable "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("TypeName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("Int"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TypeStruct describes a type which has a group of fields of varying Type.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Each field has a name, which is used to access its value, similarly to")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## accessing values in a map.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## The most typical representation of a struct is as a map, in which case field")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## names also serve as the the map keys (though this is a default, and details")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## of this representation may be configured; and other representation strategies")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## also exist).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeStruct")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tfields "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("FieldName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("StructField"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\trepresentation StructRepresentation\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## FieldName is an alias of string.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## There are some additional rules that should be applied:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##   - Field names should by convention begin with a lower-case letter;")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##   - Field names must be all printable characters (no whitespace);")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##   - Field names must not contain punctuation other than underscores")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##     (dashes, dots, etc.).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Field names are strings meant for human consumption at a local scope.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## When making a Schema, note that the FieldName is the key of the map:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## a FieldName must be unique within the Schema.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FieldName")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("string")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## StructField describes the properties of each field declared by a TypeStruct.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## StructField contains properties similar to TypeMap -- namely, it describes")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## a content type (as a TypeTerm -- it supports inline definitions) -- and")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## has a boolean property for whether or not the value is permitted to be null.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## In addition, StructField also has a property called "optional".')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## An "optional" field is one which is permitted to be absent entirely.')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## This is distinct from "nullable": a field can be optional=false and')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## nullable=true, in which case it's an error if the key is missing entirely,")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## but null is of course valid.  Conversely, if a field is optional=true and")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## nullable=false, it's an error if the field is present and assigned null, but")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## fine for a map to be missing a key of the field's name entirely and still be")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## recognized as this struct.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## (The specific behavior of optionals may vary per StructRepresentation.)")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Note that the 'optional' and 'nullable' properties are not themselves")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## optional... however, in the IPLD serial representation of schemas, you'll")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## often see them absent from the map encoding a StructField.  This is because")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## these fields are specified to be implicitly false.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Implicits in a map representation of a struct mean that those entries may")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## be missing from the map encoding... but unlike with "optional" fields, there')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## is no "undefined" value; absence is simply interpreted as the value specified')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## as the implicit.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## (With implicit fields, an explicitly encoded implicit value is actually an")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## error instead!)  "Optional" fields give rise to N+1 cardinality logic,')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## just like "nullable" fields; "implicit" fields *do not*.')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StructField")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("\ttype")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeTerm")])]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" Bool "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("implicit "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"false"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullable")]),t._v(" Bool "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("implicit "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"false"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TypeTerm is a union of either TypeName or an InlineDefn. th It's used for the")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## value type in the recursive types (maps, lists, and the fields of structs),")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## which allows the use of InlineDefn in any of those positions.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TypeTerm is simply a TypeName if the kind of data is a string; this is the")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## simple case.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Note that TypeTerm isn't used to describe *keys* in the recursive types that")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## have them (maps, structs) -- recursive types in keys would not lend itself")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## well to serialization!")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TypeTerm also isn't used to describe members in Unions -- this is a choice")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## aimed to limit syntactical complexity (both at type definition authoring")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## time, as well as for the sake of error messaging during typechecking).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeTerm")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeName "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("string")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" InlineDefn map\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" kinded\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## InlineDefn represents a declaration of an anonymous type of one of the simple")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## recursive kinds (e.g. map or list) which is found "inline" in another type\'s')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## definition.  It's the more complex option of the TypeTerm union.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## Note that the representation of this union -- `representation inline "kind"`')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## -- as well as the keywords for its members -- align exactly with those")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## in the Type union.  Technically, this isn't a necessary property (in that")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## nothing would break if that sameness was violated) but it's awfully nice for")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## sanity; what we're saying here is that the representation of the types in an")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## InlineDefn should look *exactly the same* as the top-level Types... it's just")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## that we're restricted to a subset of the members.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InlineDefn")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeMap "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"map"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" TypeList "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"list"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" inline "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tdiscriminantKey "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"kind"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## StructRepresentation describes how a struct type should be mapped onto")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## its IPLD Data Model representation.  Typically, maps are the representation")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## kind, but other kinds and details can be configured.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StructRepresentation")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" StructRepresentation_Map "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"map"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" StructRepresentation_Tuple "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"tuple"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" StructRepresentation_StringPairs "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"stringpairs"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" StructRepresentation_StringJoin "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"stringjoin"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" StructRepresentation_ListPairs "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"listpairs"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## StructRepresentation_Map describes a way to map a struct type onto a map")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## representation. Field serialization options may optionally be configured to")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## enable mapping serialized keys using the 'rename' option, or implicit values")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## specified where the field is omitted from the serialized form using the")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## 'implicit' option.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## See StructRepresentation_Map_FieldDetails for details on the 'rename' and")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## 'implicit' options.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StructRepresentation_Map")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tfields "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("FieldName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("StructRepresentation_Map_FieldDetails"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## StructRepresentation_Map_FieldDetails describes additional properties of a")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## struct field when represented as a map.  For example, fields may be renamed,")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## or implicit values associated.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## If an implicit value is defined, then during marshalling, if the actual value")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## is the implicit value, that field will be omitted from the map; and during")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## unmarshalling, correspondingly, the absence of that field will be interpreted")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## as being the implicit value.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Note that fields with implicits are distinct from fields which are optional!")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## The cardinality of membership of an optional field is is incremented:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## e.g., the cardinality of "fieldname Bool" is 2; "fieldname optional Bool" is')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## membership cardinality *3*, because it may also be undefined.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## By contrast, the cardinality of membership of a field with an implicit value")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## remains unchanged; there is serial state which can map to an undefined value.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Note that 'rename' supports exactly one string, and not a list: this is")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## intentional.  The rename feature is meant to allow serial representations")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## to use a different key string than the schema type definition field name;")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## it is not intended to be used for migration purposes.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StructRepresentation_Map_FieldDetails")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\trename "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" String\n\timplicit "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" AnyScalar\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## StructRepresentation_Tuple describes a way to map a struct type into a list")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## representation.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Tuple representations are less flexible than map representations:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## field order can be specified in order to override the order defined")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## in the type, but optionals and implicits are not (currently) supported.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## A `fieldOrder` list must include quoted strings (FieldName is a string")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## type) which are coerced to the names of the struct fields. e.g.:")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('##   fieldOrder ["Foo", "Bar", "Baz"]')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StructRepresentation_Tuple")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tfieldOrder "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("FieldName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## StructRepresentation_StringPairs describes that a struct should be encoded")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## as a string of delimited "k/v" entries, e.g. "k1=v1,k2=v2".')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## The separating delimiter may be specified with "entryDelim", and the k/v')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## delimiter may be specified with "innerDelim". So a "k=v" naive')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## comma-separated form would use an "innerDelim" of "=" and an "entryDelim"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## of ",".')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Serialization a struct with stringpairs works the same way as serializing")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## a map with stringpairs and the same character limitations exist. See")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## MapRepresentation_StringPairs for more details on these limitations.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StructRepresentation_StringPairs")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tinnerDelim String\n\tentryDelim String\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## StructRepresentation_StringJoin describes a way to encode a struct to")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## a string in the IPLD Data Model. Similar to tuple representation, the")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## keys are dropped as they may be inferred from the struct definition.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## values are concatenated, in order, and separated by a "join" delimiter.')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## For example, specifying ":" as the "join": "v1,v2,v3".')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## stringjoin is necessarily restrictive and therefore only valid for structs")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## whose values may all be encoded to string form without conflicts in "join"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## character. It is recommended, therefore, that its use be limited to structs")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## containing values with the basic data model kinds that exclude multiple")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## values (i.e. no maps, lists, and therefore structs or unions).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StructRepresentation_StringJoin")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tjoin String\n\tfieldOrder "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("optional")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("FieldName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## StructRepresentation_ListPairs describes that a struct, should be encoded as")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## a list in the IPLD Data Model. This list comprises a sub-list for each")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## entry, in the form: [[k1,v1],[k2,v2]].")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## This representation type encodes in the same way as")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## MapStructRepresentation_Tuple. It is also similar to")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## StructRepresentation_Tuple except it includes the keys in nested lists.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## A tuple representation for a struct will encode more compact than listpairs.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("StructRepresentation_ListPairs")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## TypeEnum describes a type which has a known, pre-defined set of possible")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## values. Each of the values must be representable as a string (EnumValue)")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## when using the default "string" representation, or when using an "int"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## representation, an integer must also be supplied along with the EnumValue.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## Integer and string values (for int and string representations respectively)")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## are provided in parens in the DSL. Where the string used in serialization is")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## the same as the EnumValue, it may be omitted. For int representation enums,")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## all int values are required.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeEnum")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tmembers "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("EnumValue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("Null"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\trepresentation EnumRepresentation\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## EnumValue is a string that has limitations for use as a member of an enum")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## set. The rules for EnumValue are the same as for TypeName but without the")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## convention of an uppercase first character. Capitalization is left up to")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## the user.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("EnumValue")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("string")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## EnumRepresentation describes how an enum type should be mapped onto")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## its IPLD Data Model representation. By default an enum is represented as a")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## string kind but it may also be represented as an int kind.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("EnumRepresentation")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("union")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" EnumRepresentation_String "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"string"')]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v(" EnumRepresentation_Int "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"int"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token representation"}},[t._v("} "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("representation")])]),t._v(" keyed\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## EnumRepresentation_String describes the way an enum is represented as a")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## string in the data model. By default, the strings used as EnumValue will be")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## used at the serialization. A custom string may be provided (with `Foo ("x")`')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## in the DSL) which will be stored here in the representation block. Missing")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## entries in this map will use the default.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("EnumRepresentation_String")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("EnumValue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("String"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## EnumRepresentation_Int describes the way an enum is represented as an int")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## in the data model. A mapping of names to ints is required to perform the")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## conversion from int to enum value. In the DSL, int values _must_ be provided")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## for each EnumValue (with `Foo ("100")`, those are stored here.')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("EnumRepresentation_Int")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("EnumValue"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("Int"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## TypeCopy describes a special "copy" unit that indicates that a type name')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## should copy the type descriptor of another type. TypeCopy does not redirect a")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## name to another type. Instead, it copies the entire type definition and")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## assigns it to another type.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## The DSL defines a TypeCopy as `type NewThing = CopiedThing`, where")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('## "CopiedThing" refers to a `type` defined elsewhere in a schema and is not')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("## one of TypeKind or an inline type descriptor (`{}`, `[]`, `&`).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("##")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token typedef"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TypeCopy")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tfromType TypeName\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);