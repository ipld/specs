(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{446:function(e,t,n){"use strict";n.r(t);var i=n(45),a=Object(i.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"ipld-schemas-and-migration"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ipld-schemas-and-migration"}},[e._v("#")]),e._v(" IPLD Schemas and migration")]),e._v(" "),n("p",[e._v("Fundamental to our approach to schemas is an understanding:")]),e._v(" "),n("blockquote",[n("p",[e._v("Data Never Changes.  Only our interpretation varies.")])]),e._v(" "),n("p",[e._v("Data can be created under one schema, and interpreted later under another.\nData may predate or be created without any kind of schema at all.\nAll of this needs to be fine.")]),e._v(" "),n("p",[e._v("Moreover, before talking about migration, it's important to note that we\ndon't allow the comforting, easy notion that migration is a one-way process,\nor can be carried out atomically at one magically instantaneous point in time.\nBecause data is immutable, and producing updated versions of it doesn't make\nthe older version of the data go away, migration is less a thing that you do;\nand more a state of mind.  Migration has to be seamless at any time.")]),e._v(" "),n("p",[e._v("Migration comes in two parts:")]),e._v(" "),n("ol",[n("li",[e._v("Understand what data we have;")]),e._v(" "),n("li",[e._v("and having a process to map it into the format of data we want.")])]),e._v(" "),n("p",[e._v("We'll spend a few sections on part 1, and then get on to part 2.")]),e._v(" "),n("h2",{attrs:{id:"version-detection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#version-detection"}},[e._v("#")]),e._v(" Version detection")]),e._v(" "),n("p",[e._v("We don't include any built-in/blessed concepts of versioning in IPLD Schemas.\nIt's not necessary: we have rich primitives which can be used to build\neither explicit versioning or version detection, at your option.")]),e._v(" "),n("p",[e._v("Since it's easy to check if a schema fits over a piece of data, it's\neasy to simply probe a series of schemas until finding one that fits.\nTherefore, any constraint a schema makes has the potential to be used\nfor version detection!")]),e._v(" "),n("p",[e._v("There are a handful of recognizable patterns that are used frequently:")]),e._v(" "),n("ul",[n("li",[e._v("Using a dummy union to get nominative typing at the document root.\n"),n("ul",[n("li",[e._v("e.g. "),n("code",[e._v('{"foo": {...}}')]),e._v(', using "foo" as the type+version hint.\nThe union has only single member, and we use this in concert with multiple\nschemas and probing: it returns quickly in the case of a non-match.')]),e._v(" "),n("li",[e._v("Any union representation will do.\n"),n("ul",[n("li",[e._v("Keyed unions: "),n("code",[e._v('{"foo-v2": {...}}')])]),e._v(" "),n("li",[e._v("Envelope unions: "),n("code",[e._v('{"version": "2", "content":{...}}')])])])]),e._v(" "),n("li",[e._v("Inline unions: "),n("code",[e._v('{"version": "2", ...}')])]),e._v(" "),n("li",[e._v("A single-member struct would also fit the pattern, being functionally\nequivalent to a keyed union.")]),e._v(" "),n("li",[e._v("See the schema-schema for an example of this!")])])]),e._v(" "),n("li",[e._v('Using a "version" union (with multiple members).\n'),n("ul",[n("li",[e._v("e.g. "),n("code",[e._v('{"version": "1.2.3", "data":{...}}')])]),e._v(" "),n("li",[e._v("Any union representation will do.")]),e._v(" "),n("li",[e._v("This might not be the best approach: in this approach, the multiple versions\nare implemented "),n("em",[e._v("within")]),e._v(" one schema!  Typically it's considered easier to\nwork with and more maintainable to use a separate schema per version.")])])]),e._v(" "),n("li",[e._v('Using a struct with "version" field(s), then a second unpacking.\n'),n("ul",[n("li",[e._v("Two phases of matching allow user-specified decisions in the middle:\n"),n("ul",[n("li",[e._v("First a simple schema is used, containing some struct fields for version\ninfo, plus some ignored fields which will contain the further content.\nThis simple schema is assumed to match completely.")]),e._v(" "),n("li",[e._v("Secondly, using information from that first pass, user-specified logic\nselects a complete schema, which is then used to handle the full data.")])])])])])]),e._v(" "),n("p",[e._v("(Currently, this probing is left to the library user.  More built-in features\naround this are expected to come in the future.)")]),e._v(" "),n("p",[e._v("Any of these approaches may also be composed.  For example, you might choose\nto use a dummy union at the root of a document to sanity-check what general\ntype of data you're processing; and use an inline union inside that for more\nspecific version matching, and so forth.")]),e._v(" "),n("p",[e._v("(In the future, we may also be able to construct some specialized schemas that\nsuggest jumping to another schema specifically and directly (rather than\nlinear probing); some research required.  (Ideally this would work consistently\nregardless of the ordering of fields in the arriving data, but there's some\ntension between that and performance.)  It might also be possible to construct\nthese as a user already!)")]),e._v(" "),n("p",[e._v("NOTE that these conventions are easy to adopt even by systems not implemented\nusing IPLD Schemas!  If you're working on a system which hasn't started using\nIPLD Schemas yet, and you aim to in the future, "),n("em",[e._v("start using version hinting")]),e._v("\nbased on these designs "),n("em",[e._v("now")]),e._v("; the benefits can be reaped later.")]),e._v(" "),n("h2",{attrs:{id:"versioning-theory"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#versioning-theory"}},[e._v("#")]),e._v(" Versioning theory")]),e._v(" "),n("p",[e._v("There are different philosophies of versioning: namely, explicit versioning\nlabels and version detection; which to use is a choice.")]),e._v(" "),n("p",[e._v("In short, explicit versioning with labels takes a prescriptive approach,\nrequiring coordinated labelling choices up front, and thus tends towards\nfragility and is not particularly fork/community/decentralization-friendly.\nVersion detection -- also known as its generalized cousin, "),n("em",[e._v("Feature")]),e._v(" detection\n-- is strictly more powerful, but can be more complex.\nNeither can be deployed to reliable effect without a plan.")]),e._v(" "),n("p",[e._v("Explicit versioning labelling is prone to treating the version label as a\nsemantic junk drawer, upon which we can heap unbounded amounts of\nnot-necessarily-related semantics.\nThis is a temptation which can be mitigated through diligence, but the\nfundamental incentive is always there: like global variables in programming,\na document-global explicit version allows lazy coding and fosters presumptions.")]),e._v(" "),n("p",[e._v("Version/feature detection has the potential to become a fractal.\nUsing it well thus "),n("em",[e._v("also")]),e._v(" requires diligence.  However, there is no built-in\nsiren temptation to misuse them in the same way as explicit versioning; the\ntrade-offs in complexity tend to be make themselves fairly pronounced and\nas such are relatively easily communicated.")]),e._v(" "),n("p",[e._v("It's impossible to make a blanket prescription of how to associate version\ninformation with data.  Different choices have different tradeoffs.\nIPLD Schemas aim to make either choice (or hybrids of approach!) viable.")]),e._v(" "),n("h2",{attrs:{id:"strongly-linked-schemas"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#strongly-linked-schemas"}},[e._v("#")]),e._v(" Strongly linked schemas")]),e._v(" "),n("p",[e._v("It is possible to have a document which links directly to its own Schema!\nSince IPLD Schemas are themselves representable in IPLD, it's outright trivial\nto make an object containing a CID linking to a Schema.")]),e._v(" "),n("p",[e._v("This may be useful -- in particular, it certainly solves any issue of chosing\nunique version strings in using explicit versioning! -- but it is also worth\nnoting that is is not a solution to "),n("em",[e._v("migration")]),e._v(': while having a specific schema\nexplicitly linked is certainly one way to address the need to\n"understand what data we have", remember that the definition of migration has a\nsecond half: "having a process to map data into the format we want".')]),e._v(" "),n("p",[e._v("Unless it just so "),n("em",[e._v("happens")]),e._v(" that this exact schema is the one you want, and have\nalready build your application logic against, etc... an explicitly linked schema\ndoesn't necessarily provide more value in terms of migration than any of the\nother forms of versioning; it's essentially the same as using explicit labels.")]),e._v(" "),n("h2",{attrs:{id:"actually-migrating"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#actually-migrating"}},[e._v("#")]),e._v(" Actually migrating")]),e._v(" "),n("p",[e._v("IPLD Schemas aren't completely magic.")]),e._v(" "),n("p",[e._v('Some part of migration is inevitably left up to application logic.\nAlmost by definition, "a process to map data into the format of data we want"\nis at its most general going to be a turing-complete operation.')]),e._v(" "),n("p",[e._v("However, IPLD can still help: the relationship between the Data Model versus\nthe Schema provides a foundation for writing maintainable migrations.")]),e._v(" "),n("p",[e._v("Any migration logic can be expressed as a function from "),n("code",[e._v("Node")]),e._v(" to "),n("code",[e._v("Node")]),e._v(".\nThese nodes may each be checking Schema validity -- against two different\nschemas! -- but the code for transposing data from one node to the other\ncan operate entirely within Data Model.  The result is the ability to write\ncode that's effectively handling multiple disjoin type systems... without\nany real issues.")]),e._v(" "),n("p",[e._v("Thus, a valid strategy for longlived application design is to handle each\nmajor change to a schema by copying/forking the current one; keeping it\naround for use as a recognizer for old versions of data; and writing a\nquick function that can flip data from the old schema format to the new one.\nWhen parsing data, try the newer schema first; if it's rejected, try the old\none, and use the migration function as necessary.")]),e._v(" "),n("p",[e._v("If you're using codegen based on the schema, note that you'll probably only\nneed to use codegen for the most recent / most preferred version of the schema.\n(This is a good thing!  We wouldn't want tons of generated code per version\nto start stacking up in our repos.)\nParsing of data for other versions can be handled by "),n("code",[e._v("ipldcbor.Node")]),e._v(" or other\nsuch implementations which are optimized for handling serial data; the\nmigration function is a natural place to build the codegenerated native typed\n"),n("code",[e._v("Node")]),e._v("s, and so each half of the process can easily use the "),n("code",[e._v("Node")]),e._v("\nimplementation that is best suited.")])])}),[],!1,null,null,null);t.default=a.exports}}]);