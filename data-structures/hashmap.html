<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Specification: HashMap | IPLD Specifications</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="Specifications for the Inter-planetary Linked Data project">
    
    <link rel="preload" href="/assets/css/0.styles.6c77b833.css" as="style"><link rel="preload" href="/assets/js/app.e54c04cf.js" as="script"><link rel="preload" href="/assets/js/2.fa483b33.js" as="script"><link rel="preload" href="/assets/js/38.8f0ab58a.js" as="script"><link rel="prefetch" href="/assets/js/10.f6e8966c.js"><link rel="prefetch" href="/assets/js/11.b50c9801.js"><link rel="prefetch" href="/assets/js/12.dfda07e3.js"><link rel="prefetch" href="/assets/js/13.bc44e0a1.js"><link rel="prefetch" href="/assets/js/14.02bd3716.js"><link rel="prefetch" href="/assets/js/15.feedc362.js"><link rel="prefetch" href="/assets/js/16.1076ecbb.js"><link rel="prefetch" href="/assets/js/17.83c7ad87.js"><link rel="prefetch" href="/assets/js/18.fb0a53fa.js"><link rel="prefetch" href="/assets/js/19.6cad2206.js"><link rel="prefetch" href="/assets/js/20.e5d2b50d.js"><link rel="prefetch" href="/assets/js/21.7255bc0c.js"><link rel="prefetch" href="/assets/js/22.61d63bb5.js"><link rel="prefetch" href="/assets/js/23.20e9e9e8.js"><link rel="prefetch" href="/assets/js/24.c35c7061.js"><link rel="prefetch" href="/assets/js/25.02f56933.js"><link rel="prefetch" href="/assets/js/26.9763295a.js"><link rel="prefetch" href="/assets/js/27.d40bd431.js"><link rel="prefetch" href="/assets/js/28.666891d7.js"><link rel="prefetch" href="/assets/js/29.2196a2d1.js"><link rel="prefetch" href="/assets/js/3.ce55762f.js"><link rel="prefetch" href="/assets/js/30.806aa330.js"><link rel="prefetch" href="/assets/js/31.a448c6a4.js"><link rel="prefetch" href="/assets/js/32.0658f00c.js"><link rel="prefetch" href="/assets/js/33.6e36c0be.js"><link rel="prefetch" href="/assets/js/34.fc297eec.js"><link rel="prefetch" href="/assets/js/35.67518866.js"><link rel="prefetch" href="/assets/js/36.477e2ecf.js"><link rel="prefetch" href="/assets/js/37.5a63d481.js"><link rel="prefetch" href="/assets/js/39.c023f51e.js"><link rel="prefetch" href="/assets/js/4.84d7103d.js"><link rel="prefetch" href="/assets/js/40.543eab40.js"><link rel="prefetch" href="/assets/js/41.c97acf8b.js"><link rel="prefetch" href="/assets/js/42.0c297929.js"><link rel="prefetch" href="/assets/js/43.24f355f4.js"><link rel="prefetch" href="/assets/js/44.be6f4b64.js"><link rel="prefetch" href="/assets/js/45.5616e444.js"><link rel="prefetch" href="/assets/js/46.178cd27a.js"><link rel="prefetch" href="/assets/js/47.931d1ebf.js"><link rel="prefetch" href="/assets/js/48.e718b233.js"><link rel="prefetch" href="/assets/js/49.6ee87e40.js"><link rel="prefetch" href="/assets/js/5.abf32d94.js"><link rel="prefetch" href="/assets/js/50.bd3c41d0.js"><link rel="prefetch" href="/assets/js/51.6b34c736.js"><link rel="prefetch" href="/assets/js/52.a71ac794.js"><link rel="prefetch" href="/assets/js/53.22cfe720.js"><link rel="prefetch" href="/assets/js/54.f191b562.js"><link rel="prefetch" href="/assets/js/55.ad506e80.js"><link rel="prefetch" href="/assets/js/56.d371d416.js"><link rel="prefetch" href="/assets/js/57.1a245a79.js"><link rel="prefetch" href="/assets/js/58.f895a993.js"><link rel="prefetch" href="/assets/js/59.d5953986.js"><link rel="prefetch" href="/assets/js/6.8e80b6bb.js"><link rel="prefetch" href="/assets/js/60.faef6b7f.js"><link rel="prefetch" href="/assets/js/61.af720eaa.js"><link rel="prefetch" href="/assets/js/62.84c72a46.js"><link rel="prefetch" href="/assets/js/63.dd894062.js"><link rel="prefetch" href="/assets/js/64.3edc5c3b.js"><link rel="prefetch" href="/assets/js/65.92f0c2f1.js"><link rel="prefetch" href="/assets/js/66.71f337d2.js"><link rel="prefetch" href="/assets/js/67.9d77d778.js"><link rel="prefetch" href="/assets/js/68.8e08e272.js"><link rel="prefetch" href="/assets/js/69.0bca181d.js"><link rel="prefetch" href="/assets/js/7.20765c01.js"><link rel="prefetch" href="/assets/js/70.0d1e90cc.js"><link rel="prefetch" href="/assets/js/71.3c62e64f.js"><link rel="prefetch" href="/assets/js/72.1cc8375e.js"><link rel="prefetch" href="/assets/js/73.4791ebfa.js"><link rel="prefetch" href="/assets/js/74.032ab4ac.js"><link rel="prefetch" href="/assets/js/75.1ea0d30b.js"><link rel="prefetch" href="/assets/js/76.7c0afe1a.js"><link rel="prefetch" href="/assets/js/77.c866cb21.js"><link rel="prefetch" href="/assets/js/78.1ecf418e.js"><link rel="prefetch" href="/assets/js/79.d9f2e81f.js"><link rel="prefetch" href="/assets/js/8.6b02f076.js"><link rel="prefetch" href="/assets/js/80.90ad9f35.js"><link rel="prefetch" href="/assets/js/81.c6dd8988.js"><link rel="prefetch" href="/assets/js/82.2c56d1cd.js"><link rel="prefetch" href="/assets/js/83.ef332e9f.js"><link rel="prefetch" href="/assets/js/84.c31cb174.js"><link rel="prefetch" href="/assets/js/85.6c4554f1.js"><link rel="prefetch" href="/assets/js/86.3e7c685c.js"><link rel="prefetch" href="/assets/js/87.aa391666.js"><link rel="prefetch" href="/assets/js/88.dbb53c4d.js"><link rel="prefetch" href="/assets/js/89.b61fc1a2.js"><link rel="prefetch" href="/assets/js/9.4dd99b27.js"><link rel="prefetch" href="/assets/js/90.dd04f094.js"><link rel="prefetch" href="/assets/js/91.932346e8.js"><link rel="prefetch" href="/assets/js/92.7e4e3238.js"><link rel="prefetch" href="/assets/js/93.9e0b9fc3.js"><link rel="prefetch" href="/assets/js/94.fae6c28d.js"><link rel="prefetch" href="/assets/js/95.1506c4a5.js"><link rel="prefetch" href="/assets/js/96.eac0aa58.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6c77b833.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">IPLD Specifications</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/schemas/" class="nav-link">
  IPLD Schemas
</a></div> <a href="https://github.com/ipld/specs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/schemas/" class="nav-link">
  IPLD Schemas
</a></div> <a href="https://github.com/ipld/specs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Specification: HashMap</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/data-structures/hashmap.html#introduction" class="sidebar-link">Introduction</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/data-structures/hashmap.html#useful-references" class="sidebar-link">Useful references</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/data-structures/hashmap.html#summary" class="sidebar-link">Summary</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/data-structures/hashmap.html#structure" class="sidebar-link">Structure</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#parameters" class="sidebar-link">Parameters</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#node-properties" class="sidebar-link">Node properties</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#schema" class="sidebar-link">Schema</a></li></ul></li><li><a href="/data-structures/hashmap.html#algorithm-in-detail" class="sidebar-link">Algorithm in detail</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#get-key" class="sidebar-link">Get(key)</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#set-key-value" class="sidebar-link">Set(key, value)</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#delete-key" class="sidebar-link">Delete(key)</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#keys-values-and-entries" class="sidebar-link">Keys(), Values() and Entries()</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#differences-to-champ" class="sidebar-link">Differences to CHAMP</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#canonical-form" class="sidebar-link">Canonical form</a></li></ul></li><li><a href="/data-structures/hashmap.html#use-as-a-set" class="sidebar-link">Use as a &quot;Set&quot;</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/data-structures/hashmap.html#implementation-defaults" class="sidebar-link">Implementation defaults</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#hashalg" class="sidebar-link">hashAlg</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#bitwidth" class="sidebar-link">bitWidth</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#bucketsize" class="sidebar-link">bucketSize</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#maximum-key-size" class="sidebar-link">Maximum key size</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#inline-values" class="sidebar-link">Inline values</a></li></ul></li><li><a href="/data-structures/hashmap.html#possible-future-improvements-and-areas-for-research" class="sidebar-link">Possible future improvements and areas for research</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#maximum-depth-limitations" class="sidebar-link">Maximum depth limitations</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#hash-algorithm" class="sidebar-link">Hash algorithm</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#buckets" class="sidebar-link">Buckets</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#security" class="sidebar-link">Security</a></li></ul></li><li><a href="/data-structures/hashmap.html#appendix-filecoin-hamt-variant" class="sidebar-link">Appendix: Filecoin HAMT Variant</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#implicit-and-fixed-parameters" class="sidebar-link">Implicit and fixed parameters</a></li><li class="sidebar-sub-header"><a href="/data-structures/hashmap.html#block-layout" class="sidebar-link">Block layout</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="specification-hashmap"><a href="#specification-hashmap" class="header-anchor">#</a> Specification: HashMap</h1> <p><strong>Status: Prescriptive - Draft</strong></p> <ul><li><a href="#Introduction">Introduction</a></li> <li><a href="#Useful-references">Useful references</a></li> <li><a href="#Summary">Summary</a></li> <li><a href="#Structure">Structure</a> <ul><li><a href="#Parameters">Parameters</a></li> <li><a href="#Node-properties">Node properties</a></li> <li><a href="#Schema">Schema</a></li></ul></li> <li><a href="#Algorithm-in-detail">Algorithm in detail</a> <ul><li><a href="#Getkey"><code>Get(key)</code></a></li> <li><a href="#Setkey-value"><code>Set(key, value)</code></a></li> <li><a href="#Deletekey"><code>Delete(key)</code></a></li> <li><a href="#Keys-Values-and-Entries"><code>Keys()</code>, <code>Values()</code> and <code>Entries()</code></a></li> <li><a href="#Differences-to-CHAMP">Differences to CHAMP</a></li> <li><a href="#Canonical-form">Canonical form</a></li></ul></li> <li><a href="#Use-as-a-%22Set%22">Use as a &quot;Set&quot;</a></li> <li><a href="#Implementation-defaults">Implementation defaults</a> <ul><li><a href="#hashAlg"><code>hashAlg</code></a></li> <li><a href="#bitWidth"><code>bitWidth</code></a></li> <li><a href="#bucketSize"><code>bucketSize</code></a></li> <li><a href="#Maximum-key-size">Maximum key size</a></li> <li><a href="#Inline-values">Inline values</a></li></ul></li> <li><a href="#Possible-future-improvements-and-areas-for-research">Possible future improvements and areas for research</a> <ul><li><a href="#Maximum-depth-limitations">Maximum depth limitations</a></li> <li><a href="#Hash-algorithm">Hash algorithm</a></li> <li><a href="#Buckets">Buckets</a></li> <li><a href="#Security">Security</a></li></ul></li> <li><a href="#Appendix-Filecoin-hamt-variant">Appendix: Filecoin HAMT Variant</a> <ul><li><a href="#Implicit-and-fixed-parameters">Implicit and fixed parameters</a></li> <li><a href="#Block-layout">Block layout</a></li></ul></li></ul> <h2 id="introduction"><a href="#introduction" class="header-anchor">#</a> Introduction</h2> <p>The IPLD HashMap provides multi-block key/value storage and implements the Map <a href="/data-model-layer/data-model.html#kinds">kind</a> as an advanced data layout in the IPLD type system.</p> <p>The IPLD HashMap is constructed as a <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie" target="_blank" rel="noopener noreferrer">hash array mapped trie (HAMT)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> with buckets for value storage and <a href="https://michael.steindorfer.name/publications/oopsla15.pdf" target="_blank" rel="noopener noreferrer">CHAMP<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> mutation semantics. The CHAMP invariant and mutation rules provide us with the ability to maintain canonical forms given any set of keys and their values, regardless of insertion order and intermediate data insertion and deletion. Therefore, for any given set of keys and their values, a consistent IPLD HashMap configuration and block encoding, the root node should always produce the same content identifier (CID).</p> <h2 id="useful-references"><a href="#useful-references" class="header-anchor">#</a> Useful references</h2> <ul><li><a href="https://infoscience.epfl.ch/record/64394/files/triesearches.pdf" target="_blank" rel="noopener noreferrer">Fast And Space Efficient Trie Searches<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> by Phil Bagwell, 2000, and <a href="http://lampwww.epfl.ch/papers/idealhashtrees.pdf" target="_blank" rel="noopener noreferrer">Ideal Hash Trees<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> by Phil Bagwell, 2001, introduce the AMT and HAMT concepts.</li> <li><a href="https://michael.steindorfer.name/publications/oopsla15.pdf" target="_blank" rel="noopener noreferrer">CHAMP paper<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> presented at Oopsla 2015 by Steinforder &amp; Vinju</li> <li><a href="https://github.com/msteindorfer/oopsla15-artifact/" target="_blank" rel="noopener noreferrer">Java implementation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> accompanying the original CHAMP paper (see https://github.com/msteindorfer/oopsla15-artifact/blob/master/pdb.values/src/org/eclipse/imp/pdb/facts/util/TrieMap_5Bits.java and other TrieMap files in the same directory).</li> <li><a href="https://blog.acolyer.org/2015/11/27/hamt/" target="_blank" rel="noopener noreferrer">Optimizing Hash-Array Mapped Tries for Fast and Lean Immutable JVM Collections<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> a high-level description of HAMT data structures in general and the specifics of CHAMP.</li> <li>Peergos <a href="https://github.com/Peergos/Peergos/blob/master/src/peergos/shared/hamt/Champ.java" target="_blank" rel="noopener noreferrer">CHAMP<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> implementation</li> <li><a href="https://github.com/rvagg/iamap" target="_blank" rel="noopener noreferrer">IAMap<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> JavaScript implementation of the algorithm</li> <li><a href="https://github.com/rvagg/js-ipld-hashmap" target="_blank" rel="noopener noreferrer">ipld-hashmap<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> JavaScript IPLD frontend to IAMap with a mutable API</li> <li><a href="https://github.com/ipfs/go-hamt-ipld" target="_blank" rel="noopener noreferrer">go-hamt-ipld<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> Filecoin Go HAMT implementation used by the <a href="https://lotu.sh/" target="_blank" rel="noopener noreferrer">Lotus<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> client. See the appendix for how this implementation differs from this specification.</li></ul> <h2 id="summary"><a href="#summary" class="header-anchor">#</a> Summary</h2> <p>The HAMT algorithm is used to build the IPLD HashMap. This algorithm is common across many language standard libraries, particularly on the JVM (Clojure, Scala, Java), to power very efficient in-memory unordered key/value storage data structures. We extend the basic algorithm with buckets for block elasticity and strict mutation rules to ensure canonical form.</p> <p>The HAMT algorithm hashes incoming keys and uses incrementing subsections of that hash at each level of its tree structure to determine the placement of either the entry or a link to a child node of the tree. A <code>bitWidth</code> determines the number of bits of the hash to use for index calculation at each level of the tree such that the root node takes the first <code>bitWidth</code> bits of the hash to calculate an index and as we move lower in the tree, we move along the hash by <code>depth x bitWidth</code> bits. In this way, a sufficiently randomizing hash function will generate a hash that provides a new index at each level of the data structure. An index comprising <code>bitWidth</code> bits will generate index values of  <code>[ 0, 2</code><sup><code>bitWidth</code></sup><code>)</code>. So a <code>bitWidth</code> of <code>8</code> will generate indexes of <code>0</code> to <code>255</code> inclusive.</p> <p>Each node in the tree can therefore hold up to <code>2</code><sup><code>bitWidth</code></sup> elements of data, which we store in an array. In the IPLD HashMap we store entries in buckets. A <code>Set(key, value)</code> mutation where the index generated at the root node for the hash of <code>key</code> denotes an array index that does not yet contain an entry, we create a new bucket and insert the <code>key</code> / <code>value</code> pair entry. In this way, a single node can theoretically hold up to <code>2</code><sup><code>bitWidth</code></sup><code>x bucketSize</code> entries, where <code>bucketSize</code> is the maximum number of elements a bucket is allowed to contain (&quot;collisions&quot;). In practice, indexes do not distribute with perfect randomness so this maximum is theoretical. Entries stored in the node's buckets are stored in <code>key</code>-sorted order.</p> <p>If a <code>Set(key, value)</code> mutation places a new entry in a bucket that already contains <code>bucketSize</code> entries, we overflow to a new child node. A new empty node is created and all existing entries in the bucket, in addition to the new <code>key</code> / <code>value</code> pair entry are inserted into this new node. We increment the <code>depth</code> for calculation of the <code>index</code> from each <code>key</code>'s hash value to calculate the position in the new node's data array. By incrementing <code>depth</code> we move along by <code>bitWidth</code> bits in each <code>key</code>'s hash. With a sufficiently random hash function each <code>key</code> that generated the same <code>index</code> at a previous level should be distributed roughly evenly in the new node's data array, resulting in a node that contains up to <code>bucketSize</code> new buckets.</p> <p>The process of generating <code>index</code> values from <code>bitWidth</code> subsections of the hash values provides us with a depth of up to <code>(digestLength x 8) / bitWidth</code> levels in our tree data structure where <code>digestLength</code> is the number of output bytes generated by the hash function. With each node able to store up to <code>2</code><sup><code>bitWidth</code></sup> child node references and up to <code>bucketSize</code> elements able to be stored in colliding leaf positions we are able to store a very large number of entries. A hash function's randomness will dictate the  even distribution of elements and a hash function's output <code>digestLength</code> will dictate the maximum depth of the tree.</p> <p>A further optimization is applied to reduce the storage requirements of HAMT nodes. The data elements array is only allocated to be long enough to store actual entries: non-empty buckets or links to actual child nodes. An empty or <code>Null</code> array index is not used as a signal that a <code>key</code> does not exist in that node. Instead, the data elements array is compacted by use of a <code>map</code> bitfield where each bit of <code>map</code> corresponds to an <code>index</code> in the node. When an <code>index</code> is generated, the <code>index</code> bit of the <code>map</code> bitfield is checked. If the bit is not set (<code>0</code>), that index does not exist. If the bit is set (<code>1</code>), the value exists in the data elements array. To determine the index of the data elements array, we perform a bit-count (<code>popcount()</code>) on the <code>map</code> bitfield <em>up to</em> the <code>index</code> bit to generate a <code>dataIndex</code>. In this way, the data elements array's total length is equal to <code>popcount(map)</code> (the number of bits set in all of <code>map</code>). If <code>map</code>'s bits are all set then the data elements array will be <code>2</code><sup><code>bitWidth</code></sup> in length, i.e. every position will contain either a bucket or a link to a child node.</p> <p>Insertion of new buckets with <code>Set(key, value)</code> involves splicing in a new element to the data array at the <code>dataIndex</code> position and setting the <code>index</code> bit of the <code>map</code> bitmap. Converting a bucket to a child node leaves the <code>map</code> bit map alone as the <code>index</code> bit still indicates there is an element at that position.</p> <p>A <code>Get(key)</code> operation performs the same hash, <code>index</code> and <code>dataIndex</code> calculation at the root node, traversing into a bucket to find an entry matching <code>key</code> or traversing into child nodes and performing the same <code>index</code> and <code>dataIndex</code> calculation but at an offset of an additional <code>bitWidth</code> bits in the <code>key</code>'s hash.</p> <p>A <code>Delete(key)</code> mutation first locates the element in the same way as <code>Get(key)</code> and if that entry exists, it is removed from the bucket containing it. If the bucket is empty after deletion of the entry, we remove the bucket element completely from the data element array and unsets the <code>index</code> bit of <code>map</code>. If the node containing the deleted element has no links to child nodes and contains <code>bucketSize</code> elements after the deletion, those elements are compacted into a single bucket and placed in the parent node in place of the link to that node. We perform this check on the parent (and recursively if required), thereby transforming the tree into its most compact form, with only buckets in place of nodes that have up to <code>bucketSize</code> entries at all edges. This compaction process combined with the <code>key</code> ordering of entries in buckets produces canonical forms of the data structure for any given set of <code>key</code> / <code>value</code> pairs regardless of their insertion order or whether any intermediate entries have been added and deleted.</p> <p>By default, each node in an IPLD HashMap is stored in a distinct IPLD block and CIDs are used for child node links. The schema and algorithm presented here also allows for inline child nodes rather than links, with read operations able to traverse multiple nodes within a single block where they are inlined. The production of inlined IPLD HashMaps is left unspecified and users should be aware that inlining breaks canonical form guarantees.</p> <h2 id="structure"><a href="#structure" class="header-anchor">#</a> Structure</h2> <h3 id="parameters"><a href="#parameters" class="header-anchor">#</a> Parameters</h3> <p>Configurable parameters for any given IPLD HashMap:</p> <ul><li><code>hashAlg</code>: The hash algorithm applied to keys in order to evenly distribute entries throughout the data structure. The algorithm is chosen based on speed, <code>digestLength</code> and randomness properties (but it must be available to the reader, hence the need for shared defaults, see below).</li> <li><code>bitWidth</code>: The number of bits to use at each level of the data structure for determining the index of the entry or a link to the next level of the data structure to continue searching. The equation <code>2</code><sup><code>bitWidth</code></sup> yields the arity of the HashMap nodes, i.e. the number of storage locations for buckets and/or links to child nodes.</li> <li><code>bucketSize</code>: The maximum array size of entry storage buckets such that exceeding <code>bucketSize</code> causes the creation of a new child node to replace entry storage.</li></ul> <h3 id="node-properties"><a href="#node-properties" class="header-anchor">#</a> Node properties</h3> <p>Each node in a HashMap data structure contains:</p> <ul><li><code>data</code>: An Array, with a length of one to <code>2</code><sup><code>bitWidth</code></sup>.</li> <li><code>map</code>: A bitfield, stored as Bytes, where the first <code>2</code><sup><code>bitWidth</code></sup> bits are used to indicate whether a bucket or child node link is present at each possible index of the node.</li></ul> <p>An important property of a HAMT is that the <code>data</code> array only contains active elements. Indexes in a node that do not contain any values (in buckets or links to child nodes) are not stored and the <code>map</code> bitfield is used to determine the <code>data</code> whether values are present and the array index of present values using a <a href="https://en.wikipedia.org/wiki/Hamming_weight" target="_blank" rel="noopener noreferrer"><code>popcount()</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. This allows us to store a maximally compacted <code>data</code> array for each node.</p> <h3 id="schema"><a href="#schema" class="header-anchor">#</a> Schema</h3> <p>The <strong>root block</strong> of an IPLD HashMap contains the same properties as all other blocks, in addition to configuration data that dictates how the algorithm below traverses and mutates the data structure.</p> <p>See <a href="../../schemas">IPLD Schemas</a> for a definition of this format.</p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token comment"># Root node layout</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">HashMapRoot</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  hashAlg Int
  bucketSize Int
  hamt HashMapNode
<span class="token punctuation">}</span>

<span class="token comment"># Non-root node layout</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">HashMapNode</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  map Bytes
  data <span class="token punctuation">[</span> Element <span class="token punctuation">]</span>
<span class="token representation">} <span class="token builtin">representation</span></span> tuple

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Element</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
  <span class="token punctuation">|</span> <span class="token punctuation">&amp;</span>HashMapNode link
  <span class="token punctuation">|</span> Bucket list
<span class="token representation">} <span class="token builtin">representation</span></span> kinded

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Bucket</span></span> <span class="token punctuation">[</span> BucketEntry <span class="token punctuation">]</span>

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">BucketEntry</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  key Bytes
  value Any
<span class="token representation">} <span class="token builtin">representation</span></span> tuple
</code></pre></div><p>Notes:</p> <ul><li><code>hashAlg</code> in the root block is an integer code identifying the hash algorithm used for mapping keys to their positions in the structure. The code should correspond to a <a href="https://github.com/multiformats/multihash" target="_blank" rel="noopener noreferrer">multihash<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> code as found in the <a href="https://github.com/multiformats/multicodec/blob/master/table.csv" target="_blank" rel="noopener noreferrer">multiformats table<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</li> <li><code>bitWidth</code> in the root block must be at least <code>3</code>, making the minimum <code>map</code> size 1 byte.</li> <li><code>bitWidth</code> is not present in the root block as it is inferred from the size of the <code>map</code> byte array with the equation <code>log2(byteLength(map) x 8)</code>, being the inverse of the <code>map</code> size equation <code>2</code><sup><code>bitWidth</code></sup><code>/ 8</code>. For lower-level languages, you can use the cheaper equivalent <code>trailingZeroBits(byteLength(map)) + 3</code>.</li> <li><code>bucketSize</code> in the root block must be at least <code>1</code>.</li> <li>Keys are stored in <code>Byte</code> form.</li> <li><code>Element</code> is a kinded union that supports storing either a <code>Bucket</code> (as kind <code>list</code>) or a link to a child node (as kind <code>link</code>).</li></ul> <h2 id="algorithm-in-detail"><a href="#algorithm-in-detail" class="header-anchor">#</a> Algorithm in detail</h2> <h3 id="get-key"><a href="#get-key" class="header-anchor">#</a> <code>Get(key)</code></h3> <ol><li>Set a <code>depth</code> value to <code>0</code>, indicating the root block</li> <li>The <code>key</code> is hashed, using <code>hashAlg</code>.</li> <li>Take the left-most <code>bitWidth</code> bits, offset by <code>depth x bitWidth</code>, from the hash to form an <code>index</code>. At each level of the data structure, we increment the section of bits we take from the hash so that the <code>index</code> comprises a different set of bits as we move down.</li> <li>If the <code>index</code> bit in the node's <code>map</code> is <code>0</code>, we can be certain that the <code>key</code> does not exist in this data structure, so return an empty value (as appropriate for the implementation platform).</li> <li>If the <code>index</code> bit in the node's <code>map</code> is <code>1</code>, the value may exist. Perform a <code>popcount()</code> on the <code>map</code> up to <code>index</code> such that we count the number of <code>1</code> bits up to the <code>index</code> bit-position. This gives us <code>dataIndex</code>, an index in the <code>data</code> array to look up the value or insert a new bucket.</li> <li>If the <code>dataIndex</code> element of <code>data</code> contains a link (CID) to a child block, increment <code>depth</code> and repeat with the child node identified by the link from step <strong>3</strong>.</li> <li>If the <code>dataIndex</code> element of <code>data</code> contains a bucket (array), iterate through entries in the bucket:
<ol><li>If an entry has the <code>key</code> we are looking for, return the <code>value</code>.</li> <li>If no entries contain the <code>key</code> we are looking for, return an empty value (as appropriate for the implementation platform). Note that the bucket will be sorted by <code>key</code> so a scan can stop when a scan yields keys greater than <code>key</code>.</li></ol></li></ol> <h3 id="set-key-value"><a href="#set-key-value" class="header-anchor">#</a> <code>Set(key, value)</code></h3> <ol><li>Set a <code>depth</code> value to <code>0</code>, indicating the root block</li> <li>The <code>key</code> is hashed, using <code>hashAlg</code>.</li> <li>Take the left-most <code>bitWidth</code> bits, offset by <code>depth x bitWidth</code>, from the hash to form an <code>index</code>. At each level of the data structure, we increment the section of bits we take from the hash so that the <code>index</code> comprises a different set of bits as we move down.</li> <li>If the <code>index</code> bit in the node's <code>map</code> is <code>0</code>, a new bucket needs to be created at the current node. If the <code>index</code> bit in the node's <code>map</code> is <code>1</code>, a value exists for this <code>index</code> in the node's <code>data</code> which may be a bucket (which may be full) or may be a link to a child node.</li> <li>Perform a <code>popcount()</code> on the <code>map</code> up to <code>index</code> such that we count the number of <code>1</code> bits up to the <code>index</code> bit-position. This gives us <code>dataIndex</code>, an index in the <code>data</code> array to look up the value or insert a new bucket.</li> <li>If the <code>index</code> bit in the node's <code>map</code> is <code>0</code>:
<ol><li>Mutate the current node (create a copy).</li> <li>Insert a new element in <code>data</code> at <code>dataIndex</code> containing an new bucket (array) with a single entry for the <code>key</code> / <code>value</code> pair.</li> <li>Create a CID for the mutated node.</li> <li>If <code>depth</code> is <code>0</code>, the CID represents the new root block of the HashMap.</li> <li>If <code>depth</code> is greater than <code>0</code>:
<ol><li>Mutate the node's parent</li> <li>Record the new CID of the mutated child in the appropriate position of the mutated parent's <code>data</code> array.</li> <li>Recursively proceed, by recording the new CIDs of each node in a mutated copy of its parent node until <code>depth</code> of <code>0</code> where we produce the the new root block and its CID.</li></ol></li></ol></li> <li>If the <code>index</code> bit in the node's <code>map</code> is <code>1</code>:
<ol><li>If the <code>dataIndex</code> element of <code>data</code> contains a link (CID) to a child node, increment <code>depth</code>:
<ol><li>If <code>(depth x bitWidth) / 8</code> is now greater than the <code>digestLength</code>, a &quot;max collisions&quot; failure has occurred and an error state should be returned to the user.</li> <li>If <code>(depth x bitWidth) / 8</code> is less than the number of bytes in the hash, repeat with the child node identified in step <strong>3</strong>.</li></ol></li> <li>If the <code>dataIndex</code> element of <code>data</code> contains a bucket (array) and the bucket's size is less than <code>bucketSize</code>:
<ol><li>Mutate the current node (create a copy).</li> <li>If <code>key</code> is already present in the new bucket, change its corresponding <code>value</code> to the new one. Otherwise, insert the <code>key</code> / <code>value</code> pair at a position sorted by <code>key</code> such that all entries in the bucket are ordered respective to their <code>key</code>s. This helps ensure canonical form.</li> <li>Proceed to create new CIDs for the current block and each parent as per step <strong>6.c</strong>. until we have a new root block and its CID.</li></ol></li> <li>If the <code>dataIndex</code> element of <code>data</code> contains a bucket (array) and the bucket's size is <code>bucketSize</code>:
<ol><li>Create a new empty node</li> <li>For each element of the bucket, perform a <code>Set(key, value)</code> on the new empty node with a <code>depth</code> set to <code>depth + 1</code>, proceeding from step <strong>2</strong>. This should create a new node with <code>bucketSize</code> elements distributed approximately evenly through its <code>data</code> array. This operation will only result in more than one new node being created if all <code>key</code>s being set have the same <code>bitWidth</code> bits of their hashes at <code>bitWidth</code> position <code>depth + 1</code> (and so on). A sufficiently random hash algorithm should prevent this from occuring.</li> <li>Create a CID for the new child node.</li> <li>Mutate the current node (create a copy)</li> <li>Replace <code>dataIndex</code> of <code>data</code> with a link to the new child node.</li> <li>Proceed to create new CIDs for the current block and each parent as per step <strong>6.c</strong>. until we have a new root block and its CID.</li></ol></li></ol></li></ol> <h3 id="delete-key"><a href="#delete-key" class="header-anchor">#</a> <code>Delete(key)</code></h3> <p>The deletion algorithm below is presented as an iterative operation. It can also be usefully conceived of as a recursive algorithm, which is particularly helpful in the case of node collapsing. See section &quot;4.2 Deletion Algorithm&quot; of the <a href="https://michael.steindorfer.name/publications/oopsla15.pdf" target="_blank" rel="noopener noreferrer">CHAMP paper<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> for a description of this algorithm. Note that the linked paper does not make use of buckets so note the importance of counting entries in a node and comparing to <code>bucketSize</code> in the algorithm below.</p> <ol><li>Set a <code>depth</code> value to <code>0</code>, indicating the root block</li> <li>The <code>key</code> is hashed, using <code>hashAlg</code>.</li> <li>Take the left-most <code>bitWidth</code> bits, offset by <code>depth x bitWidth</code>, from the hash to form an <code>index</code>. At each level of the data structure, we increment the section of bits we take from the hash so that the <code>index</code> comprises a different set of bits as we move down.</li> <li>If the <code>index</code> bit in the node's <code>map</code> is <code>0</code>, we can be certain that the <code>key</code> does not exist in this data structure, so there is no need to proceed.</li> <li>If the <code>index</code> bit in the node's <code>map</code> is <code>1</code>, the value may exist. Perform a <code>popcount()</code> on the <code>map</code> up to <code>index</code> such that we count the number of <code>1</code> bits up to the <code>index</code> bit-position. This gives us <code>dataIndex</code>, an index in the <code>data</code> array to look up the value or insert a new bucket.</li> <li>If the <code>dataIndex</code> element of <code>data</code> contains a link (CID) to a child node, increment <code>depth</code> and repeat with the child node identified in step <strong>3</strong>.</li> <li>If the <code>dataIndex</code> element of <code>data</code> contains a bucket (array), iterate through entries in the bucket:
<ol><li>If no entries contain the <code>key</code> we are looking for, there is no need to proceed. Note that the bucket will be sorted by <code>key</code> so a scan can stop when a scan yields keys greater than <code>key</code>.</li> <li>If an entry has the <code>key</code> we are looking for, we need to remove it and possibly collapse this node and any number of parent nodes depending on the number of entries remaining. This helps ensure canonical form. Note that there are two possible states below, if neither case matches the state of the current node, we have not satisfied the invariant and the tree is not in a canonical state (i.e. something has failed):
<ol><li>If <code>depth</code> is <code>0</code> (the root node) or there are links in the <code>data</code> array for this node (it has child nodes) or the number of entries across all buckets in this node is currently greater than <code>bucketSize + 1</code>, we don't need to collapse this node into its parent, but can simply remove the entry from its bucket.
<ol><li>Mutate the current node (create a copy)
<ol><li>If the bucket located at <code>dataIndex</code> of the <code>data</code> array contains more than one element, remove the entry from the bucket at <code>dataIndex</code> of <code>data</code> (the remaining elements must remain sorted by <code>key</code>).</li> <li>If the bucket located at <code>dataIndex</code> of the <code>data</code> array contains only one element:
<ol><li>Remove <code>dataIndex</code> of <code>data</code> (such that <code>data</code> now has one less element)</li> <li>Set the <code>index</code> bit of <code>map</code> to <code>0</code></li></ol></li> <li>Create a CID for the new node with the entry removed.</li> <li>Record the new CID of the mutated child in the appropriate position of the mutated parent's <code>data</code> array.</li> <li>Recursively proceed, by recording the new CIDs of each node in a mutated copy of its parent node until <code>depth</code> of <code>0</code> where we produce the the new root block and its CID.</li></ol></li></ol></li> <li>If <code>depth</code> is not <code>0</code> (not the root node) and there are no links in the <code>data</code> array for this node (it has no child nodes) and the number of entries across all buckets in this node is currently equal to <code>bucketSize + 1</code>, then this node needs to be collapsed into a single bucket, of <code>bucketSize</code> once the entry being deleted is removed, and replaced in its parent's <code>data</code> array in place of the link to this node.
<ol><li>Create a new bucket and place all entries in the node except for the one being removed into the new bucket. The new bucket now contains all of the entries from the node and will be used to replace the node in the parent.</li> <li>Mutate the parent node (create a copy).</li> <li>Replace the link to the node in the parent's <code>data</code> array with the newly created bucket. (Note the position in the parent's <code>data</code> array will be dependendent on the <code>key</code>'s <code>index</code> at <code>depth - 1</code> and the <code>dataIndex</code> calculated from the parent's <code>map</code>).</li> <li>Create a CID for the new parent.</li> <li>If the parent is at a <code>depth</code> of <code>0</code>, i.e. the parent node, the CID represents the new root node.</li> <li>If the parent is not at <code>depth</code> of <code>0</code>, repeat from step <strong>7.2</strong> with the parent node. This process should repeat up the tree all the way to <code>depth</code> of <code>0</code>, potentially collapsing more than one node into its parent in the process.</li></ol></li></ol></li></ol></li></ol> <h3 id="keys-values-and-entries"><a href="#keys-values-and-entries" class="header-anchor">#</a> <code>Keys()</code>, <code>Values()</code> and <code>Entries()</code></h3> <p>These collection-spanning iteration operations are <strong>optional</strong> for implementations.</p> <p>The storage order of entries in an IPLD HashMap is entirely dependent on the hash algorithm and <code>bitWidth</code>. Therefore IPLD HashMaps are considered to be random for practical purposes (as opposed to ordered-by-construction or ordered-by-comparator, see <a href="https://github.com/ipld/specs/blob/master/data-structures/multiblock-collections.md#collection-types%5D" target="_blank" rel="noopener noreferrer">IPLD Multi-block Collections / Collection types<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>). It is left to the implementation to decide the tree-traversal order and algorithm used to iterate over entries.</p> <p>An implementation should only emit any given <code>key</code>, <code>value</code> or <code>key</code> / <code>value</code> entry pair once per iteration.</p> <h3 id="differences-to-champ"><a href="#differences-to-champ" class="header-anchor">#</a> Differences to CHAMP</h3> <p>This algorithm differs from CHAMP in the following ways:</p> <ol><li>CHAMP separates <code>map</code> into <code>datamap</code> and <code>nodemap</code> for referencing local data elements and local references to child nodes. The <code>data</code> array is then split in half such that data elements are stored from the left and the child node links are stored from the right with a reverse index. This allows important speed and cache-locality optimizations for fully in-memory data structures but those optimizations are not present, or make negligible impact in a distributed data structure.</li> <li>CHAMP does not make use, of buckets, nor do common implementations of HAMTs on the JVM (e.g. Clojure, Scala, Java). Storing only entries and links removes the need for an iterative search and compare within buckets and allows direct traversal to the entries required. This is effective for in-memory data structures but is less useful when performing block-by-block traversal with distributed data structures where packing data to reduce traversals may be more important.</li></ol> <h3 id="canonical-form"><a href="#canonical-form" class="header-anchor">#</a> Canonical form</h3> <p>To achieve canonical forms for any given set of <code>key</code> / <code>value</code> pairs, we note the following properties in the algorithm:</p> <ol><li>We must keep buckets sorted by <code>key</code> during both insertion and deletion operations.</li> <li>We must retain an invariant that states that no non-root node may contain, either directly or via links through child nodes, less than <code>bucketSize + 1</code> entries. By applying this strictly during the deletion process, we can generalize that no non-root node without links to child nodes may contain less than <code>bucketSize + 1</code> entries. Any non-root node in the tree breaking this rule during the deletion process must have its entries collapsed into a single bucket of <code>bucketSize</code> length (i.e. without the entry being removed) and inserted into its parent node in place of the link to the impacted node. We continue to apply this rule recursively up the tree, potentially collapsing additional nodes into their parents.</li></ol> <h2 id="use-as-a-set"><a href="#use-as-a-set" class="header-anchor">#</a> Use as a &quot;Set&quot;</h2> <p>The IPLD HashMap can be repurposed as a &quot;Set&quot;: a data structure that holds only unique <code>key</code>s. Every <code>value</code> in a <code>Set(key, value)</code> mutation is fixed to some trivial value, such as <code>true</code> or <code>1</code>. <code>Has(key)</code> operations are then simply a <code>Get(key)</code> operation that asserts that a value was returned.</p> <h2 id="implementation-defaults"><a href="#implementation-defaults" class="header-anchor">#</a> Implementation defaults</h2> <p>Implements need to ship with <em>sensible defaults</em> and be able to create HashMaps without users requiring intimate knowledge of the algorithm and the all of the trade-offs (although such knowledge will help in their optimal use).</p> <p>These defaults are descriptive rather than prescriptive. New implementations may opt for different defaults, while acknowledging that they will produce different graphs (and therefore CIDs) for the same data as with the defaults listed below. Users may also be provided with facilities to override these defaults to suit their use cases where these defaults do not produce optimal outcomes.</p> <h3 id="hashalg"><a href="#hashalg" class="header-anchor">#</a> <code>hashAlg</code></h3> <ul><li>The default supported hash algorithm for writing IPLD HashMaps is the x64 form of the 128-bit <a href="https://github.com/aappleby/smhasher" target="_blank" rel="noopener noreferrer">MurmurHash3<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> (identified by the multihash name <a href="https://github.com/multiformats/multicodec/blob/master/table.csv" target="_blank" rel="noopener noreferrer">'murmur3-128'<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>). Note the x86 form will produce different output so should not be confused with the x64 form. Additionally, <a href="https://cimi.io/murmurhash3js-revisited/" target="_blank" rel="noopener noreferrer">some JavaScript implementations<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> do not correctly decompose UTF-8 strings into their constituent bytes for hashing so will not produce portable results.</li> <li>Pluggability of hash algorithms is encouraged to allow users to switch switch if their use-case has a compelling reason. Such pluggability requires the supply of an algorithm that takes Bytes and returns Bytes. Users changing the hash algorithm need to be aware that such pluggability restricts the ability of other implementations to read their data since matching hash algorithms also need to be supplied on the read-side.</li></ul> <h3 id="bitwidth"><a href="#bitwidth" class="header-anchor">#</a> <code>bitWidth</code></h3> <ul><li>The default <code>bitWidth</code> is <code>8</code> for writing IPLD HashMaps. This value yields a <code>data</code> length of <code>2</code><sup><code>8</code></sup><code>=256</code>. <code>8</code> is also simple in most programming languages to slice off a list of bytes since it's a simple byte-index. However, implementations should be designed to support different <code>bitWidth</code>s encountered when reading IPLD HashMaps. The minimum supported <code>bitWidth</code> must be <code>3</code> (for a 1-byte <code>map</code>). No maximum is specified, however implementers should be aware that interoperability problems may arise with large <code>bitWidth</code> values. For lower-level languages, you can work out the <code>data</code> length via the equivalent <code>1 &lt;&lt; (bitWidth - 3)</code>.</li></ul> <h3 id="bucketsize"><a href="#bucketsize" class="header-anchor">#</a> <code>bucketSize</code></h3> <ul><li>The default <code>bucketSize</code> is <code>3</code> for writing IPLD HashMaps. Combined with a <code>bitWidth</code> of <code>8</code> this yields a theoretical maximally full node (with no child nodes) of <code>256 x 3 = 768</code> <code>key</code> / <code>value</code> pairs. The minimum supported <code>bucketSize</code> should be <code>1</code>. No maximum is specified, however implementers should be aware that interoperability problems may arise with very large <code>bucketSize</code> values.</li></ul> <h3 id="maximum-key-size"><a href="#maximum-key-size" class="header-anchor">#</a> Maximum key size</h3> <p>Implementations may impose a maximum key size for writing IPLD HashMaps. Reading IPLD HashMaps with keys larger than the maximum they define for reading is not defined in this specification.</p> <h3 id="inline-values"><a href="#inline-values" class="header-anchor">#</a> Inline values</h3> <p>Implementations may choose to write all values in separate blocks and store only CIDs in <code>value</code> locations in an IPLD HashMap. Alternatively, a rough size heuristic may also be applied to make a decision regarding inline versus linked blocks. Or this decision could be left up to the user via some API choice. As storage of arbitrary kinds in <code>value</code> locations is allowed by this specification, implementations should support this for read operations.</p> <h2 id="possible-future-improvements-and-areas-for-research"><a href="#possible-future-improvements-and-areas-for-research" class="header-anchor">#</a> Possible future improvements and areas for research</h2> <h3 id="maximum-depth-limitations"><a href="#maximum-depth-limitations" class="header-anchor">#</a> Maximum depth limitations</h3> <p>One aim of IPLD collections is to support arbitrarily large data sets. This specification does not meet this requirement as there is a maximum depth imposed by the number of bits in a hash.</p> <p>Future iterations of this specification may explore:</p> <ul><li>Default hash algorithm(s) outputting a larger number of bits (e.g. a cryptographic hash function such as SHA2-256).</li> <li>Resetting the <code>index</code> calculation to take bits from the start of the hash once maximum-depth is reached, allowing or theoretically infinite depth data structures.</li> <li>Allowing flexibility in <code>bucketSize</code> at maximum-depth nodes.</li></ul> <h3 id="hash-algorithm"><a href="#hash-algorithm" class="header-anchor">#</a> Hash algorithm</h3> <ul><li>The use of MurmurHash3 x64 128-bit needs further research and modelling. There may be more appropriate default algorithms for the IPLD HashMap with more optimal characteristics (speed, randomness, suitability for a web environment, etc.).</li> <li>There may arise a demonstrated need to encode a nonce or key in the root block to support keyed hash algorithms.</li></ul> <h3 id="buckets"><a href="#buckets" class="header-anchor">#</a> Buckets</h3> <p>The impact on the data structure layout imposed by the use of buckets in the IPLD HashMap needs to be researched and the costs and benefits properly quantified. It is possible that buckets may be removed from a future version of this specification depending on the results of such research.</p> <h3 id="security"><a href="#security" class="header-anchor">#</a> Security</h3> <p>As yet, there is no known hash collision attack vector against IPLD data structures. There may conceivably be use cases where user-input is able to impact <code>key</code>s and collisions against a chosen <code>hashAlg</code> are practical. In such cases, an IPLD HashMap could be built whereby it reaches its maximum depth of <code>(digestLength x 8) / bitWidth</code> quickly and further colliding additions cause errors and possible denial of service. The current use-cases of IPLD do not lend themselves to denial of service attacks of this kind. Further practical application and research may change this understanding and dictate the need for hash algorithms with large byte output and/or cryptographic hash algorithms without known collision flaws.</p> <h2 id="appendix-filecoin-hamt-variant"><a href="#appendix-filecoin-hamt-variant" class="header-anchor">#</a> Appendix: Filecoin HAMT Variant</h2> <p>The <a href="https://filecoin-project.github.io/specs/" target="_blank" rel="noopener noreferrer">Filecoin Project blockchain<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> makes use of a HAMT that uses the same HAMT with buckets and CHAMP mutation semantics as outlined in this document. It encodes directly as <a href="/block-layer/codecs/dag-cbor.html">DAG-CBOR</a> but uses a different block layout to the one specified here. This section documents the specific ways that the Filecoin HAMT variant differs from this specification. IPLD HashMap implementations may be able to implement a form that provides compatibility with Filecoin when requested by the user.</p> <p>The reference Go implementation for the Filecoin HAMT is used by the <a href="https://lotu.sh/" target="_blank" rel="noopener noreferrer">Lotus<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> client and is available at <a href="https://github.com/ipfs/go-hamt-ipld" target="_blank" rel="noopener noreferrer">https://github.com/ipfs/go-hamt-ipld<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <h3 id="implicit-and-fixed-parameters"><a href="#implicit-and-fixed-parameters" class="header-anchor">#</a> Implicit and fixed parameters</h3> <p>The Filecoin HAMT <em>does not</em> use an explicit root block (<code>HashMapRoot</code>) to encode its parameters within the data. Instead it is expected that consumers of the data understand the parameters from a combination of the Filecoin specification and versioning of the blockchain over time. All HAMT nodes take the same form, there is no differentiation for a root node and an implementation must bring implicit parameters when decoding each node.</p> <ul><li><code>hashAlg</code>: The hash algorithm used by the Filecoin HAMT is SHA2-256.</li> <li><code>bitWidth</code>: The Filecoin HAMT fixes the bit width to <code>5</code>, meaning that each node of the HAMT can contain up to <code>2</code><sup><code>5</code></sup> (<code>32</code>) elements containing either buckets or links to child nodes.</li> <li><code>bucketSize</code>: The Filecoin HAMT fixes the maximum length of its buckets to <code>3</code>, meaning a maximally full HAMT leaf node can contain <code>32 x 3</code> (<code>96</code>) key/value pairs.</li></ul> <h3 id="block-layout"><a href="#block-layout" class="header-anchor">#</a> Block layout</h3> <p>An IPLD schema representing the Filecoin HAMT varies from the IPLD HashMap <a href="#Schema">schema</a> so any implementation needing to read Filecoin HAMT blocks will need to handle its specific layout:</p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">HashMapNode</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  map Bytes
  data <span class="token punctuation">[</span> Element <span class="token punctuation">]</span>
<span class="token representation">} <span class="token builtin">representation</span></span> tuple

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Element</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
  <span class="token punctuation">|</span> <span class="token punctuation">&amp;</span>HashMapNode <span class="token string">&quot;0&quot;</span>
  <span class="token punctuation">|</span> Bucket <span class="token string">&quot;1&quot;</span>
<span class="token representation">} <span class="token builtin">representation</span></span> keyed

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Bucket</span></span> <span class="token punctuation">[</span> BucketEntry <span class="token punctuation">]</span>

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">BucketEntry</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  key Bytes
  value Any
<span class="token representation">} <span class="token builtin">representation</span></span> tuple
</code></pre></div><p>There is currently no limitation on the types available for storage as <code>value</code>s as long as they can be decoded from the bytes. In practice, the Filecoin HAMT is used to store inline objects rather than links to objects.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/ipld/specs/edit/master/data-structures/hashmap.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">11/18/2020, 4:25:14 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e54c04cf.js" defer></script><script src="/assets/js/2.fa483b33.js" defer></script><script src="/assets/js/38.8f0ab58a.js" defer></script>
  </body>
</html>
