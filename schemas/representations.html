<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Representations of IPLD Schema Kinds | IPLD Specifications</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="Specifications for the Inter-planetary Linked Data project">
    <link rel="preload" href="/assets/css/0.styles.af5e56d4.css" as="style"><link rel="preload" href="/assets/js/app.20f730e6.js" as="script"><link rel="preload" href="/assets/js/2.2d6107ed.js" as="script"><link rel="preload" href="/assets/js/74.97b91c2f.js" as="script"><link rel="prefetch" href="/assets/js/10.36f99d26.js"><link rel="prefetch" href="/assets/js/11.59f24366.js"><link rel="prefetch" href="/assets/js/12.0d0ab97f.js"><link rel="prefetch" href="/assets/js/13.cfaa19c7.js"><link rel="prefetch" href="/assets/js/14.fd2903ea.js"><link rel="prefetch" href="/assets/js/15.8e535de7.js"><link rel="prefetch" href="/assets/js/16.8535e938.js"><link rel="prefetch" href="/assets/js/17.28d6338b.js"><link rel="prefetch" href="/assets/js/18.d035f88f.js"><link rel="prefetch" href="/assets/js/19.f4aedf5a.js"><link rel="prefetch" href="/assets/js/20.2f4b96a1.js"><link rel="prefetch" href="/assets/js/21.c06b674e.js"><link rel="prefetch" href="/assets/js/22.a5474984.js"><link rel="prefetch" href="/assets/js/23.9520c5cd.js"><link rel="prefetch" href="/assets/js/24.f78ef168.js"><link rel="prefetch" href="/assets/js/25.9dc1e40c.js"><link rel="prefetch" href="/assets/js/26.e53eaca3.js"><link rel="prefetch" href="/assets/js/27.3e4cf2aa.js"><link rel="prefetch" href="/assets/js/28.816fe4e3.js"><link rel="prefetch" href="/assets/js/29.cd52a63f.js"><link rel="prefetch" href="/assets/js/3.067b1da1.js"><link rel="prefetch" href="/assets/js/30.d6ef6a85.js"><link rel="prefetch" href="/assets/js/31.831bbb05.js"><link rel="prefetch" href="/assets/js/32.bfb50562.js"><link rel="prefetch" href="/assets/js/33.5f99915b.js"><link rel="prefetch" href="/assets/js/34.62ee9991.js"><link rel="prefetch" href="/assets/js/35.8a4b296e.js"><link rel="prefetch" href="/assets/js/36.a9ad770e.js"><link rel="prefetch" href="/assets/js/37.9f8deb1c.js"><link rel="prefetch" href="/assets/js/38.c96f42fa.js"><link rel="prefetch" href="/assets/js/39.0d3d9d13.js"><link rel="prefetch" href="/assets/js/4.ee4abcf1.js"><link rel="prefetch" href="/assets/js/40.f7327dc4.js"><link rel="prefetch" href="/assets/js/41.85e040d3.js"><link rel="prefetch" href="/assets/js/42.185ebaf8.js"><link rel="prefetch" href="/assets/js/43.32f51fb1.js"><link rel="prefetch" href="/assets/js/44.097cea13.js"><link rel="prefetch" href="/assets/js/45.8a99faf7.js"><link rel="prefetch" href="/assets/js/46.eb54faa0.js"><link rel="prefetch" href="/assets/js/47.129e4258.js"><link rel="prefetch" href="/assets/js/48.d822c0c4.js"><link rel="prefetch" href="/assets/js/49.9f9b1d03.js"><link rel="prefetch" href="/assets/js/5.02f47f72.js"><link rel="prefetch" href="/assets/js/50.fef10e7e.js"><link rel="prefetch" href="/assets/js/51.9a481eb8.js"><link rel="prefetch" href="/assets/js/52.71ed10d7.js"><link rel="prefetch" href="/assets/js/53.cdbf0b81.js"><link rel="prefetch" href="/assets/js/54.c1f38729.js"><link rel="prefetch" href="/assets/js/55.c9452da2.js"><link rel="prefetch" href="/assets/js/56.d6d25929.js"><link rel="prefetch" href="/assets/js/57.e20626b6.js"><link rel="prefetch" href="/assets/js/58.c8f9c033.js"><link rel="prefetch" href="/assets/js/59.c1b155f2.js"><link rel="prefetch" href="/assets/js/6.d29fd7af.js"><link rel="prefetch" href="/assets/js/60.32d4379a.js"><link rel="prefetch" href="/assets/js/61.33804ab8.js"><link rel="prefetch" href="/assets/js/62.592be5de.js"><link rel="prefetch" href="/assets/js/63.a7233cf1.js"><link rel="prefetch" href="/assets/js/64.8e3d382c.js"><link rel="prefetch" href="/assets/js/65.6d9f8dfa.js"><link rel="prefetch" href="/assets/js/66.0bc3a5f5.js"><link rel="prefetch" href="/assets/js/67.fc1c3bd3.js"><link rel="prefetch" href="/assets/js/68.d62191bf.js"><link rel="prefetch" href="/assets/js/69.d9131a8b.js"><link rel="prefetch" href="/assets/js/7.aac06655.js"><link rel="prefetch" href="/assets/js/70.1c2d30fc.js"><link rel="prefetch" href="/assets/js/71.ca26ea64.js"><link rel="prefetch" href="/assets/js/72.d290d096.js"><link rel="prefetch" href="/assets/js/73.dc0b6f75.js"><link rel="prefetch" href="/assets/js/75.1ae7617b.js"><link rel="prefetch" href="/assets/js/76.3055e13e.js"><link rel="prefetch" href="/assets/js/8.623a5dd0.js"><link rel="prefetch" href="/assets/js/9.05249855.js">
    <link rel="stylesheet" href="/assets/css/0.styles.af5e56d4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">IPLD Specifications</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/schemas/" class="nav-link router-link-active">
  IPLD Schemas
</a></div> <a href="https://github.com/ipld/specs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/schemas/" class="nav-link router-link-active">
  IPLD Schemas
</a></div> <a href="https://github.com/ipld/specs" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>IPLD Schemas</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/schemas/goals.html" class="sidebar-link">Goals</a></li><li><a href="/schemas/feature-summary.html" class="sidebar-link">Feature Summary</a></li><li><a href="/schemas/introduction.html" class="sidebar-link">Introduction</a></li><li><a href="/schemas/authoring-guide.html" class="sidebar-link">Authoring Guide</a></li><li><a href="/schemas/links.html" class="sidebar-link">Links and IPLD Schemas</a></li><li><a href="/schemas/schema-kinds.html" class="sidebar-link">IPLD Schema Kinds</a></li><li><a href="/schemas/representations.html" aria-current="page" class="active sidebar-link">Representations</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/schemas/representations.html#available-representation-strategies" class="sidebar-link">Available Representation Strategies</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#representation-strategy-reference" class="sidebar-link">Representation Strategy Reference</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/schemas/representations.html#struct-map-representation" class="sidebar-link">Struct map Representation</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#struct-tuple-representation" class="sidebar-link">Struct tuple Representation</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#struct-stringpairs-representation" class="sidebar-link">Struct stringpairs Representation</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#struct-stringjoin-representation" class="sidebar-link">Struct stringjoin Representation</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#struct-listpairs-representation" class="sidebar-link">Struct listpairs Representation</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#map-map-representation" class="sidebar-link">Map map Representation</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#map-stringpairs-representation" class="sidebar-link">Map stringpairs Representation</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#map-listpairs-representation" class="sidebar-link">Map listpairs Representation</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#union-keyed-representation" class="sidebar-link">Union keyed Representation</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#union-kinded-representation" class="sidebar-link">Union kinded Representation</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#union-envelope-representation" class="sidebar-link">Union envelope Representation</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#union-inline-representation" class="sidebar-link">Union inline Representation</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#union-byteprefix-representation" class="sidebar-link">Union byteprefix Representation</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#enum-string-representation" class="sidebar-link">Enum string Representation</a></li><li class="sidebar-sub-header"><a href="/schemas/representations.html#enum-int-representation" class="sidebar-link">Enum int Representation</a></li></ul></li></ul></li><li><a href="/schemas/advanced-layouts.html" class="sidebar-link">Advanced Layouts</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="representations-of-ipld-schema-kinds"><a href="#representations-of-ipld-schema-kinds" class="header-anchor">#</a> Representations of IPLD Schema Kinds</h1> <ul><li><a href="#available-representation-strategies">Available Representation Strategies</a></li> <li><a href="#representation-strategy-reference">Representation Strategy Reference</a> <ul><li><a href="#struct-map-representation">Struct <code>map</code> Representation</a></li> <li><a href="#struct-tuple-representation">Struct <code>tuple</code> Representation</a></li> <li><a href="#struct-stringpairs-representation">Struct <code>stringpairs</code> Representation</a></li> <li><a href="#struct-stringjoin-representation">Struct <code>stringjoin</code> Representation</a></li> <li><a href="#struct-listpairs-representation">Struct <code>listpairs</code> Representation</a></li> <li><a href="#map-map-representation">Map <code>map</code> Representation</a></li> <li><a href="#map-stringpairs-representation">Map <code>stringpairs</code> Representation</a></li> <li><a href="#map-listpairs-representation">Map <code>listpairs</code> Representation</a></li> <li><a href="#union-keyed-representation">Union <code>keyed</code> Representation</a></li> <li><a href="#union-kinded-representation">Union <code>kinded</code> Representation</a></li> <li><a href="#union-envelope-representation">Union <code>envelope</code> Representation</a></li> <li><a href="#union-inline-representation">Union <code>inline</code> Representation</a></li> <li><a href="#union-byteprefix-representation">Union <code>byteprefix</code> Representation</a></li> <li><a href="#enum-string-representation">Enum <code>string</code> Representation</a></li> <li><a href="#enum-int-representation">Enum <code>int</code> Representation</a></li></ul></li></ul> <p>A type at the Schema layer must be mapped onto a representation expressible within the Data Model. Each Schema type, therefore, has a &quot;representation kind&quot; which dictates what Data Model kind it is represented as. Each Schema type has a &quot;representation strategy&quot; for converting it, where required, into a &quot;representation kind&quot;.</p> <p>For all Schema kinds which have direct equivalents in the Data Model (e.g. Int, String, Float), that kind is also the representation kind and there is a default representation strategy (mostly implicitly) named after that kind, i.e. a String schema kind has a String representation kind and also a <code>string</code> representation strategy that is a direct transferrence through the Data Model. The default representation is, broadly speaking, a no-op: a string remains a string, and a map is easy to enough to represent as a map!</p> <p>The Schema layer introduces additional kinds (see <a href="/schemas/schema-kinds.html">IPLD Schema Kinds</a>) that can be thought of as &quot;perceived kinds&quot;, in that they have no direct equivalent in the Data Model but can be represented there and perceived as something different when passing through the Schema layer. Most also have default mappings.</p> <p>For example, A Struct maps directly to a Data Model Map, where the Struct's fields are Map keys and the Struct's field's values are the values found at the values of the Map's keys:</p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Foo</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  x   Int
  y   Int
  msg String
<span class="token punctuation">}</span>
</code></pre></div><p>May be deserialized from a JSON map:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;x&quot;</span><span class="token operator">:</span> <span class="token number">10005510</span><span class="token punctuation">,</span>
  <span class="token property">&quot;y&quot;</span><span class="token operator">:</span> <span class="token number">-21183</span><span class="token punctuation">,</span>
  <span class="token property">&quot;msg&quot;</span><span class="token operator">:</span> <span class="token string">&quot;A treasure chest is found at this location&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>By default, Enums map to String kinds where no other strategy is declared. Unions are a special case as there's no single widely agreed upon transcription pattern for unions (from before the establishment of IPLD), so these require
an explicit choice.</p> <p>Maps, Structs, Enums and Unions all have more than one possible representation strategy.</p> <p>The default representation strategy for Maps, Struct and Enums is implicit and need not be stated, but we could rewrite our example above to be explicit:</p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Foo</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  x   Int
  y   Int
  msg String
<span class="token representation">} <span class="token builtin">representation</span></span> map
</code></pre></div><p>Representation strategies are identified by one primary keyword, which indicates what kind in the Data Model will be transcribed to. Some representation strategies have additional parameters, some optional and some mandatory. Such parameters, where they apply to the type as a whole, may be located inside a separate block (<code>{</code>, <code>}</code>) following the declaration of the representation strategy. Where those parameters impact specific fields of a type, they are presented inline with the field in parens (<code>(</code>, <code>)</code>) to indicate that they do not directly impact the user-facing form of the type but rather the serialized form.</p> <p>For example, a type declaration laden with representation parameters:</p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Foo</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  x Int <span class="token punctuation">(</span>rename <span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span>
  y Int <span class="token punctuation">(</span>rename <span class="token string">&quot;b&quot;</span> implicit <span class="token string">&quot;0&quot;</span><span class="token punctuation">)</span>
  msg String
<span class="token representation">} <span class="token builtin">representation</span></span> stringpairs <span class="token punctuation">{</span>
  innerDelim <span class="token string">&quot;=&quot;</span>
  entryDelim <span class="token string">&quot;,&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="available-representation-strategies"><a href="#available-representation-strategies" class="header-anchor">#</a> Available Representation Strategies</h2> <p>Schema kinds for which no meaningful customization is possible: Null, Boolean, Integer, Float, String, Bytes, List and Link are not included in this list. Custom custom representation strategies for these kinds has not been ruled out and may be introduced in the future.</p> <p>Discussion of Advanced Data Layouts and their ability to override the representation strategy of various type can be found in <a href="/schemas/advanced-layouts.html">Advanced Layouts for IPLD Schemas</a>.</p> <ul><li><strong>Map</strong> <ul><li><code>map</code>: <em>(default)</em> transcribes to <em>Map</em> in the Data Model.</li> <li><code>stringpairs</code>: transcribes to <em>String</em> in the Data Model.</li> <li><code>listpairs</code>: transcribes to <em>List</em> (of Lists) in the Data Model.</li></ul></li> <li><strong>Union</strong> <ul><li><code>keyed</code>: transcribes to a single-entry <em>Map</em> in the Data Model.</li> <li><code>kinded</code>: transcribes to varying kinds in the Data Model, see below for details.</li> <li><code>envelope</code>: transcribes to a dual-entry <em>Map</em> in the Data Model.</li> <li><code>inline</code>: transcribes to a <em>Map</em> in the Data Model (and has additional limitations).</li> <li><code>byteprefix</code>: transcribes to <em>Bytes</em> in the Data Model, only usable for unions of Bytes.</li></ul></li> <li><strong>Struct</strong> <ul><li><code>map</code>: <em>(default)</em> transcribes to <em>Map</em> in the Data Model.</li> <li><code>tuple</code>: transcribes to <em>List</em> in the Data Model.</li> <li><code>stringpairs</code>: transcribes to <em>String</em> in the Data Model.</li> <li><code>stringjoin</code>: transcribes to <em>String</em> in the Data Model.</li> <li><code>listpairs</code>: transcribes to <em>List</em> (of Lists) in the Data Model.</li></ul></li> <li><strong>Enum</strong> <ul><li><code>string</code>: <em>(default)</em> transcribes the enum values as <em>String</em> in the Data Model.</li> <li><code>int</code>: transcribes the enum values as <em>Int</em> in the Data Model.</li></ul></li></ul> <p>Each of these representation strategies will be explored in detail in below.</p> <h2 id="representation-strategy-reference"><a href="#representation-strategy-reference" class="header-anchor">#</a> Representation Strategy Reference</h2> <h3 id="struct-map-representation"><a href="#struct-map-representation" class="header-anchor">#</a> Struct <code>map</code> Representation</h3> <p><strong>Representation Kind: Map</strong></p> <p>A Data Model Map representation of Structs means that the Struct is represented as a Map, where the keys are the names of the Struct fields. This is a common and natural way to represent Structs and is therefore their default representation. As the default, this strategy is inferred in absence of any other.</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Foo</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  fieldOne String
  fieldTwo Bool
<span class="token representation">} <span class="token builtin">representation</span></span> map
</code></pre></div><p>In this case, <code>representation map</code> could have been elided.</p> <p>Some data matching the <code>Foo</code> Struct (shown as JSON) is:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;fieldOne&quot;</span><span class="token operator">:</span> <span class="token string">&quot;this is field one&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;fieldTwo&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre></div><p>The <code>map</code> Struct representation strategy also allows for field-specific parameters which may be specified after the fields in the main declaration. The two parameters are:</p> <ul><li><code>rename</code> to declare that at serialization and deserialization, this field has an alternate name in the underlying Data Model Map. This may be useful for providing verbose names at the Schema layer but compact names in the encoding, for example.</li> <li><code>implicit</code> to declare that a particular value of this field is assumed if the field is omitted from serialized form. This applies to both serialization and deserialization. A common example may be <code>implicit &quot;false&quot;</code> so that a Bool field need only be present in the serialized form when it is <code>true</code>.</li></ul> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Foo</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  fieldOne String <span class="token punctuation">(</span>rename <span class="token string">&quot;one&quot;</span><span class="token punctuation">)</span>
  fieldTwo Bool <span class="token punctuation">(</span>rename <span class="token string">&quot;two&quot;</span> implicit <span class="token string">&quot;false&quot;</span><span class="token punctuation">)</span>
<span class="token representation">} <span class="token builtin">representation</span></span> map
</code></pre></div><p>The field-specific parameters (<code>rename</code> and <code>implicit</code>) are only available for the <code>map</code> Struct representation strategy. They are technically possible in some other forms (i.e. <code>listpairs</code> and <code>stringpairs</code>) and support may be extended in the future.</p> <p>See <a href="/schemas/schema-kinds.html#Value-Type-Modifiers">Value Type Modifiers</a> for a discussion on such matters as well as the impacts on value cardinality.</p> <h3 id="struct-tuple-representation"><a href="#struct-tuple-representation" class="header-anchor">#</a> Struct <code>tuple</code> Representation</h3> <p><strong>Representation Kind: List</strong></p> <p>The <code>tuple</code> Struct representation strategy allows Structs to be packed into a compact List representation. This List representation drops the Struct field's names from the representation entirely and relies entirely on the order of elements to denote meaning. As such, it is generally a very compact way to represent data.</p> <p><code>tuple</code> Struct representation strategies should be used cautiously. Since they contain little in the way of &quot;self-describing&quot; information, <code>tuple</code> Struct representations can make for very fragile protocols, increase the difficulty of migrations, and make serialized data incomprehensible without the schema information in hand.</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Foo</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  fieldOne String
  fieldTwo Bool
<span class="token representation">} <span class="token builtin">representation</span></span> tuple
</code></pre></div><p>Some data matching the <code>Foo</code> Struct (shown as JSON) is:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">[</span><span class="token string">&quot;this is field one&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span>
</code></pre></div><p>Notice how this is the same data as in the <code>map</code> Struct representation strategy example above; it's just much more compact than it was in the map representation (and beware: correspondingly less self-describing!).</p> <p>Optional or implicit fields are not possible with the <code>tuple</code> Struct representation strategy, all elements must be present.</p> <p>No field-specific parameters are available for the <code>tuple</code> Struct representation strategy (i.e. <code>implicit</code> and <code>rename</code> which are available for <code>map</code>). One general parameter is available:</p> <ul><li><code>fieldOrder</code> declares that the fields are serialized in a particular order that may be different from the order presented in the type descriptor. This option is implicitly set to the declared order but may be overridden where needed.</li></ul> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Foo</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  fieldOne String
  fieldTwo Bool
<span class="token representation">} <span class="token builtin">representation</span></span> tuple <span class="token punctuation">{</span>
  fieldOrder <span class="token punctuation">[</span><span class="token string">&quot;fieldTwo&quot;</span>, <span class="token string">&quot;fieldOne&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Serialization of such a type in JSON may appear as:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">[</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">&quot;this is field one&quot;</span> <span class="token punctuation">]</span>
</code></pre></div><h3 id="struct-stringpairs-representation"><a href="#struct-stringpairs-representation" class="header-anchor">#</a> Struct <code>stringpairs</code> Representation</h3> <p><strong>Representation Kind: String</strong></p> <p>The <code>stringpairs</code> Struct representation strategy encodes a Struct to a single String. It should be used with special caution as there are no escaping mechanisms in place to prevent incompatible data from disrupting the encoding and causing errors during decode operations.</p> <p>The encoding presents key / value pairs as a delimited String. e.g. <code>&quot;k1=v1,k2=v2&quot;</code> rather than <code>{ &quot;k1&quot;: &quot;v1&quot;, &quot;k2&quot;: &quot;v2&quot; }</code> if the same data used a <code>map</code> Struct representation strategy. The entry delimiter and the key / value (inner) delimiter must be specified as general parameters when <code>stringpairs</code> is used, there is no default for these. In our example, the <code>entryDelim</code> would be <code>&quot;,&quot;</code> while the <code>innerDelim</code> would be <code>&quot;=&quot;</code>.</p> <p>This serial representation is strictly limited: the domain of available for field names must exclude the <code>innerDelim</code> in any position and values and keys must exclude the <code>entryDelim</code> in any position. There is no facility for escaping, such as in escaped CSV. This also leads to a further restriction that this representation is only valid for Structs whose values may all be encoded to String kind in the Data Model layer. It is recommended, therefore, that its use be limited to Structs containing values with the basic data model kinds that exclude multiple values, i.e. no Maps, Lists, and therefore Structs or Unions or any other type that has a recursive representation kind.</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Foo</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  fieldOne String
  fieldTwo Bool
<span class="token representation">} <span class="token builtin">representation</span></span> stringpairs <span class="token punctuation">{</span>
  innerDelim <span class="token string">&quot;=&quot;</span>
  entryDelim <span class="token string">&quot;,&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Some data matching the <code>Foo</code> Struct (shown as JSON) is:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token string">&quot;fieldOne=this is field one,fieldTwo=true&quot;</span>
</code></pre></div><p>No field-specific parameters are available for the <code>stringpairs</code> Struct representation strategy (i.e. <code>implicit</code> and <code>rename</code> which are available for <code>map</code>). The two general parameters are mandatory:</p> <ul><li><code>innerDelim</code> declares a quoted string that is used to delimit a key from a value</li> <li><code>entryDelim</code> declares a quoted string that is used to delimit entries from each other</li></ul> <h3 id="struct-stringjoin-representation"><a href="#struct-stringjoin-representation" class="header-anchor">#</a> Struct <code>stringjoin</code> Representation</h3> <p><strong>Representation Kind: String</strong></p> <p>The <code>stringjoin</code> Struct representation strategy encodes a Struct to a single String. It should be used with special caution as there are no escaping mechanisms in place to prevent incompatible data from disrupting the encoding and causing errors during decode operations.</p> <p><code>stringjoin</code> is very similar to <code>stringpairs</code> and caries many of the same notes of caution. The difference is that <code>stringjoin</code> omits the keys and relies instead on declared field order to assume the location of the field values, similar to the <code>tuple</code> representation.</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Fizzlebop</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  a String
  b String
<span class="token representation">} <span class="token builtin">representation</span></span> stringjoin <span class="token punctuation">{</span>
  join <span class="token string">&quot;:&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Some data matching the <code>Fizzlebop</code> Struct (shown as JSON) is:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token string">&quot;value-of-a:value-of-b&quot;</span>
</code></pre></div><p>Since there is no escaping mechanism, no value can contain the string used for <code>join</code> as this would disrupt decoding and result in an error. Additionally, optional or implicit fields are not possible with the <code>stringjoin</code> Struct representation strategy, all elements must be present.</p> <p>No field-specific parameters are available for the <code>stringjoin</code> Struct representation strategy (i.e. <code>implicit</code> and <code>rename</code> which are available for <code>map</code>). The single general parameter is mandatory:</p> <ul><li><code>join</code> declares a quoted string that is used to delimit field values</li></ul> <h3 id="struct-listpairs-representation"><a href="#struct-listpairs-representation" class="header-anchor">#</a> Struct <code>listpairs</code> Representation</h3> <p><strong>Representation Kind: List</strong></p> <p>The <code>listpairs</code> Struct representation strategy encodes a Struct to a List of Lists at the Data Model layer. Similar to the <code>tuple</code> representation but the keys are also included in the encoding so the serialized form is not as opaque and more self-describing than <code>tuple</code>.</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Foo</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  fieldOne String
  fieldTwo Bool
<span class="token representation">} <span class="token builtin">representation</span></span> listpairs
</code></pre></div><p>Some data matching the <code>Foo</code> Struct (shown as JSON) is:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&quot;fieldOne&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;this is field one&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&quot;fieldTwo&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre></div><p>Each entry of the parent List is a List containing exactly two entries, where the first is the exact field name and the second is the value.</p> <p>No field-specific parameters are available for the <code>listpairs</code> Struct representation strategy (i.e. <code>implicit</code> and <code>rename</code> which are available for <code>map</code>).</p> <h3 id="map-map-representation"><a href="#map-map-representation" class="header-anchor">#</a> Map <code>map</code> Representation</h3> <p><strong>Representation Kind: Map</strong></p> <p>Schema Maps are represented as Data Model Maps by default. Schema Maps differ from Data Model Maps in that their value types are constrained.</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">FloatMap</span></span> <span class="token punctuation">{</span>String<span class="token punctuation">:</span>Float<span class="token punctuation">}</span>
</code></pre></div><p>Some data matching the <code>FloatMap</code> Map (shown as JSON) is:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;x&quot;</span><span class="token operator">:</span> <span class="token number">0.812411</span><span class="token punctuation">,</span>
  <span class="token property">&quot;y&quot;</span><span class="token operator">:</span> <span class="token number">0.15</span><span class="token punctuation">,</span>
  <span class="token property">&quot;z&quot;</span><span class="token operator">:</span> <span class="token number">0.0</span>
<span class="token punctuation">}</span>
</code></pre></div><p>No parameters are available for the <code>map</code> Map representation strategy.</p> <h3 id="map-stringpairs-representation"><a href="#map-stringpairs-representation" class="header-anchor">#</a> Map <code>stringpairs</code> Representation</h3> <p><strong>Representation Kind: String</strong></p> <p>The <code>stringpairs</code> Map representation strategy is roughly the same the <code>stringpairs</code> for Structs. It encodes a Map to a single String. It should be used with special caution as there are no escaping mechanisms in place to prevent incompatible data from disrupting the encoding and causing errors during decode operations.</p> <p>The encoding presents key / value pairs as a delimited String. e.g. <code>&quot;k1=v1,k2=v2&quot;</code> rather than <code>{ &quot;k1&quot;: &quot;v1&quot;, &quot;k2&quot;: &quot;v2&quot; }</code> if the same data used a <code>map</code> Map representation strategy. The entry delimiter and the key / value (inner) delimiter must be specified as general parameters when <code>stringpairs</code> is used, there is no default for these. In our example, the <code>entryDelim</code> would be <code>&quot;,&quot;</code> while the <code>innerDelim</code> would be <code>&quot;=&quot;</code>.</p> <p>This serial representation is strictly limited: the domain of available for keys must exclude the <code>innerDelim</code> in any position and values and keys must exclude the <code>entryDelim</code> in any position. There is no facility for escaping, such as in escaped CSV. This also leads to a further restriction that this representation is only valid for Maps whose values may all be encoded to String kind in the Data Model layer. It is recommended, therefore, that its use be limited to Maps containing values with the basic data model kinds that exclude multiple values, i.e. no Maps, Lists, and therefore Structs or Unions or any other type that has a recursive representation kind.</p> <p><strong>Example</strong></p> <p>A string that is similar in format to the options found in an /etc/fstab file might be defined as:</p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">MountOptions</span></span> <span class="token punctuation">{</span>String<span class="token punctuation">:</span>String<span class="token punctuation">}</span> representation stringpairs <span class="token punctuation">{</span>
  innerDelim <span class="token string">&quot;=&quot;</span>
  entryDelim <span class="token string">&quot;,&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Some data matching the <code>MountOptions</code> Struct (shown as JSON) is:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token string">&quot;keys=values,serialized=thusly&quot;</span>
</code></pre></div><p>The two general parameters for the <code>stringpairs</code> Map representation strategy are mandatory:</p> <ul><li><code>innerDelim</code> declares a quoted string that is used to delimit a key from a value</li> <li><code>entryDelim</code> declares a quoted string that is used to delimit entries from each other</li></ul> <h3 id="map-listpairs-representation"><a href="#map-listpairs-representation" class="header-anchor">#</a> Map <code>listpairs</code> Representation</h3> <p><strong>Representation Kind: List</strong></p> <p>The <code>listpairs</code> Map representation strategy is roughly the same the <code>listpairs</code> for Structs. It encodes a Map to a List of Lists at the Data Model layer.</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">FloatMap</span></span> <span class="token punctuation">{</span>String<span class="token punctuation">:</span>Float<span class="token punctuation">}</span> representation listpairs
</code></pre></div><p>Some data matching the <code>FloatMap</code> Map (shown as JSON) is:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&quot;x&quot;</span><span class="token punctuation">,</span> <span class="token number">0.812411</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&quot;y&quot;</span><span class="token punctuation">,</span> <span class="token number">0.15</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&quot;z&quot;</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre></div><p>Each entry of the parent List is a List containing exactly two entries, where the first is the key String and the second is the value.</p> <p>No parameters are available for the <code>listpairs</code> Map representation strategy.</p> <h3 id="union-keyed-representation"><a href="#union-keyed-representation" class="header-anchor">#</a> Union <code>keyed</code> Representation</h3> <p><strong>Representation Kind: Map</strong> (single entry of current node)</p> <p>A Union using a <code>keyed</code> representation strategy determines which of the types in the Union is present by looking at the keys in the Map at the current node. Exactly one of the keys listed in the Union must be present at any such Union node for it to be valid.</p> <p>When using a <code>keyed</code> Union representation strategy, the Union lists the quoted keys after each constituent type. These keys must be unique strings.</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">MyKeyedUnion</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
  <span class="token punctuation">|</span> Foo <span class="token string">&quot;foo&quot;</span>
  <span class="token punctuation">|</span> Bar <span class="token string">&quot;bar&quot;</span>
<span class="token representation">} <span class="token builtin">representation</span></span> keyed

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Foo</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  froz Bool
<span class="token punctuation">}</span>

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Bar</span></span> <span class="token keyword">int</span>
</code></pre></div><p>Some data matching <code>MyKeyedUnion</code>, finding <code>Foo</code> present, (shown as JSON) is:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;foo&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;froz&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>This data would also match, as <code>Bar</code>:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;bar&quot;</span><span class="token operator">:</span> <span class="token number">12</span>
<span class="token punctuation">}</span>
</code></pre></div><p>No parameters are available for the <code>keyed</code> Union representation strategy.</p> <h3 id="union-kinded-representation"><a href="#union-kinded-representation" class="header-anchor">#</a> Union <code>kinded</code> Representation</h3> <p><strong>Representation Kind: <em>Various</em></strong></p> <p><code>kinded</code> Unions discriminate between constituent types of the Union by inspecting the <em>representation kind</em> present at the current node. Each type in the union must be associated with a unique representation kind and exactly one of these representation kinds must be present at the node for it to be a valid Union of the type in question.</p> <p>The <code>kinded</code> Union representation strategy doesn't introduce any kind of wrapping Map in the serialized form at all. Maps are only present if <code>map</code> is one of the kinds listed in the Union. Contrast this with other union representation strategies, all of which use at least one layer of Map in their representation (other than <code>byteprefix</code> Unions which are a special case).</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">MyKindedUnion</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
  <span class="token punctuation">|</span> Foo map
  <span class="token punctuation">|</span> Bar <span class="token keyword">int</span>
<span class="token representation">} <span class="token builtin">representation</span></span> kinded

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Foo</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  froz Bool
<span class="token punctuation">}</span>

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Bar</span></span> <span class="token keyword">int</span>
</code></pre></div><p>Some data matching <code>MyKindedUnion</code>, finding <code>Foo</code> present, (shown as JSON) is:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;froz&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre></div><p>This data would also match, as <code>Bar</code>:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token number">12</span>
</code></pre></div><p>The syntax used in the type declaration is different for <code>kinded</code> Unions in comparison to other Union representation strategies. <code>kinded</code> Unions list a representation kind, unquoted, unlike other representation strategies which list a quoted key or discriminator (other than <code>byteprefix</code> Unions, a special case).</p> <p>The kind listed after each element of the Union must be a valid representation kind, that is, a kind at the Data Model layer, such as <code>string</code> and <code>map</code>. Schema kinds are not valid as they don't denote representation kinds (i.e. <code>struct</code> would not be a valid kind for a <code>kinded</code> Union).</p> <p>It is only possible to discriminate <em>distinct</em> representation kinds in a <code>kinded</code> Union, there may be at most one of each possible representation kind present in such a Union.</p> <p>Note that a type that has a different Schema kind to its representation kind uses the latter:</p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">MyKindedUnion</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
  <span class="token punctuation">|</span> Foo map
  <span class="token punctuation">|</span> Bar <span class="token keyword">int</span>
  <span class="token punctuation">|</span> Bang <span class="token keyword">string</span>
<span class="token representation">} <span class="token builtin">representation</span></span> kinded

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Foo</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  froz Bool
<span class="token punctuation">}</span>

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Bar</span></span> <span class="token keyword">int</span>

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Bang</span></span> <span class="token punctuation">{</span>String<span class="token punctuation">:</span>Int<span class="token punctuation">}</span> representation stringpairs <span class="token punctuation">{</span>
  innerDelim <span class="token string">&quot;:&quot;</span>
  entryDelim <span class="token string">&quot;|&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>In this instance, even though <code>Bang</code> presents as a user-facing Schema Map kind, it encodes to a String representation kind and is therefore listed as a <code>string</code> in the <code>kinded</code> Union.</p> <p>No parameters are available for the <code>kinded</code> Union representation strategy.</p> <h3 id="union-envelope-representation"><a href="#union-envelope-representation" class="header-anchor">#</a> Union <code>envelope</code> Representation</h3> <p><strong>Representation Kind: Map</strong> (two entries of current node)</p> <p>An <code>envelope</code> Union representation strategy discriminates between constituent types of the Union by inspecting the value of a pre-determined discriminator key (<code>discriminantKey</code>) in a Map, while the content of the type is decoded from the value of a predetermined content key (<code>contentKey</code>). <code>envelope</code> Unions are only valid for nodes that are Maps in the Data Model layer, it requires the ability to look up two distinct keys.</p> <p>Each constituent type of an <code>envelope</code> Union is accompanied by a quoted string that is unique amongst the types that is used to match against the value of <code>discriminantKey</code> in the current node.</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">MyEnvelopeUnion</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
  <span class="token punctuation">|</span> Foo <span class="token string">&quot;foo&quot;</span>
  <span class="token punctuation">|</span> Bar <span class="token string">&quot;bar&quot;</span>
<span class="token representation">} <span class="token builtin">representation</span></span> envelope <span class="token punctuation">{</span>
  discriminantKey <span class="token string">&quot;tag&quot;</span>
  contentKey <span class="token string">&quot;msg&quot;</span>
<span class="token punctuation">}</span>

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Foo</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  froz Bool
<span class="token punctuation">}</span>

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Bar</span></span> <span class="token keyword">int</span>
</code></pre></div><p>Some data matching <code>MyEnvelopeUnion</code>, finding <code>Foo</code> present, (shown as JSON) is:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;tag&quot;</span><span class="token operator">:</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;msg&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;froz&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>This data would also match, as <code>Bar</code>:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;tag&quot;</span><span class="token operator">:</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;msg&quot;</span><span class="token operator">:</span> <span class="token number">12</span>
<span class="token punctuation">}</span>
</code></pre></div><p>The <code>envelope</code> Union representation strategy is an &quot;envelope&quot; in the sense that the type is addressed within a value of the current node and the type itself is wrapped in another value of the current node, the current node being the envelope that exists only to contain and discriminate the type. <code>envelope</code> Unions are more self-describing and explicit than <code>inline</code> or <code>kinded</code> unions but are roughly comparable to <code>keyed</code> unions in that sense.</p> <p>Two general parameters are mandatory for the <code>envelope</code> Union representation strategy:</p> <ul><li><code>discriminantKey</code> defines a quoted string that is used to look up a string in the Map at the current node to match against the keys provided with each of the constituent types of the Union.</li> <li><code>contentKey</code> defines a quoted string that is used to look up a node that may decode to the type that the discriminator determines is the type of the Union.</li></ul> <h3 id="union-inline-representation"><a href="#union-inline-representation" class="header-anchor">#</a> Union <code>inline</code> Representation</h3> <p><strong>Representation Kind: Map</strong> (only some entries of current node)</p> <p>The <code>inline</code> Union representation strategy decodes a Map node from the Data Model layer into one of the constituent types of the union by discriminating based on the value of a pre-determined key of that Map (<code>discriminantKey</code>).</p> <p>This strategy is similar to the <code>envelope</code> Union representation strategy but it does not traverse into a child node to decode the type, instead it decodes that type from the current node. Therefore, constituent type of an <code>inline</code> Union <em>must</em> have a Map representation kind (i.e. a Struct or a Map with default representation strategies).</p> <p>Each constituent type of an <code>inline</code> Union is accompanied by a quoted string that is unique amongst the types that is used to match against the value of <code>discriminantKey</code> in the current node.</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">MyInlineUnion</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
  <span class="token punctuation">|</span> Foo <span class="token string">&quot;foo&quot;</span>
  <span class="token punctuation">|</span> Bar <span class="token string">&quot;bar&quot;</span>
<span class="token representation">} <span class="token builtin">representation</span></span> inline <span class="token punctuation">{</span>
  discriminantKey <span class="token string">&quot;tag&quot;</span>
<span class="token punctuation">}</span>

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Foo</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  froz Bool
<span class="token punctuation">}</span>

<span class="token comment"># Note that Bar is not an int as in our previous examples since this is not</span>
<span class="token comment"># possible with an inline Union</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Bar</span></span> <span class="token builtin">struct</span> <span class="token punctuation">{</span>
  bral String
<span class="token punctuation">}</span>
</code></pre></div><p>Some data matching <code>MyInlineUnion</code>, finding <code>Foo</code> present, (shown as JSON) is:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;tag&quot;</span><span class="token operator">:</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;froz&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre></div><p>This data would also match, as <code>Bar</code>:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;tag&quot;</span><span class="token operator">:</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;bral&quot;</span><span class="token operator">:</span> <span class="token string">&quot;zot&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Using a type that has a representation kind other than a Map with an <code>inline</code> Union would result in an error.</p> <p>One general parameter is mandatory for the <code>inline</code> Union representation strategy:</p> <ul><li><code>discriminantKey</code> defines a quoted string that is used to look up a string in the Map at the current node to match against the keys provided with each of the constituent types of the Union.</li></ul> <h3 id="union-byteprefix-representation"><a href="#union-byteprefix-representation" class="header-anchor">#</a> Union <code>byteprefix</code> Representation</h3> <p><strong>Representation Kind: Bytes</strong></p> <p>The <code>byteprefix</code> Union representation strategy is used strictly for Bytes representation kinds. As there are currently no representation strategies other than the default for Bytes that encode as Bytes at the Data Model layer, the <code>byteprefix</code> Union representation strategy can only be used as a Union between named Bytes types.</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Signature</span></span> <span class="token builtin">union</span> <span class="token punctuation">{</span>
  <span class="token punctuation">|</span> Secp256k1Signature <span class="token number">0</span>
  <span class="token punctuation">|</span> Bls12_381Signature <span class="token number">1</span>
<span class="token representation">} <span class="token builtin">representation</span></span> byteprefix

<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Secp256k1Signature</span></span> <span class="token keyword">bytes</span>
<span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Bls12_381Signature</span></span> <span class="token keyword">bytes</span>
</code></pre></div><p>At the Data Model layer, this presents as Bytes (a byte array), where the first byte is the discriminator (<code>0x00</code> or <code>0x01</code>) and the remainder is sliced to form either of the two types depending on the discriminator.</p> <p>No parameters are available for the <code>byteprefix</code> Union representation strategy.</p> <h3 id="enum-string-representation"><a href="#enum-string-representation" class="header-anchor">#</a> Enum <code>string</code> Representation</h3> <p><strong>Representation Kind: String</strong></p> <p>By default, a Schema Enum is simply represented as a String in the data model. An Enum in a Schema simply defines the list of possible strings that could be used at that node.</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Status</span></span> <span class="token builtin">enum</span> <span class="token punctuation">{</span>
  <span class="token punctuation">|</span> Nope
  <span class="token punctuation">|</span> Yep
  <span class="token punctuation">|</span> Maybe
<span class="token punctuation">}</span>
</code></pre></div><p>This Enum dictates that where <code>Status</code> is used, we should find one of <code>&quot;Nope&quot;</code>, <code>&quot;Yep&quot;</code> or <code>&quot;Maybe&quot;</code>.  No other value is valid where <code>Status</code> is used.</p> <p>Where the serialized Strings are different to the values used for the Enum, they may be provided in parens as field-specific representation parameters:</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Status</span></span> <span class="token builtin">enum</span> <span class="token punctuation">{</span>
  <span class="token punctuation">|</span> Nope <span class="token punctuation">(</span><span class="token string">&quot;Nay&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">|</span> Yep  <span class="token punctuation">(</span><span class="token string">&quot;Yay&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">|</span> Maybe
<span class="token punctuation">}</span>
</code></pre></div><p>In this example, the serialization expects, and uses, the strings <code>Nay</code>, <code>Yay</code> and <code>Maybe</code>.</p> <p>No general parameters are available for the <code>string</code> Enum representation strategy.</p> <h3 id="enum-int-representation"><a href="#enum-int-representation" class="header-anchor">#</a> Enum <code>int</code> Representation</h3> <p><strong>Representation Kind: Int</strong></p> <p>An alternative representation strategy for enums is <code>int</code>, which is closer to what users may expect from Enums in some programming languages that map enum values to integers. In IPLD Schemas we explicitly define the mapping to integers, so the user can dictate the appropriate data model values.</p> <p><strong>Example</strong></p> <div class="language-ipldsch extra-class"><pre class="language-ipldsch"><code><span class="token typedef"><span class="token keyword">type</span> <span class="token class-name">Status</span></span> <span class="token builtin">enum</span> <span class="token punctuation">{</span>
  <span class="token punctuation">|</span> Nope  <span class="token punctuation">(</span><span class="token string">&quot;0&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">|</span> Yep   <span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">|</span> Maybe <span class="token punctuation">(</span><span class="token string">&quot;100&quot;</span><span class="token punctuation">)</span>
<span class="token representation">} <span class="token builtin">representation</span></span> <span class="token keyword">int</span>
</code></pre></div><p>As with the <code>string</code> representaiton strategy, Enums with an <code>int</code> representation strategy still quote the integer strings when provided as field-specific representation parameters. This is standard practice for field-specific representation parameters as they are converted to the correct type depending on context. In this context, they are assumed to be integers so must be convertable to integers.</p> <p>There are no optional values, as in the <code>string</code> representation strategy, all values must be provided when using <code>int</code> representation strategy.</p> <p>In our example, serialization expects, and uses, data model integer values <code>0</code>, <code>1</code>, and <code>100</code>. No other values at this position are valid.</p> <p>No general parameters are available for the <code>int</code> Enum representation strategy.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/ipld/specs/edit/master/schemas/representations.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">9/17/2020, 3:17:59 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      
      <a href="/schemas/schema-kinds.html" class="prev">
        IPLD Schema Kinds
      </a></span> <span class="next"><a href="/schemas/advanced-layouts.html">
        Advanced Layouts
      </a>
      
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.20f730e6.js" defer></script><script src="/assets/js/2.2d6107ed.js" defer></script><script src="/assets/js/74.97b91c2f.js" defer></script>
  </body>
</html>
